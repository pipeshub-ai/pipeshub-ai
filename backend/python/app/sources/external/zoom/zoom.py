"""
zoom.py â€” Auto-generated unified Zoom datasource (single-class ZoomDataSource)
"""

from typing import Any, Dict, List, Optional
import logging

# NOTE: This file is auto-generated. Review & adjust auth/typing as needed.
from app.sources.client.iclient import IClient  # type: ignore


class ZoomDataSource:
    def __init__(self, rest_client: IClient, base_url: str = 'https://api.zoom.us/v2', logger: Optional[logging.Logger] = None) -> None:
        """
        rest_client: IClient providing async request(method, url, params=None, body=None, timeout=None)
        """
        self._rest_client = rest_client
        self._base_url = base_url.rstrip('/')
        self._logger = logger
    # ===== Accounts =====
    async def get_account_lock_settings(self, accountId: str, option: Optional[str] = None, custom_query_fields: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get locked settings

        API: GET /accounts/{accountId}/lock_settings

        Args:
            accountId (str, required): original param name `accountId`
            option (str, optional): original param name `option`
            custom_query_fields (str, optional): original param name `custom_query_fields`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/accounts/{accountId}/lock_settings"

        params: Dict[str, Any] = {}
        if option is not None:
            params['option'] = option
        if custom_query_fields is not None:
            params['custom_query_fields'] = custom_query_fields

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_locked_settings(self, accountId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update locked settings

        API: PATCH /accounts/{accountId}/lock_settings

        Args:
            accountId (str, required): original param name `accountId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/accounts/{accountId}/lock_settings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def account_managed_domain(self, accountId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get account's managed domains

        API: GET /accounts/{accountId}/managed_domains

        Args:
            accountId (str, required): original param name `accountId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/accounts/{accountId}/managed_domains"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_the_account_owner(self, accountId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update the account owner

        API: PUT /accounts/{accountId}/owner

        Args:
            accountId (str, required): original param name `accountId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/accounts/{accountId}/owner"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def account_settings(self, accountId: str, option: Optional[str] = None, custom_query_fields: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get account settings

        API: GET /accounts/{accountId}/settings

        Args:
            accountId (str, required): original param name `accountId`
            option (str, optional): original param name `option`
            custom_query_fields (str, optional): original param name `custom_query_fields`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/accounts/{accountId}/settings"

        params: Dict[str, Any] = {}
        if option is not None:
            params['option'] = option
        if custom_query_fields is not None:
            params['custom_query_fields'] = custom_query_fields

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def account_settings_update(self, accountId: str, option: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update account settings

        API: PATCH /accounts/{accountId}/settings

        Args:
            accountId (str, required): original param name `accountId`
            option (str, optional): original param name `option`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/accounts/{accountId}/settings"

        params: Dict[str, Any] = {}
        if option is not None:
            params['option'] = option

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def account_settings_registration(self, accountId: str, type_param: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get an account's webinar registration settings

        API: GET /accounts/{accountId}/settings/registration

        Args:
            accountId (str, required): original param name `accountId`
            type_param (str, optional): original param name `type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/accounts/{accountId}/settings/registration"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def account_settings_registration_update(self, accountId: str, type_param: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an account's webinar registration settings

        API: PATCH /accounts/{accountId}/settings/registration

        Args:
            accountId (str, required): original param name `accountId`
            type_param (str, optional): original param name `type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/accounts/{accountId}/settings/registration"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def upload_vb(self, accountId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Upload virtual background files

        API: POST /accounts/{accountId}/settings/virtual_backgrounds

        Args:
            accountId (str, required): original param name `accountId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/accounts/{accountId}/settings/virtual_backgrounds"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def del_vb(self, accountId: str, file_ids: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete virtual background files

        API: DELETE /accounts/{accountId}/settings/virtual_backgrounds

        Args:
            accountId (str, required): original param name `accountId`
            file_ids (str, optional): original param name `file_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/accounts/{accountId}/settings/virtual_backgrounds"

        params: Dict[str, Any] = {}
        if file_ids is not None:
            params['file_ids'] = file_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def account_trusted_domain(self, accountId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get account's trusted domains

        API: GET /accounts/{accountId}/trusted_domains

        Args:
            accountId (str, required): original param name `accountId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/accounts/{accountId}/trusted_domains"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_chat(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get chat metrics

        API: GET /metrics/chat

        Args:
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/chat"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_client_feedback(self, from_param: Optional[str] = None, to: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List Zoom meetings client feedback

        API: GET /metrics/client/feedback

        Args:
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/client/feedback"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_client_feedback_detail(
        feedbackId: str,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get zoom meetings client feedback

        API: GET /metrics/client/feedback/{feedbackId}

        Args:
            feedbackId (str, required): original param name `feedbackId`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/client/feedback/{feedbackId}"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_meeting_satisfaction(self, from_param: Optional[str] = None, to: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List client meeting satisfaction

        API: GET /metrics/client/satisfaction

        Args:
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/client/satisfaction"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_client_versions(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List the client versions

        API: GET /metrics/client_versions

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/client_versions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_crc(self, from_param: Optional[str] = None, to: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get CRC port usage

        API: GET /metrics/crc

        Args:
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/crc"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_issue_zoom_room(self, from_param: Optional[str] = None, to: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get top 25 Zoom Rooms with issues

        API: GET /metrics/issues/zoomrooms

        Args:
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/issues/zoomrooms"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_issue_detail_zoom_room(
        zoomroomId: str,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get issues of Zoom Rooms

        API: GET /metrics/issues/zoomrooms/{zoomroomId}

        Args:
            zoomroomId (str, required): original param name `zoomroomId`
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/issues/zoomrooms/{zoomroomId}"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_meetings(
        type_param: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        group_id: Optional[str] = None,
        group_include_participant: Optional[bool] = None,
        include_fields: Optional[str] = None,
        query_date_type: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List meetings

        API: GET /metrics/meetings

        Args:
            type_param (str, optional): original param name `type`
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            group_id (str, optional): original param name `group_id`
            group_include_participant (bool, optional): original param name `group_include_participant`
            include_fields (str, optional): original param name `include_fields`
            query_date_type (str, optional): original param name `query_date_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/meetings"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if group_id is not None:
            params['group_id'] = group_id
        if group_include_participant is not None:
            params['group_include_participant'] = group_include_participant
        if include_fields is not None:
            params['include_fields'] = include_fields
        if query_date_type is not None:
            params['query_date_type'] = query_date_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_meeting_detail(self, meetingId: str, type_param: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get meeting details

        API: GET /metrics/meetings/{meetingId}

        Args:
            meetingId (str, required): original param name `meetingId`
            type_param (str, optional): original param name `type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/meetings/{meetingId}"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_meeting_participants(
        meetingId: str,
        type_param: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        include_fields: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List meeting participants

        API: GET /metrics/meetings/{meetingId}/participants

        Args:
            meetingId (str, required): original param name `meetingId`
            type_param (str, optional): original param name `type`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            include_fields (str, optional): original param name `include_fields`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/meetings/{meetingId}/participants"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if include_fields is not None:
            params['include_fields'] = include_fields

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_meeting_participants_qos(
        meetingId: str,
        type_param: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List meeting participants QoS

        API: GET /metrics/meetings/{meetingId}/participants/qos

        Args:
            meetingId (str, required): original param name `meetingId`
            type_param (str, optional): original param name `type`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/meetings/{meetingId}/participants/qos"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def participant_feedback(
        meetingId: str,
        type_param: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get post meeting feedback

        API: GET /metrics/meetings/{meetingId}/participants/satisfaction

        Args:
            meetingId (str, required): original param name `meetingId`
            type_param (str, optional): original param name `type`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/meetings/{meetingId}/participants/satisfaction"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_meeting_participant_share(
        meetingId: str,
        type_param: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get meeting sharing/recording details

        API: GET /metrics/meetings/{meetingId}/participants/sharing

        Args:
            meetingId (str, required): original param name `meetingId`
            type_param (str, optional): original param name `type`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/meetings/{meetingId}/participants/sharing"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_meeting_participant_qos(self, meetingId: str, participantId: str, type_param: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get meeting participant QoS

        API: GET /metrics/meetings/{meetingId}/participants/{participantId}/qos

        Args:
            meetingId (str, required): original param name `meetingId`
            participantId (str, required): original param name `participantId`
            type_param (str, optional): original param name `type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/meetings/{meetingId}/participants/{participantId}/qos"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_quality(self, from_param: Optional[str] = None, to: Optional[str] = None, type_param: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get meeting quality scores

        API: GET /metrics/quality

        Args:
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            type_param (str, optional): original param name `type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/quality"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if type_param is not None:
            params['type'] = type_param

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_webinars(
        type_param: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        group_id: Optional[str] = None,
        group_include_participant: Optional[bool] = None,
        query_date_type: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List webinars

        API: GET /metrics/webinars

        Args:
            type_param (str, optional): original param name `type`
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            group_id (str, optional): original param name `group_id`
            group_include_participant (bool, optional): original param name `group_include_participant`
            query_date_type (str, optional): original param name `query_date_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/webinars"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if group_id is not None:
            params['group_id'] = group_id
        if group_include_participant is not None:
            params['group_include_participant'] = group_include_participant
        if query_date_type is not None:
            params['query_date_type'] = query_date_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_webinar_detail(self, webinarId: str, type_param: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get webinar details

        API: GET /metrics/webinars/{webinarId}

        Args:
            webinarId (str, required): original param name `webinarId`
            type_param (str, optional): original param name `type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/webinars/{webinarId}"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_webinar_participants(
        webinarId: str,
        type_param: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        include_fields: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get webinar participants

        API: GET /metrics/webinars/{webinarId}/participants

        Args:
            webinarId (str, required): original param name `webinarId`
            type_param (str, optional): original param name `type`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            include_fields (str, optional): original param name `include_fields`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/webinars/{webinarId}/participants"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if include_fields is not None:
            params['include_fields'] = include_fields

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_webinar_participants_qos(
        webinarId: str,
        type_param: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List webinar participant QoS

        API: GET /metrics/webinars/{webinarId}/participants/qos

        Args:
            webinarId (str, required): original param name `webinarId`
            type_param (str, optional): original param name `type`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/webinars/{webinarId}/participants/qos"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def participant_webinar_feedback(
        webinarId: str,
        type_param: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get post webinar feedback

        API: GET /metrics/webinars/{webinarId}/participants/satisfaction

        Args:
            webinarId (str, required): original param name `webinarId`
            type_param (str, optional): original param name `type`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/webinars/{webinarId}/participants/satisfaction"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_webinar_participant_share(
        webinarId: str,
        type_param: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get webinar sharing/recording details

        API: GET /metrics/webinars/{webinarId}/participants/sharing

        Args:
            webinarId (str, required): original param name `webinarId`
            type_param (str, optional): original param name `type`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/webinars/{webinarId}/participants/sharing"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_webinar_participant_qos(self, webinarId: str, participantId: str, type_param: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get webinar participant QoS

        API: GET /metrics/webinars/{webinarId}/participants/{participantId}/qos

        Args:
            webinarId (str, required): original param name `webinarId`
            participantId (str, required): original param name `participantId`
            type_param (str, optional): original param name `type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/webinars/{webinarId}/participants/{participantId}/qos"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_zoom_rooms(self, page_size: Optional[int] = None, page_number: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List Zoom Rooms

        API: GET /metrics/zoomrooms

        Args:
            page_size (int, optional): original param name `page_size`
            page_number (int, optional): original param name `page_number`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/zoomrooms"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if page_number is not None:
            params['page_number'] = page_number
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_zoom_room_issue(self, from_param: Optional[str] = None, to: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get top 25 issues of Zoom Rooms

        API: GET /metrics/zoomrooms/issues

        Args:
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/zoomrooms/issues"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_zoom_room(
        zoomroomId: str,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get Zoom Rooms details

        API: GET /metrics/zoomrooms/{zoomroomId}

        Args:
            zoomroomId (str, required): original param name `zoomroomId`
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/zoomrooms/{zoomroomId}"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def downloadfilesfrom_data_request(self, fileId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get download link for data access request file

        API: GET /data_requests/files/{fileId}/url

        Args:
            fileId (str, required): original param name `fileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/data_requests/files/{fileId}/url"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_data_requests_history(self, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List data request history

        API: GET /data_requests/requests

        Args:
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/data_requests/requests"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_data_access_request(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create data  (export/deletion) request

        API: POST /data_requests/requests

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/data_requests/requests"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_downloadable_filesfor_data_request(self, requestId: str, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List downloadable files for export data request

        API: GET /data_requests/requests/{requestId}

        Args:
            requestId (str, required): original param name `requestId`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/data_requests/requests/{requestId}"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def cancel_data_request(self, requestId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Cancel data deletion request

        API: DELETE /data_requests/requests/{requestId}

        Args:
            requestId (str, required): original param name `requestId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/data_requests/requests/{requestId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def information_barriers_list(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List information Barrier policies

        API: GET /information_barriers/policies

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/information_barriers/policies"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def information_barriers_create(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create an Information Barrier policy

        API: POST /information_barriers/policies

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/information_barriers/policies"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def information_barriers_get(self, policyId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get an Information Barrier policy by ID

        API: GET /information_barriers/policies/{policyId}

        Args:
            policyId (str, required): original param name `policyId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/information_barriers/policies/{policyId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def information_barriers_delete(self, policyId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove an Information Barrier policy

        API: DELETE /information_barriers/policies/{policyId}

        Args:
            policyId (str, required): original param name `policyId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/information_barriers/policies/{policyId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def information_barriers_update(self, policyId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an Information Barriers policy

        API: PATCH /information_barriers/policies/{policyId}

        Args:
            policyId (str, required): original param name `policyId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/information_barriers/policies/{policyId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def roles(self, type_param: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List roles

        API: GET /roles

        Args:
            type_param (str, optional): original param name `type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/roles"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_role(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a role

        API: POST /roles

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/roles"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_role_information(self, roleId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get role information

        API: GET /roles/{roleId}

        Args:
            roleId (str, required): original param name `roleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/roles/{roleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_role(self, roleId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a role

        API: DELETE /roles/{roleId}

        Args:
            roleId (str, required): original param name `roleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/roles/{roleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_role(self, roleId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update role information

        API: PATCH /roles/{roleId}

        Args:
            roleId (str, required): original param name `roleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/roles/{roleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def role_members(
        roleId: str,
        page_count: Optional[str] = None,
        page_number: Optional[int] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List members in a role

        API: GET /roles/{roleId}/members

        Args:
            roleId (str, required): original param name `roleId`
            page_count (str, optional): original param name `page_count`
            page_number (int, optional): original param name `page_number`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/roles/{roleId}/members"

        params: Dict[str, Any] = {}
        if page_count is not None:
            params['page_count'] = page_count
        if page_number is not None:
            params['page_number'] = page_number
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_role_members(self, roleId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign a role

        API: POST /roles/{roleId}/members

        Args:
            roleId (str, required): original param name `roleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/roles/{roleId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def role_member_delete(self, roleId: str, memberId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign a role

        API: DELETE /roles/{roleId}/members/{memberId}

        Args:
            roleId (str, required): original param name `roleId`
            memberId (str, required): original param name `memberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/roles/{roleId}/members/{memberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_account_surveys(self, page_size: Optional[str] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get surveys

        API: GET /surveys

        Args:
            page_size (str, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/surveys"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_survey_info(self, surveyId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get survey info

        API: GET /surveys/{surveyId}

        Args:
            surveyId (str, required): original param name `surveyId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/surveys/{surveyId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_survey_answers(
        surveyId: str,
        page_size: Optional[str] = None,
        next_page_token: Optional[str] = None,
        instance_id: Optional[str] = None,
        submit_time_start: Optional[str] = None,
        submit_time_end: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get survey answers

        API: GET /surveys/{surveyId}/answers

        Args:
            surveyId (str, required): original param name `surveyId`
            page_size (str, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            instance_id (str, optional): original param name `instance_id`
            submit_time_start (str, optional): original param name `submit_time_start`
            submit_time_end (str, optional): original param name `submit_time_end`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/surveys/{surveyId}/answers"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if instance_id is not None:
            params['instance_id'] = instance_id
        if submit_time_start is not None:
            params['submit_time_start'] = submit_time_start
        if submit_time_end is not None:
            params['submit_time_end'] = submit_time_end

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_survey_instances_info(
        surveyId: str,
        page_size: Optional[str] = None,
        next_page_token: Optional[str] = None,
        instance_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get survey instances

        API: GET /surveys/{surveyId}/instances

        Args:
            surveyId (str, required): original param name `surveyId`
            page_size (str, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            instance_id (str, optional): original param name `instance_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/surveys/{surveyId}/instances"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if instance_id is not None:
            params['instance_id'] = instance_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== AI Companion =====
    async def get_ai_cconversationarchives(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get AI Companion conversation archives

        API: GET /aic/users/{userId}/conversation_archive

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/aic/users/{userId}/conversation_archive"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== Calendar =====
    async def listacl(
        calId: str,
        maxResults: Optional[int] = None,
        showDeleted: Optional[bool] = None,
        pageToken: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List ACL rules of specified calendar

        API: GET /calendars/{calId}/acl

        Args:
            calId (str, required): original param name `calId`
            maxResults (int, optional): original param name `maxResults`
            showDeleted (bool, optional): original param name `showDeleted`
            pageToken (str, optional): original param name `pageToken`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}/acl"

        params: Dict[str, Any] = {}
        if maxResults is not None:
            params['maxResults'] = maxResults
        if showDeleted is not None:
            params['showDeleted'] = showDeleted
        if pageToken is not None:
            params['pageToken'] = pageToken

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def insertacl(self, calId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a new ACL rule

        API: POST /calendars/{calId}/acl

        Args:
            calId (str, required): original param name `calId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}/acl"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getacl(self, calId: str, aclId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get the specified ACL rule

        API: GET /calendars/{calId}/acl/{aclId}

        Args:
            calId (str, required): original param name `calId`
            aclId (str, required): original param name `aclId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}/acl/{aclId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def deleteacl(self, calId: str, aclId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an existing ACL rule

        API: DELETE /calendars/{calId}/acl/{aclId}

        Args:
            calId (str, required): original param name `calId`
            aclId (str, required): original param name `aclId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}/acl/{aclId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def patchacl(self, calId: str, aclId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update the specified ACL rule

        API: PATCH /calendars/{calId}/acl/{aclId}

        Args:
            calId (str, required): original param name `calId`
            aclId (str, required): original param name `aclId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}/acl/{aclId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def listcalendar_list(
        userIdentifier: str,
        maxResults: Optional[int] = None,
        minAccessRole: Optional[str] = None,
        pageToken: Optional[str] = None,
        showDeleted: Optional[bool] = None,
        showHidden: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List the calendars in the user's own calendarList

        API: GET /calendars/users/{userIdentifier}/calendarList

        Args:
            userIdentifier (str, required): original param name `userIdentifier`
            maxResults (int, optional): original param name `maxResults`
            minAccessRole (str, optional): original param name `minAccessRole`
            pageToken (str, optional): original param name `pageToken`
            showDeleted (bool, optional): original param name `showDeleted`
            showHidden (bool, optional): original param name `showHidden`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/users/{userIdentifier}/calendarList"

        params: Dict[str, Any] = {}
        if maxResults is not None:
            params['maxResults'] = maxResults
        if minAccessRole is not None:
            params['minAccessRole'] = minAccessRole
        if pageToken is not None:
            params['pageToken'] = pageToken
        if showDeleted is not None:
            params['showDeleted'] = showDeleted
        if showHidden is not None:
            params['showHidden'] = showHidden

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def insertcalendar_list(self, userIdentifier: str, colorRgbFormat: Optional[bool] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Insert an existing calendar to the user's own calendarList

        API: POST /calendars/users/{userIdentifier}/calendarList

        Args:
            userIdentifier (str, required): original param name `userIdentifier`
            colorRgbFormat (bool, optional): original param name `colorRgbFormat`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/users/{userIdentifier}/calendarList"

        params: Dict[str, Any] = {}
        if colorRgbFormat is not None:
            params['colorRgbFormat'] = colorRgbFormat

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getcalendar_list(self, userIdentifier: str, calendarId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a specified calendar from the user's own calendarList

        API: GET /calendars/users/{userIdentifier}/calendarList/{calendarId}

        Args:
            userIdentifier (str, required): original param name `userIdentifier`
            calendarId (str, required): original param name `calendarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/users/{userIdentifier}/calendarList/{calendarId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def deletecalendar_list(self, userIdentifier: str, calendarId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an existing calendar from the user's own calendarList

        API: DELETE /calendars/users/{userIdentifier}/calendarList/{calendarId}

        Args:
            userIdentifier (str, required): original param name `userIdentifier`
            calendarId (str, required): original param name `calendarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/users/{userIdentifier}/calendarList/{calendarId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def patchcalendar_list(
        userIdentifier: str,
        calendarId: str,
        colorRgbFormat: Optional[bool] = None,
        body: Optional[Dict[str, Any]] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Update an existing calendar in the user's own calendarList

        API: PATCH /calendars/users/{userIdentifier}/calendarList/{calendarId}

        Args:
            userIdentifier (str, required): original param name `userIdentifier`
            calendarId (str, required): original param name `calendarId`
            colorRgbFormat (bool, optional): original param name `colorRgbFormat`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/users/{userIdentifier}/calendarList/{calendarId}"

        params: Dict[str, Any] = {}
        if colorRgbFormat is not None:
            params['colorRgbFormat'] = colorRgbFormat

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def insertcalendar(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a new secondary calendar

        API: POST /calendars

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getcalendar(self, calId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get the specified calendar

        API: GET /calendars/{calId}

        Args:
            calId (str, required): original param name `calId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def deletecalendar(self, calId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a calendar owned by a user

        API: DELETE /calendars/{calId}

        Args:
            calId (str, required): original param name `calId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def patchcalendar(self, calId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update the specified calendar

        API: PATCH /calendars/{calId}

        Args:
            calId (str, required): original param name `calId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getcolor(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get the color definitions for calendars and events

        API: GET /calendars/colors

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/colors"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def listevent(
        calId: str,
        maxResults: Optional[int] = None,
        orderBy: Optional[str] = None,
        showDeleted: Optional[bool] = None,
        singleEvents: Optional[bool] = None,
        pageToken: Optional[str] = None,
        timeMax: Optional[str] = None,
        timeMin: Optional[str] = None,
        timeZone: Optional[str] = None,
        syncToken: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List events on the specified calendar

        API: GET /calendars/{calId}/events

        Args:
            calId (str, required): original param name `calId`
            maxResults (int, optional): original param name `maxResults`
            orderBy (str, optional): original param name `orderBy`
            showDeleted (bool, optional): original param name `showDeleted`
            singleEvents (bool, optional): original param name `singleEvents`
            pageToken (str, optional): original param name `pageToken`
            timeMax (str, optional): original param name `timeMax`
            timeMin (str, optional): original param name `timeMin`
            timeZone (str, optional): original param name `timeZone`
            syncToken (str, optional): original param name `syncToken`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}/events"

        params: Dict[str, Any] = {}
        if maxResults is not None:
            params['maxResults'] = maxResults
        if orderBy is not None:
            params['orderBy'] = orderBy
        if showDeleted is not None:
            params['showDeleted'] = showDeleted
        if singleEvents is not None:
            params['singleEvents'] = singleEvents
        if pageToken is not None:
            params['pageToken'] = pageToken
        if timeMax is not None:
            params['timeMax'] = timeMax
        if timeMin is not None:
            params['timeMin'] = timeMin
        if timeZone is not None:
            params['timeZone'] = timeZone
        if syncToken is not None:
            params['syncToken'] = syncToken

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def insertevent(self, calId: str, sendUpdates: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Insert a new event to the specified calendar

        API: POST /calendars/{calId}/events

        Args:
            calId (str, required): original param name `calId`
            sendUpdates (str, optional): original param name `sendUpdates`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}/events"

        params: Dict[str, Any] = {}
        if sendUpdates is not None:
            params['sendUpdates'] = sendUpdates

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def importevent(self, calId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Import event to the specified calendar

        API: POST /calendars/{calId}/events/import

        Args:
            calId (str, required): original param name `calId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}/events/import"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def quickaddevent(
        calId: str,
        text: Optional[str] = None,
        sendUpdates: Optional[str] = None,
        body: Optional[Dict[str, Any]] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Quick add an event to the specified calendar

        API: POST /calendars/{calId}/events/quickAdd

        Args:
            calId (str, required): original param name `calId`
            text (str, required): original param name `text`
            sendUpdates (str, optional): original param name `sendUpdates`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}/events/quickAdd"

        params: Dict[str, Any] = {}
        if text is not None:
            params['text'] = text
        if sendUpdates is not None:
            params['sendUpdates'] = sendUpdates

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getevent(self, calId: str, eventId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get the specified event on the specified calendar

        API: GET /calendars/{calId}/events/{eventId}

        Args:
            calId (str, required): original param name `calId`
            eventId (str, required): original param name `eventId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}/events/{eventId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def deleteevent(self, calId: str, eventId: str, sendUpdates: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an existing event from the specified calendar

        API: DELETE /calendars/{calId}/events/{eventId}

        Args:
            calId (str, required): original param name `calId`
            eventId (str, required): original param name `eventId`
            sendUpdates (str, optional): original param name `sendUpdates`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}/events/{eventId}"

        params: Dict[str, Any] = {}
        if sendUpdates is not None:
            params['sendUpdates'] = sendUpdates

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def patchevent(
        calId: str,
        eventId: str,
        sendUpdates: Optional[str] = None,
        body: Optional[Dict[str, Any]] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Update the specified event on the specified calendar

        API: PATCH /calendars/{calId}/events/{eventId}

        Args:
            calId (str, required): original param name `calId`
            eventId (str, required): original param name `eventId`
            sendUpdates (str, optional): original param name `sendUpdates`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}/events/{eventId}"

        params: Dict[str, Any] = {}
        if sendUpdates is not None:
            params['sendUpdates'] = sendUpdates

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def instanceevent(
        calId: str,
        eventId: str,
        maxResults: Optional[int] = None,
        showDeleted: Optional[bool] = None,
        pageToken: Optional[str] = None,
        timeMax: Optional[str] = None,
        timeMin: Optional[str] = None,
        timeZone: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List all instances of the specified recurring event

        API: GET /calendars/{calId}/events/{eventId}/instances

        Args:
            calId (str, required): original param name `calId`
            eventId (str, required): original param name `eventId`
            maxResults (int, optional): original param name `maxResults`
            showDeleted (bool, optional): original param name `showDeleted`
            pageToken (str, optional): original param name `pageToken`
            timeMax (str, optional): original param name `timeMax`
            timeMin (str, optional): original param name `timeMin`
            timeZone (str, optional): original param name `timeZone`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}/events/{eventId}/instances"

        params: Dict[str, Any] = {}
        if maxResults is not None:
            params['maxResults'] = maxResults
        if showDeleted is not None:
            params['showDeleted'] = showDeleted
        if pageToken is not None:
            params['pageToken'] = pageToken
        if timeMax is not None:
            params['timeMax'] = timeMax
        if timeMin is not None:
            params['timeMin'] = timeMin
        if timeZone is not None:
            params['timeZone'] = timeZone

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def moveevent(
        calId: str,
        eventId: str,
        destination: Optional[str] = None,
        sendUpdates: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Move the specified event from a calendar to another specified calendar

        API: POST /calendars/{calId}/events/{eventId}/move

        Args:
            calId (str, required): original param name `calId`
            eventId (str, required): original param name `eventId`
            destination (str, required): original param name `destination`
            sendUpdates (str, optional): original param name `sendUpdates`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/{calId}/events/{eventId}/move"

        params: Dict[str, Any] = {}
        if destination is not None:
            params['destination'] = destination
        if sendUpdates is not None:
            params['sendUpdates'] = sendUpdates

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def queryfreebusy(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Query freebusy information for a set of calendars

        API: POST /calendars/freeBusy

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/freeBusy"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def listsettings(self, userIdentifier: str, maxResults: Optional[int] = None, pageToken: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List all user calendar settings of the authenticated user

        API: GET /calendars/users/{userIdentifier}/settings

        Args:
            userIdentifier (str, required): original param name `userIdentifier`
            maxResults (int, optional): original param name `maxResults`
            pageToken (str, optional): original param name `pageToken`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/users/{userIdentifier}/settings"

        params: Dict[str, Any] = {}
        if maxResults is not None:
            params['maxResults'] = maxResults
        if pageToken is not None:
            params['pageToken'] = pageToken

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getsetting(self, userIdentifier: str, settingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get the specified user calendar settings of the authenticated user

        API: GET /calendars/users/{userIdentifier}/settings/{settingId}

        Args:
            userIdentifier (str, required): original param name `userIdentifier`
            settingId (str, required): original param name `settingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/users/{userIdentifier}/settings/{settingId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def patchsetting(self, userIdentifier: str, settingId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Patch the specified user calendar settings of the authenticated user

        API: PATCH /calendars/users/{userIdentifier}/settings/{settingId}

        Args:
            userIdentifier (str, required): original param name `userIdentifier`
            settingId (str, required): original param name `settingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/calendars/users/{userIdentifier}/settings/{settingId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== Chatbot =====
    async def send_chatbot(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Send Chatbot messages

        API: POST /im/chat/messages

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/im/chat/messages"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def edit_chatbot_message(self, message_id: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Edit a Chatbot message

        API: PUT /im/chat/messages/{message_id}

        Args:
            message_id (str, required): original param name `message_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/im/chat/messages/{message_id}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_a_chatbot_message(
        message_id: str,
        account_id: Optional[str] = None,
        user_jid: Optional[str] = None,
        robot_jid: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete a Chatbot message

        API: DELETE /im/chat/messages/{message_id}

        Args:
            message_id (str, required): original param name `message_id`
            account_id (str, required): original param name `account_id`
            user_jid (str, optional): original param name `user_jid`
            robot_jid (str, required): original param name `robot_jid`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/im/chat/messages/{message_id}"

        params: Dict[str, Any] = {}
        if account_id is not None:
            params['account_id'] = account_id
        if user_jid is not None:
            params['user_jid'] = user_jid
        if robot_jid is not None:
            params['robot_jid'] = robot_jid

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def unfurling_link(self, userId: str, triggerId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Link Unfurls

        API: POST /im/chat/users/{userId}/unfurls/{triggerId}

        Args:
            userId (str, required): original param name `userId`
            triggerId (str, required): original param name `triggerId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/im/chat/users/{userId}/unfurls/{triggerId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== Clips =====
    async def get_clip_collaborators(self, clipId: str, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get collaborators of a clip

        API: GET /clips/{clipId}/collaborators

        Args:
            clipId (str, required): original param name `clipId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/clips/{clipId}/collaborators"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_collaborator(self, clipId: str, user_key: Optional[str] = None, channel_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove the collaborator from a clip

        API: DELETE /clips/{clipId}/collaborators

        Args:
            clipId (str, required): original param name `clipId`
            user_key (str, optional): original param name `user_key`
            channel_id (str, optional): original param name `channel_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/clips/{clipId}/collaborators"

        params: Dict[str, Any] = {}
        if user_key is not None:
            params['user_key'] = user_key
        if channel_id is not None:
            params['channel_id'] = channel_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def listclipcomments(self, clipId: str, page_size: Optional[str] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List clip comments

        API: GET /clips/{clipId}/comments

        Args:
            clipId (str, required): original param name `clipId`
            page_size (str, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/clips/{clipId}/comments"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def deleteacomment(self, clipId: str, commentId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a comment

        API: DELETE /clips/{clipId}/comments/{commentId}

        Args:
            clipId (str, required): original param name `clipId`
            commentId (str, required): original param name `commentId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/clips/{clipId}/comments/{commentId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_clip_by_id(self, clipId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a clip

        API: GET /clips/{clipId}

        Args:
            clipId (str, required): original param name `clipId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/clips/{clipId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_clip(self, clipId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a clip(soft delete)

        API: DELETE /clips/{clipId}

        Args:
            clipId (str, required): original param name `clipId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/clips/{clipId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def transferclipsowner(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Transfer clips owner

        API: POST /clips/transfers

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/clips/transfers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def transfertaskstatuscheck(self, taskId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Transfer task status check

        API: GET /clips/transfers/{taskId}

        Args:
            taskId (str, required): original param name `taskId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/clips/transfers/{taskId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def upload_clip_file(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Upload clip file

        API: POST /clips/files

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/clips/files"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def upload_iq_multipart_clip_file(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Upload clip multipart files

        API: POST /clips/files/multipart

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/clips/files/multipart"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def initiate_and_complete_a_clip_multipart_upload(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Initiate and complete the multipart file upload for a clip

        API: POST /clips/files/multipart/upload_events

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/clips/files/multipart/upload_events"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_user_clips(
        page_size: Optional[str] = None,
        next_page_token: Optional[str] = None,
        user_id: Optional[str] = None,
        search_key: Optional[str] = None,
        date_filter_type: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List all clips

        API: GET /clips

        Args:
            page_size (str, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            user_id (str, required): original param name `user_id`
            search_key (str, optional): original param name `search_key`
            date_filter_type (str, optional): original param name `date_filter_type`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/clips"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if user_id is not None:
            params['user_id'] = user_id
        if search_key is not None:
            params['search_key'] = search_key
        if date_filter_type is not None:
            params['date_filter_type'] = date_filter_type
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== Conference Room Connector =====
    async def get_cisco_polycom_room_account_setting(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Cisco/Polycom Room Account Setting

        API: GET /crc/managed_rooms/account_setting

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/managed_rooms/account_setting"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_cisco_polycom_room_account_setting(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update Cisco/Polycom Room Account Setting

        API: PATCH /crc/managed_rooms/account_setting

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/managed_rooms/account_setting"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_list_api_connectors(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List API Connectors

        API: GET /crc/api_connectors

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/api_connectors"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_api_connector(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create an API Connector

        API: POST /crc/api_connectors

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/api_connectors"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_api_connector(self, connectorId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get an API Connector

        API: GET /crc/api_connectors/{connectorId}

        Args:
            connectorId (str, required): original param name `connectorId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/api_connectors/{connectorId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_api_connector(self, connectorId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an API Connector

        API: DELETE /crc/api_connectors/{connectorId}

        Args:
            connectorId (str, required): original param name `connectorId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/api_connectors/{connectorId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_api_connector(self, connectorId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an API Connector

        API: PATCH /crc/api_connectors/{connectorId}

        Args:
            connectorId (str, required): original param name `connectorId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/api_connectors/{connectorId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getan_api_connector_sprivatekey(self, connectorId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get an API Connector's private key

        API: GET /crc/api_connectors/{connectorId}/private_key

        Args:
            connectorId (str, required): original param name `connectorId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/api_connectors/{connectorId}/private_key"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_api_connector_private_key(self, connectorId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an API Connector's private key

        API: PATCH /crc/api_connectors/{connectorId}/private_key

        Args:
            connectorId (str, required): original param name `connectorId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/api_connectors/{connectorId}/private_key"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_managed_rooms(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List Managed Rooms

        API: GET /crc/managed_rooms

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/managed_rooms"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def createa_managed_room(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a Managed Room

        API: POST /crc/managed_rooms

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/managed_rooms"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def geta_managed_room(self, deviceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a Managed Room

        API: GET /crc/managed_rooms/{deviceId}

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/managed_rooms/{deviceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def deleteamanagedroom(self, deviceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a managed room

        API: DELETE /crc/managed_rooms/{deviceId}

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/managed_rooms/{deviceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def updatea_managed_room(self, deviceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a Managed Room

        API: PATCH /crc/managed_rooms/{deviceId}

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/managed_rooms/{deviceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_participant_identifier_code(self, expires_in: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get participant identifier code

        API: GET /crc/participant_identifier_code

        Args:
            expires_in (int, optional): original param name `expires_in`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/participant_identifier_code"

        params: Dict[str, Any] = {}
        if expires_in is not None:
            params['expires_in'] = expires_in

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_room_templates(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List Room Templates

        API: GET /crc/room_templates

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/room_templates"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def createa_room_template(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a Room Template

        API: POST /crc/room_templates

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/room_templates"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def geta_room_template(self, templateId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a Room Template

        API: GET /crc/room_templates/{templateId}

        Args:
            templateId (str, required): original param name `templateId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/room_templates/{templateId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def deletearoomtemplate(self, templateId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a room template

        API: DELETE /crc/room_templates/{templateId}

        Args:
            templateId (str, required): original param name `templateId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/room_templates/{templateId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def updatea_room_template(self, templateId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a Room Template

        API: PATCH /crc/room_templates/{templateId}

        Args:
            templateId (str, required): original param name `templateId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/crc/room_templates/{templateId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== Mail =====
    async def list_draft_emails(
        email: str,
        includeSpamTrash: Optional[bool] = None,
        maxResults: Optional[int] = None,
        pageToken: Optional[str] = None,
        q: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List emails from draft folder

        API: GET /emails/mailboxes/{email}/drafts

        Args:
            email (str, required): original param name `email`
            includeSpamTrash (bool, optional): original param name `includeSpamTrash`
            maxResults (int, optional): original param name `maxResults`
            pageToken (str, optional): original param name `pageToken`
            q (str, optional): original param name `q`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/drafts"

        params: Dict[str, Any] = {}
        if includeSpamTrash is not None:
            params['includeSpamTrash'] = includeSpamTrash
        if maxResults is not None:
            params['maxResults'] = maxResults
        if pageToken is not None:
            params['pageToken'] = pageToken
        if q is not None:
            params['q'] = q

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_draft_email(self, email: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a new draft email

        API: POST /emails/mailboxes/{email}/drafts

        Args:
            email (str, required): original param name `email`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/drafts"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def send_draft_email(self, email: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Send out a draft email

        API: POST /emails/mailboxes/{email}/drafts/send

        Args:
            email (str, required): original param name `email`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/drafts/send"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_draft_email(self, email: str, draftId: str, format: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get the specified draft email

        API: GET /emails/mailboxes/{email}/drafts/{draftId}

        Args:
            email (str, required): original param name `email`
            draftId (str, required): original param name `draftId`
            format (str, optional): original param name `format`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/drafts/{draftId}"

        params: Dict[str, Any] = {}
        if format is not None:
            params['format'] = format

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_draft_email(self, email: str, draftId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update the specified draft email

        API: PUT /emails/mailboxes/{email}/drafts/{draftId}

        Args:
            email (str, required): original param name `email`
            draftId (str, required): original param name `draftId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/drafts/{draftId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_draft_email(self, email: str, draftId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an existing draft email

        API: DELETE /emails/mailboxes/{email}/drafts/{draftId}

        Args:
            email (str, required): original param name `email`
            draftId (str, required): original param name `draftId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/drafts/{draftId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_mailbox_history(
        email: str,
        maxResults: Optional[int] = None,
        pageToken: Optional[str] = None,
        startHistoryId: Optional[str] = None,
        historyTypes: Optional[str] = None,
        excludeHistoryTypes: Optional[str] = None,
        labelId: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List history of events for mailbox

        API: GET /emails/mailboxes/{email}/history

        Args:
            email (str, required): original param name `email`
            maxResults (int, optional): original param name `maxResults`
            pageToken (str, optional): original param name `pageToken`
            startHistoryId (str, required): original param name `startHistoryId`
            historyTypes (str, optional): original param name `historyTypes`
            excludeHistoryTypes (str, optional): original param name `excludeHistoryTypes`
            labelId (str, optional): original param name `labelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/history"

        params: Dict[str, Any] = {}
        if maxResults is not None:
            params['maxResults'] = maxResults
        if pageToken is not None:
            params['pageToken'] = pageToken
        if startHistoryId is not None:
            params['startHistoryId'] = startHistoryId
        if historyTypes is not None:
            params['historyTypes'] = historyTypes
        if excludeHistoryTypes is not None:
            params['excludeHistoryTypes'] = excludeHistoryTypes
        if labelId is not None:
            params['labelId'] = labelId

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_labels_in_mailbox(self, email: str, format: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List labels in the mailbox

        API: GET /emails/mailboxes/{email}/labels

        Args:
            email (str, required): original param name `email`
            format (str, optional): original param name `format`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/labels"

        params: Dict[str, Any] = {}
        if format is not None:
            params['format'] = format

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_label_in_mailbox(self, email: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a new label in mailbox

        API: POST /emails/mailboxes/{email}/labels

        Args:
            email (str, required): original param name `email`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/labels"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_label_in_mailbox(self, email: str, labelId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get the specified label in mailbox

        API: GET /emails/mailboxes/{email}/labels/{labelId}

        Args:
            email (str, required): original param name `email`
            labelId (str, required): original param name `labelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/labels/{labelId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_label_in_mailbox(self, email: str, labelId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update the specified label in mailbox

        API: PUT /emails/mailboxes/{email}/labels/{labelId}

        Args:
            email (str, required): original param name `email`
            labelId (str, required): original param name `labelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/labels/{labelId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_label_from_mailbox(self, email: str, labelId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an existing label from mailbox

        API: DELETE /emails/mailboxes/{email}/labels/{labelId}

        Args:
            email (str, required): original param name `email`
            labelId (str, required): original param name `labelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/labels/{labelId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def patch_label_in_mailbox(self, email: str, labelId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Patch the specified label in mailbox

        API: PATCH /emails/mailboxes/{email}/labels/{labelId}

        Args:
            email (str, required): original param name `email`
            labelId (str, required): original param name `labelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/labels/{labelId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_mailbox_profile(self, email: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get the mailbox profile

        API: GET /emails/mailboxes/{email}/profile

        Args:
            email (str, required): original param name `email`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/profile"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_emails(
        email: str,
        maxResults: Optional[str] = None,
        pageToken: Optional[str] = None,
        labelIds: Optional[str] = None,
        q: Optional[str] = None,
        includeSpamTrash: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List emails from the mailbox

        API: GET /emails/mailboxes/{email}/messages

        Args:
            email (str, required): original param name `email`
            maxResults (str, optional): original param name `maxResults`
            pageToken (str, optional): original param name `pageToken`
            labelIds (str, optional): original param name `labelIds`
            q (str, optional): original param name `q`
            includeSpamTrash (bool, optional): original param name `includeSpamTrash`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/messages"

        params: Dict[str, Any] = {}
        if maxResults is not None:
            params['maxResults'] = maxResults
        if pageToken is not None:
            params['pageToken'] = pageToken
        if labelIds is not None:
            params['labelIds'] = labelIds
        if q is not None:
            params['q'] = q
        if includeSpamTrash is not None:
            params['includeSpamTrash'] = includeSpamTrash

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_email(self, email: str, deleted: Optional[bool] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a new email

        API: POST /emails/mailboxes/{email}/messages

        Args:
            email (str, required): original param name `email`
            deleted (bool, optional): original param name `deleted`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/messages"

        params: Dict[str, Any] = {}
        if deleted is not None:
            params['deleted'] = deleted

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def batch_delete_emails(self, email: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Batch delete the specified emails

        API: POST /emails/mailboxes/{email}/messages/batchDelete

        Args:
            email (str, required): original param name `email`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/messages/batchDelete"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def batch_modify_emails(self, email: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Batch modify the specified emails

        API: POST /emails/mailboxes/{email}/messages/batchModify

        Args:
            email (str, required): original param name `email`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/messages/batchModify"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def send_email(self, email: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Send out an email

        API: POST /emails/mailboxes/{email}/messages/send

        Args:
            email (str, required): original param name `email`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/messages/send"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_email(
        email: str,
        messageId: str,
        format: Optional[str] = None,
        metadataHeaders: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get the specified email

        API: GET /emails/mailboxes/{email}/messages/{messageId}

        Args:
            email (str, required): original param name `email`
            messageId (str, required): original param name `messageId`
            format (str, optional): original param name `format`
            metadataHeaders (str, optional): original param name `metadataHeaders`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/messages/{messageId}"

        params: Dict[str, Any] = {}
        if format is not None:
            params['format'] = format
        if metadataHeaders is not None:
            params['metadataHeaders'] = metadataHeaders

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_email(self, email: str, messageId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an existing email

        API: DELETE /emails/mailboxes/{email}/messages/{messageId}

        Args:
            email (str, required): original param name `email`
            messageId (str, required): original param name `messageId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/messages/{messageId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_email(self, email: str, messageId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update the specified email

        API: POST /emails/mailboxes/{email}/messages/{messageId}/modify

        Args:
            email (str, required): original param name `email`
            messageId (str, required): original param name `messageId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/messages/{messageId}/modify"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def trash_email(self, email: str, messageId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Move the specified email to TRASH folder

        API: POST /emails/mailboxes/{email}/messages/{messageId}/trash

        Args:
            email (str, required): original param name `email`
            messageId (str, required): original param name `messageId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/messages/{messageId}/trash"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def untrash_email(self, email: str, messageId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Move the specified email out of TRASH folder

        API: POST /emails/mailboxes/{email}/messages/{messageId}/untrash

        Args:
            email (str, required): original param name `email`
            messageId (str, required): original param name `messageId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/messages/{messageId}/untrash"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_email_attachment(self, email: str, messageId: str, attachmentId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get the specified attachment for an email

        API: GET /emails/mailboxes/{email}/messages/{messageId}/attachments/{attachmentId}

        Args:
            email (str, required): original param name `email`
            messageId (str, required): original param name `messageId`
            attachmentId (str, required): original param name `attachmentId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/messages/{messageId}/attachments/{attachmentId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_mail_vacation_response_setting(self, email: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get mailbox vacation response setting

        API: GET /emails/mailboxes/{email}/settings/vacation

        Args:
            email (str, required): original param name `email`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/settings/vacation"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_mailbox_vacation_response_setting(self, email: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update mailbox vacation response setting

        API: PUT /emails/mailboxes/{email}/settings/vacation

        Args:
            email (str, required): original param name `email`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/settings/vacation"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_mailbox_delegates(self, email: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List delegates on the mailbox

        API: GET /emails/mailboxes/{email}/settings/delegates

        Args:
            email (str, required): original param name `email`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/settings/delegates"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def grant_mailbox_delegate(self, email: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Grant a new delegate access on the mailbox

        API: POST /emails/mailboxes/{email}/settings/delegates

        Args:
            email (str, required): original param name `email`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/settings/delegates"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_mailbox_delegate(self, email: str, delegateEmail: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get the specified delegate on the mailbox

        API: GET /emails/mailboxes/{email}/settings/delegates/{delegateEmail}

        Args:
            email (str, required): original param name `email`
            delegateEmail (str, required): original param name `delegateEmail`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/settings/delegates/{delegateEmail}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def revoke_mailbox_delegate(self, email: str, delegateEmail: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Revoke an existing delegate access from the mailbox

        API: DELETE /emails/mailboxes/{email}/settings/delegates/{delegateEmail}

        Args:
            email (str, required): original param name `email`
            delegateEmail (str, required): original param name `delegateEmail`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/settings/delegates/{delegateEmail}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_email_filters(self, email: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List email filters

        API: GET /emails/mailboxes/{email}/settings/filters

        Args:
            email (str, required): original param name `email`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/settings/filters"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_email_filter(self, email: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create an email filter

        API: POST /emails/mailboxes/{email}/settings/filters

        Args:
            email (str, required): original param name `email`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/settings/filters"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_email_filter(self, email: str, filterId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get the specified email filter

        API: GET /emails/mailboxes/{email}/settings/filters/{filterId}

        Args:
            email (str, required): original param name `email`
            filterId (str, required): original param name `filterId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/settings/filters/{filterId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_email_filter(self, email: str, filterId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete the specified email filter

        API: DELETE /emails/mailboxes/{email}/settings/filters/{filterId}

        Args:
            email (str, required): original param name `email`
            filterId (str, required): original param name `filterId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/settings/filters/{filterId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_email_threads(
        email: str,
        includeSpamTrash: Optional[str] = None,
        labelIds: Optional[str] = None,
        maxResults: Optional[str] = None,
        pageToken: Optional[str] = None,
        q: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List email threads from the mailbox

        API: GET /emails/mailboxes/{email}/threads

        Args:
            email (str, required): original param name `email`
            includeSpamTrash (str, optional): original param name `includeSpamTrash`
            labelIds (str, optional): original param name `labelIds`
            maxResults (str, optional): original param name `maxResults`
            pageToken (str, optional): original param name `pageToken`
            q (str, optional): original param name `q`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/threads"

        params: Dict[str, Any] = {}
        if includeSpamTrash is not None:
            params['includeSpamTrash'] = includeSpamTrash
        if labelIds is not None:
            params['labelIds'] = labelIds
        if maxResults is not None:
            params['maxResults'] = maxResults
        if pageToken is not None:
            params['pageToken'] = pageToken
        if q is not None:
            params['q'] = q

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_email_thread(
        email: str,
        threadId: str,
        format: Optional[str] = None,
        metadataHeaders: Optional[str] = None,
        maxResults: Optional[str] = None,
        pageToken: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get the specified email thread

        API: GET /emails/mailboxes/{email}/threads/{threadId}

        Args:
            email (str, required): original param name `email`
            threadId (str, required): original param name `threadId`
            format (str, optional): original param name `format`
            metadataHeaders (str, optional): original param name `metadataHeaders`
            maxResults (str, optional): original param name `maxResults`
            pageToken (str, optional): original param name `pageToken`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/threads/{threadId}"

        params: Dict[str, Any] = {}
        if format is not None:
            params['format'] = format
        if metadataHeaders is not None:
            params['metadataHeaders'] = metadataHeaders
        if maxResults is not None:
            params['maxResults'] = maxResults
        if pageToken is not None:
            params['pageToken'] = pageToken

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_email_thread(self, email: str, threadId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an existing email thread

        API: DELETE /emails/mailboxes/{email}/threads/{threadId}

        Args:
            email (str, required): original param name `email`
            threadId (str, required): original param name `threadId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/threads/{threadId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_email_thread(self, email: str, threadId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update the specified thread

        API: POST /emails/mailboxes/{email}/threads/{threadId}/modify

        Args:
            email (str, required): original param name `email`
            threadId (str, required): original param name `threadId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/threads/{threadId}/modify"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def trash_email_thread(self, email: str, threadId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Move the specified thread to TRASH folder

        API: POST /emails/mailboxes/{email}/threads/{threadId}/trash

        Args:
            email (str, required): original param name `email`
            threadId (str, required): original param name `threadId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/threads/{threadId}/trash"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def untrash_email_thread(self, email: str, threadId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Move the specified thread out of TRASH folder

        API: POST /emails/mailboxes/{email}/threads/{threadId}/untrash

        Args:
            email (str, required): original param name `email`
            threadId (str, required): original param name `threadId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/emails/mailboxes/{email}/threads/{threadId}/untrash"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== Meetings =====
    async def list_archived_files(
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        query_date_type: Optional[str] = None,
        group_id: Optional[str] = None,
        group_ids: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List archived files

        API: GET /archive_files

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            query_date_type (str, optional): original param name `query_date_type`
            group_id (str, optional): original param name `group_id`
            group_ids (str, optional): original param name `group_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/archive_files"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if query_date_type is not None:
            params['query_date_type'] = query_date_type
        if group_id is not None:
            params['group_id'] = group_id
        if group_ids is not None:
            params['group_ids'] = group_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_archived_file_statistics(self, from_param: Optional[str] = None, to: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get archived file statistics

        API: GET /archive_files/statistics

        Args:
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/archive_files/statistics"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_archived_file(self, fileId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an archived file's auto-delete status

        API: PATCH /archive_files/{fileId}

        Args:
            fileId (str, required): original param name `fileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/archive_files/{fileId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_archived_files(self, meetingUUID: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a meeting's archived files

        API: GET /past_meetings/{meetingUUID}/archive_files

        Args:
            meetingUUID (str, required): original param name `meetingUUID`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/past_meetings/{meetingUUID}/archive_files"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_archived_files(self, meetingUUID: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a meeting's archived files

        API: DELETE /past_meetings/{meetingUUID}/archive_files

        Args:
            meetingUUID (str, required): original param name `meetingUUID`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/past_meetings/{meetingUUID}/archive_files"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def recording_get(self, meetingId: str, include_fields: Optional[str] = None, ttl: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get meeting recordings

        API: GET /meetings/{meetingId}/recordings

        Args:
            meetingId (str, required): original param name `meetingId`
            include_fields (str, optional): original param name `include_fields`
            ttl (int, optional): original param name `ttl`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/recordings"

        params: Dict[str, Any] = {}
        if include_fields is not None:
            params['include_fields'] = include_fields
        if ttl is not None:
            params['ttl'] = ttl

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def recording_delete(self, meetingId: str, action: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete meeting or webinar recordings

        API: DELETE /meetings/{meetingId}/recordings

        Args:
            meetingId (str, required): original param name `meetingId`
            action (str, optional): original param name `action`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/recordings"

        params: Dict[str, Any] = {}
        if action is not None:
            params['action'] = action

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def analytics_details(
        meetingId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        type_param: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get a meeting or webinar recording's analytics details

        API: GET /meetings/{meetingId}/recordings/analytics_details

        Args:
            meetingId (str, required): original param name `meetingId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            type_param (str, optional): original param name `type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/recordings/analytics_details"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if type_param is not None:
            params['type'] = type_param

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def analytics_summary(self, meetingId: str, from_param: Optional[str] = None, to: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a meeting or webinar recording's analytics summary

        API: GET /meetings/{meetingId}/recordings/analytics_summary

        Args:
            meetingId (str, required): original param name `meetingId`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/recordings/analytics_summary"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_recording_registrants(
        meetingId: int,
        status: Optional[str] = None,
        page_size: Optional[int] = None,
        page_number: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List recording registrants

        API: GET /meetings/{meetingId}/recordings/registrants

        Args:
            meetingId (int, required): original param name `meetingId`
            status (str, optional): original param name `status`
            page_size (int, optional): original param name `page_size`
            page_number (int, optional): original param name `page_number`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/recordings/registrants"

        params: Dict[str, Any] = {}
        if status is not None:
            params['status'] = status
        if page_size is not None:
            params['page_size'] = page_size
        if page_number is not None:
            params['page_number'] = page_number
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_recording_registrant_create(self, meetingId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a recording registrant

        API: POST /meetings/{meetingId}/recordings/registrants

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/recordings/registrants"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def recording_registrants_questions_get(self, meetingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get registration questions

        API: GET /meetings/{meetingId}/recordings/registrants/questions

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/recordings/registrants/questions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def recording_registrant_question_update(self, meetingId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update registration questions

        API: PATCH /meetings/{meetingId}/recordings/registrants/questions

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/recordings/registrants/questions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_recording_registrant_status(self, meetingId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a registrant's status

        API: PUT /meetings/{meetingId}/recordings/registrants/status

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/recordings/registrants/status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def recording_setting_update(self, meetingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get meeting recording settings

        API: GET /meetings/{meetingId}/recordings/settings

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/recordings/settings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def recording_settings_update(self, meetingId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update meeting recording settings

        API: PATCH /meetings/{meetingId}/recordings/settings

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/recordings/settings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def recording_delete_one(self, meetingId: str, recordingId: str, action: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a recording file for a meeting or webinar

        API: DELETE /meetings/{meetingId}/recordings/{recordingId}

        Args:
            meetingId (str, required): original param name `meetingId`
            recordingId (str, required): original param name `recordingId`
            action (str, optional): original param name `action`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/recordings/{recordingId}"

        params: Dict[str, Any] = {}
        if action is not None:
            params['action'] = action

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def recording_status_update_one(self, meetingId: str, recordingId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Recover a single recording

        API: PUT /meetings/{meetingId}/recordings/{recordingId}/status

        Args:
            meetingId (str, required): original param name `meetingId`
            recordingId (str, required): original param name `recordingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/recordings/{recordingId}/status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_meeting_transcript(self, meetingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a meeting transcript

        API: GET /meetings/{meetingId}/transcript

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/transcript"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_meeting_transcript(self, meetingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a meeting or webinar transcript

        API: DELETE /meetings/{meetingId}/transcript

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/transcript"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def recording_status_update(self, meetingUUID: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Recover meeting recordings

        API: PUT /meetings/{meetingUUID}/recordings/status

        Args:
            meetingUUID (str, required): original param name `meetingUUID`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingUUID}/recordings/status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def recordings_list(
        userId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        mc: Optional[str] = None,
        trash: Optional[bool] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        trash_type: Optional[str] = None,
        meeting_id: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List all recordings

        API: GET /users/{userId}/recordings

        Args:
            userId (str, required): original param name `userId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            mc (str, optional): original param name `mc`
            trash (bool, optional): original param name `trash`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            trash_type (str, optional): original param name `trash_type`
            meeting_id (int, optional): original param name `meeting_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/recordings"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if mc is not None:
            params['mc'] = mc
        if trash is not None:
            params['trash'] = trash
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if trash_type is not None:
            params['trash_type'] = trash_type
        if meeting_id is not None:
            params['meeting_id'] = meeting_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_devices(
        search_text: Optional[str] = None,
        platform_os: Optional[str] = None,
        is_enrolled_in_zdm: Optional[bool] = None,
        device_type: Optional[int] = None,
        device_vendor: Optional[str] = None,
        device_model: Optional[str] = None,
        device_status: Optional[int] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List devices

        API: GET /devices

        Args:
            search_text (str, optional): original param name `search_text`
            platform_os (str, optional): original param name `platform_os`
            is_enrolled_in_zdm (bool, optional): original param name `is_enrolled_in_zdm`
            device_type (int, optional): original param name `device_type`
            device_vendor (str, optional): original param name `device_vendor`
            device_model (str, optional): original param name `device_model`
            device_status (int, optional): original param name `device_status`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/devices"

        params: Dict[str, Any] = {}
        if search_text is not None:
            params['search_text'] = search_text
        if platform_os is not None:
            params['platform_os'] = platform_os
        if is_enrolled_in_zdm is not None:
            params['is_enrolled_in_zdm'] = is_enrolled_in_zdm
        if device_type is not None:
            params['device_type'] = device_type
        if device_vendor is not None:
            params['device_vendor'] = device_vendor
        if device_model is not None:
            params['device_model'] = device_model
        if device_status is not None:
            params['device_status'] = device_status
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_device(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a new device

        API: POST /devices

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/devices"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getzdmgroupinfo(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get ZDM group info

        API: GET /devices/groups

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/devices/groups"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assigndevicetoauser_commonarea(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign a device to a user or commonarea

        API: POST /devices/zpa/assignment

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/devices/zpa/assignment"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_zpa_device_list_profile_setting_ofa_user(self, user_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Zoom Phone Appliance settings by user ID

        API: GET /devices/zpa/settings

        Args:
            user_id (str, optional): original param name `user_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/devices/zpa/settings"

        params: Dict[str, Any] = {}
        if user_id is not None:
            params['user_id'] = user_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def upgrade_zpas_app(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Upgrade ZPA firmware or app

        API: POST /devices/zpa/upgrade

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/devices/zpa/upgrade"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_zpa_device_by_vendor_and_mac_address(self, vendor: str, macAddress: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete ZPA device by vendor and mac address

        API: DELETE /devices/zpa/vendors/{vendor}/mac_addresses/{macAddress}

        Args:
            vendor (str, required): original param name `vendor`
            macAddress (str, required): original param name `macAddress`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/devices/zpa/vendors/{vendor}/mac_addresses/{macAddress}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_zpa_versioninfo(self, zdmGroupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get ZPA version info

        API: GET /devices/zpa/zdm_groups/{zdmGroupId}/versions

        Args:
            zdmGroupId (str, required): original param name `zdmGroupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/devices/zpa/zdm_groups/{zdmGroupId}/versions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_device(self, deviceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get device detail

        API: GET /devices/{deviceId}

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/devices/{deviceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_device(self, deviceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete device

        API: DELETE /devices/{deviceId}

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/devices/{deviceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_device(self, deviceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Change device

        API: PATCH /devices/{deviceId}

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/devices/{deviceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assgin_group(self, deviceId: str, group_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign a device to a group

        API: PATCH /devices/{deviceId}/assign_group

        Args:
            deviceId (str, required): original param name `deviceId`
            group_id (str, required): original param name `group_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/devices/{deviceId}/assign_group"

        params: Dict[str, Any] = {}
        if group_id is not None:
            params['group_id'] = group_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def change_device_association(self, deviceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Change device association

        API: PATCH /devices/{deviceId}/assignment

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/devices/{deviceId}/assignment"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def device_list(self, page_size: Optional[int] = None, page_number: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List H.323/SIP devices

        API: GET /h323/devices

        Args:
            page_size (int, optional): original param name `page_size`
            page_number (int, optional): original param name `page_number`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/h323/devices"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if page_number is not None:
            params['page_number'] = page_number
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def device_create(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a H.323/SIP device

        API: POST /h323/devices

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/h323/devices"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def device_delete(self, deviceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a H.323/SIP device

        API: DELETE /h323/devices/{deviceId}

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/h323/devices/{deviceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def device_update(self, deviceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a H.323/SIP device

        API: PATCH /h323/devices/{deviceId}

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/h323/devices/{deviceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_meeting_chat_message_by_id(self, meetingId: int, messageId: str, file_ids: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a live meeting message

        API: DELETE /live_meetings/{meetingId}/chat/messages/{messageId}

        Args:
            meetingId (int, required): original param name `meetingId`
            messageId (str, required): original param name `messageId`
            file_ids (str, optional): original param name `file_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/live_meetings/{meetingId}/chat/messages/{messageId}"

        params: Dict[str, Any] = {}
        if file_ids is not None:
            params['file_ids'] = file_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_meeting_chat_message_by_id(self, meetingId: int, messageId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a live meeting message

        API: PATCH /live_meetings/{meetingId}/chat/messages/{messageId}

        Args:
            meetingId (int, required): original param name `meetingId`
            messageId (str, required): original param name `messageId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/live_meetings/{meetingId}/chat/messages/{messageId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def in_meeting_control(self, meetingId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Use in-meeting controls

        API: PATCH /live_meetings/{meetingId}/events

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/live_meetings/{meetingId}/events"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_rtms_status_update(self, meetingId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update participant Real-Time Media Streams (RTMS) app status

        API: PATCH /live_meetings/{meetingId}/rtms_app/status

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/live_meetings/{meetingId}/rtms_app/status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def listmeetingsummaries(
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List an account's meeting or webinar summaries

        API: GET /meetings/meeting_summaries

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/meeting_summaries"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting(self, meetingId: int, occurrence_id: Optional[str] = None, show_previous_occurrences: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a meeting

        API: GET /meetings/{meetingId}

        Args:
            meetingId (int, required): original param name `meetingId`
            occurrence_id (str, optional): original param name `occurrence_id`
            show_previous_occurrences (bool, optional): original param name `show_previous_occurrences`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}"

        params: Dict[str, Any] = {}
        if occurrence_id is not None:
            params['occurrence_id'] = occurrence_id
        if show_previous_occurrences is not None:
            params['show_previous_occurrences'] = show_previous_occurrences

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_delete(
        meetingId: int,
        occurrence_id: Optional[str] = None,
        schedule_for_reminder: Optional[bool] = None,
        cancel_meeting_reminder: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete a meeting

        API: DELETE /meetings/{meetingId}

        Args:
            meetingId (int, required): original param name `meetingId`
            occurrence_id (str, optional): original param name `occurrence_id`
            schedule_for_reminder (bool, optional): original param name `schedule_for_reminder`
            cancel_meeting_reminder (bool, optional): original param name `cancel_meeting_reminder`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}"

        params: Dict[str, Any] = {}
        if occurrence_id is not None:
            params['occurrence_id'] = occurrence_id
        if schedule_for_reminder is not None:
            params['schedule_for_reminder'] = schedule_for_reminder
        if cancel_meeting_reminder is not None:
            params['cancel_meeting_reminder'] = cancel_meeting_reminder

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_update(self, meetingId: int, occurrence_id: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a meeting

        API: PATCH /meetings/{meetingId}

        Args:
            meetingId (int, required): original param name `meetingId`
            occurrence_id (str, optional): original param name `occurrence_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}"

        params: Dict[str, Any] = {}
        if occurrence_id is not None:
            params['occurrence_id'] = occurrence_id

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_batch_polls(self, meetingId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Perform batch poll creation

        API: POST /meetings/{meetingId}/batch_polls

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/batch_polls"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_batch_registrants(self, meetingId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Perform batch registration

        API: POST /meetings/{meetingId}/batch_registrants

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/batch_registrants"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_invitation(self, meetingId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get meeting invitation

        API: GET /meetings/{meetingId}/invitation

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/invitation"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_invite_links_create(self, meetingId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a meeting's invite links

        API: POST /meetings/{meetingId}/invite_links

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/invite_links"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_live_streaming_join_token(self, meetingId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a meeting's join token for live streaming

        API: GET /meetings/{meetingId}/jointoken/live_streaming

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/jointoken/live_streaming"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_local_archiving_archive_token(self, meetingId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a meeting's archive token for local archiving

        API: GET /meetings/{meetingId}/jointoken/local_archiving

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/jointoken/local_archiving"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_local_recording_join_token(self, meetingId: int, bypass_waiting_room: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a meeting's join token for local recording

        API: GET /meetings/{meetingId}/jointoken/local_recording

        Args:
            meetingId (int, required): original param name `meetingId`
            bypass_waiting_room (bool, optional): original param name `bypass_waiting_room`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/jointoken/local_recording"

        params: Dict[str, Any] = {}
        if bypass_waiting_room is not None:
            params['bypass_waiting_room'] = bypass_waiting_room

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_meeting_live_stream_details(self, meetingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get livestream details

        API: GET /meetings/{meetingId}/livestream

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/livestream"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_live_stream_update(self, meetingId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a livestream

        API: PATCH /meetings/{meetingId}/livestream

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/livestream"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_live_stream_status_update(self, meetingId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update livestream status

        API: PATCH /meetings/{meetingId}/livestream/status

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/livestream/status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getameetingsummary(self, meetingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a meeting or webinar summary

        API: GET /meetings/{meetingId}/meeting_summary

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/meeting_summary"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def deletemeetingorwebinarsummary(self, meetingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a meeting or webinar summary

        API: DELETE /meetings/{meetingId}/meeting_summary

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/meeting_summary"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_app_add(self, meetingId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a meeting app

        API: POST /meetings/{meetingId}/open_apps

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/open_apps"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_app_delete(self, meetingId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a meeting app

        API: DELETE /meetings/{meetingId}/open_apps

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/open_apps"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_polls(self, meetingId: int, anonymous: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List meeting polls

        API: GET /meetings/{meetingId}/polls

        Args:
            meetingId (int, required): original param name `meetingId`
            anonymous (bool, optional): original param name `anonymous`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/polls"

        params: Dict[str, Any] = {}
        if anonymous is not None:
            params['anonymous'] = anonymous

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_poll_create(self, meetingId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a meeting poll

        API: POST /meetings/{meetingId}/polls

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/polls"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_poll_get(self, meetingId: int, pollId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a meeting poll

        API: GET /meetings/{meetingId}/polls/{pollId}

        Args:
            meetingId (int, required): original param name `meetingId`
            pollId (str, required): original param name `pollId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/polls/{pollId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_poll_update(self, meetingId: int, pollId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a meeting poll

        API: PUT /meetings/{meetingId}/polls/{pollId}

        Args:
            meetingId (int, required): original param name `meetingId`
            pollId (str, required): original param name `pollId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/polls/{pollId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_poll_delete(self, meetingId: int, pollId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a meeting poll

        API: DELETE /meetings/{meetingId}/polls/{pollId}

        Args:
            meetingId (int, required): original param name `meetingId`
            pollId (str, required): original param name `pollId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/polls/{pollId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_registrants(
        meetingId: int,
        occurrence_id: Optional[str] = None,
        status: Optional[str] = None,
        page_size: Optional[int] = None,
        page_number: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List meeting registrants

        API: GET /meetings/{meetingId}/registrants

        Args:
            meetingId (int, required): original param name `meetingId`
            occurrence_id (str, optional): original param name `occurrence_id`
            status (str, optional): original param name `status`
            page_size (int, optional): original param name `page_size`
            page_number (int, optional): original param name `page_number`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/registrants"

        params: Dict[str, Any] = {}
        if occurrence_id is not None:
            params['occurrence_id'] = occurrence_id
        if status is not None:
            params['status'] = status
        if page_size is not None:
            params['page_size'] = page_size
        if page_number is not None:
            params['page_number'] = page_number
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_registrant_create(self, meetingId: int, occurrence_ids: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a meeting registrant

        API: POST /meetings/{meetingId}/registrants

        Args:
            meetingId (int, required): original param name `meetingId`
            occurrence_ids (str, optional): original param name `occurrence_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/registrants"

        params: Dict[str, Any] = {}
        if occurrence_ids is not None:
            params['occurrence_ids'] = occurrence_ids

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_registrants_questions_get(self, meetingId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List registration questions

        API: GET /meetings/{meetingId}/registrants/questions

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/registrants/questions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_registrant_question_update(self, meetingId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update registration questions

        API: PATCH /meetings/{meetingId}/registrants/questions

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/registrants/questions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_registrant_status(self, meetingId: int, occurrence_id: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update registrant's status

        API: PUT /meetings/{meetingId}/registrants/status

        Args:
            meetingId (int, required): original param name `meetingId`
            occurrence_id (str, optional): original param name `occurrence_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/registrants/status"

        params: Dict[str, Any] = {}
        if occurrence_id is not None:
            params['occurrence_id'] = occurrence_id

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_registrant_get(self, meetingId: int, registrantId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a meeting registrant

        API: GET /meetings/{meetingId}/registrants/{registrantId}

        Args:
            meetingId (int, required): original param name `meetingId`
            registrantId (str, required): original param name `registrantId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/registrants/{registrantId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meetingregistrantdelete(self, meetingId: int, registrantId: str, occurrence_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a meeting registrant

        API: DELETE /meetings/{meetingId}/registrants/{registrantId}

        Args:
            meetingId (int, required): original param name `meetingId`
            registrantId (str, required): original param name `registrantId`
            occurrence_id (str, optional): original param name `occurrence_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/registrants/{registrantId}"

        params: Dict[str, Any] = {}
        if occurrence_id is not None:
            params['occurrence_id'] = occurrence_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_sip_dialing_with_passcode(self, meetingId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a meeting SIP URI with passcode

        API: POST /meetings/{meetingId}/sip_dialing

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/sip_dialing"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_status(self, meetingId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update meeting status

        API: PUT /meetings/{meetingId}/status

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_survey_get(self, meetingId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a meeting survey

        API: GET /meetings/{meetingId}/survey

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/survey"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_survey_delete(self, meetingId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a meeting survey

        API: DELETE /meetings/{meetingId}/survey

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/survey"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_survey_update(self, meetingId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a meeting survey

        API: PATCH /meetings/{meetingId}/survey

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/survey"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_token(self, meetingId: int, type_param: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get meeting's token

        API: GET /meetings/{meetingId}/token

        Args:
            meetingId (int, required): original param name `meetingId`
            type_param (str, optional): original param name `type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/meetings/{meetingId}/token"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def past_meeting_details(self, meetingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get past meeting details

        API: GET /past_meetings/{meetingId}

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/past_meetings/{meetingId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def past_meetings(self, meetingId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List past meeting instances

        API: GET /past_meetings/{meetingId}/instances

        Args:
            meetingId (int, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/past_meetings/{meetingId}/instances"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def past_meeting_participants(self, meetingId: str, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get past meeting participants

        API: GET /past_meetings/{meetingId}/participants

        Args:
            meetingId (str, required): original param name `meetingId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/past_meetings/{meetingId}/participants"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_past_meeting_polls(self, meetingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List past meeting's poll results

        API: GET /past_meetings/{meetingId}/polls

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/past_meetings/{meetingId}/polls"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_past_meeting_qa(self, meetingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List past meetings' Q&A

        API: GET /past_meetings/{meetingId}/qa

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/past_meetings/{meetingId}/qa"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_meeting_templates(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List meeting templates

        API: GET /users/{userId}/meeting_templates

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/meeting_templates"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_template_create(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a meeting template from an existing meeting

        API: POST /users/{userId}/meeting_templates

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/meeting_templates"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meetings(
        userId: str,
        type_param: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        page_number: Optional[int] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        timezone: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List meetings

        API: GET /users/{userId}/meetings

        Args:
            userId (str, required): original param name `userId`
            type_param (str, optional): original param name `type`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            page_number (int, optional): original param name `page_number`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            timezone (str, optional): original param name `timezone`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/meetings"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_number is not None:
            params['page_number'] = page_number
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if timezone is not None:
            params['timezone'] = timezone

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def meeting_create(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a meeting

        API: POST /users/{userId}/meetings

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/meetings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_upcoming_meeting(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List upcoming meetings

        API: GET /users/{userId}/upcoming_meetings

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/upcoming_meetings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_pa_cs(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List a user's PAC accounts

        API: GET /users/{userId}/pac

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/pac"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_sign_in_sign_out_activities(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get sign In / sign out activity report

        API: GET /report/activities

        Args:
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/activities"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_billing_report(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get billing reports

        API: GET /report/billing

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/billing"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_billing_invoices_reports(self, billing_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get billing invoice reports

        API: GET /report/billing/invoices

        Args:
            billing_id (str, required): original param name `billing_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/billing/invoices"

        params: Dict[str, Any] = {}
        if billing_id is not None:
            params['billing_id'] = billing_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_cloud_recording(self, from_param: Optional[str] = None, to: Optional[str] = None, group_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get cloud recording usage report

        API: GET /report/cloud_recording

        Args:
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            group_id (str, optional): original param name `group_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/cloud_recording"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if group_id is not None:
            params['group_id'] = group_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_daily(self, year: Optional[int] = None, month: Optional[int] = None, group_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get daily usage report

        API: GET /report/daily

        Args:
            year (int, optional): original param name `year`
            month (int, optional): original param name `month`
            group_id (str, optional): original param name `group_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/daily"

        params: Dict[str, Any] = {}
        if year is not None:
            params['year'] = year
        if month is not None:
            params['month'] = month
        if group_id is not None:
            params['group_id'] = group_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def gethistorymeetingandwebinarlist(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        date_type: Optional[str] = None,
        meeting_type: Optional[str] = None,
        report_type: Optional[str] = None,
        search_key: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        group_id: Optional[str] = None,
        meeting_feature: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get history meeting and webinar list

        API: GET /report/history_meetings

        Args:
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            date_type (str, optional): original param name `date_type`
            meeting_type (str, optional): original param name `meeting_type`
            report_type (str, optional): original param name `report_type`
            search_key (str, optional): original param name `search_key`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            group_id (str, optional): original param name `group_id`
            meeting_feature (str, optional): original param name `meeting_feature`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/history_meetings"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if date_type is not None:
            params['date_type'] = date_type
        if meeting_type is not None:
            params['meeting_type'] = meeting_type
        if report_type is not None:
            params['report_type'] = report_type
        if search_key is not None:
            params['search_key'] = search_key
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if group_id is not None:
            params['group_id'] = group_id
        if meeting_feature is not None:
            params['meeting_feature'] = meeting_feature

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_meetingactivitylogs(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        meeting_number: Optional[str] = None,
        search_key: Optional[str] = None,
        activity_type: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get a meeting activities report

        API: GET /report/meeting_activities

        Args:
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            meeting_number (str, optional): original param name `meeting_number`
            search_key (str, optional): original param name `search_key`
            activity_type (str, required): original param name `activity_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/meeting_activities"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if meeting_number is not None:
            params['meeting_number'] = meeting_number
        if search_key is not None:
            params['search_key'] = search_key
        if activity_type is not None:
            params['activity_type'] = activity_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_meeting_details(self, meetingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get meeting detail reports

        API: GET /report/meetings/{meetingId}

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/meetings/{meetingId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_meeting_participants(
        meetingId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        include_fields: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get meeting participant reports

        API: GET /report/meetings/{meetingId}/participants

        Args:
            meetingId (str, required): original param name `meetingId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            include_fields (str, optional): original param name `include_fields`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/meetings/{meetingId}/participants"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if include_fields is not None:
            params['include_fields'] = include_fields

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_meeting_polls(self, meetingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get meeting poll reports

        API: GET /report/meetings/{meetingId}/polls

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/meetings/{meetingId}/polls"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_meeting_qa(self, meetingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get meeting Q&A report

        API: GET /report/meetings/{meetingId}/qa

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/meetings/{meetingId}/qa"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_meeting_survey(self, meetingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get meeting survey report

        API: GET /report/meetings/{meetingId}/survey

        Args:
            meetingId (str, required): original param name `meetingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/meetings/{meetingId}/survey"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_operation_logs(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        category_type: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get operation logs report

        API: GET /report/operationlogs

        Args:
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            category_type (str, optional): original param name `category_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/operationlogs"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if category_type is not None:
            params['category_type'] = category_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getremotesupportreport(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get remote support report

        API: GET /report/remote_support

        Args:
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (str, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/remote_support"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_telephone(
        type_param: Optional[str] = None,
        query_date_type: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        page_number: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get telephone reports

        API: GET /report/telephone

        Args:
            type_param (str, optional): original param name `type`
            query_date_type (str, optional): original param name `query_date_type`
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            page_size (int, optional): original param name `page_size`
            page_number (int, optional): original param name `page_number`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/telephone"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if query_date_type is not None:
            params['query_date_type'] = query_date_type
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if page_number is not None:
            params['page_number'] = page_number
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_upcoming_events(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        type_param: Optional[str] = None,
        group_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get upcoming events report

        API: GET /report/upcoming_events

        Args:
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            type_param (str, optional): original param name `type`
            group_id (str, optional): original param name `group_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/upcoming_events"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if type_param is not None:
            params['type'] = type_param
        if group_id is not None:
            params['group_id'] = group_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_users(
        type_param: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        page_number: Optional[int] = None,
        next_page_token: Optional[str] = None,
        group_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get active or inactive host reports

        API: GET /report/users

        Args:
            type_param (str, optional): original param name `type`
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            page_size (int, optional): original param name `page_size`
            page_number (int, optional): original param name `page_number`
            next_page_token (str, optional): original param name `next_page_token`
            group_id (str, optional): original param name `group_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/users"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if page_number is not None:
            params['page_number'] = page_number
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if group_id is not None:
            params['group_id'] = group_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_meetings(
        userId: str,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        type_param: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get meeting reports

        API: GET /report/users/{userId}/meetings

        Args:
            userId (str, required): original param name `userId`
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            type_param (str, optional): original param name `type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/users/{userId}/meetings"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if type_param is not None:
            params['type'] = type_param

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_webinar_details(self, webinarId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get webinar detail reports

        API: GET /report/webinars/{webinarId}

        Args:
            webinarId (str, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/webinars/{webinarId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_webinar_participants(
        webinarId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        include_fields: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get webinar participant reports

        API: GET /report/webinars/{webinarId}/participants

        Args:
            webinarId (str, required): original param name `webinarId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            include_fields (str, optional): original param name `include_fields`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/webinars/{webinarId}/participants"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if include_fields is not None:
            params['include_fields'] = include_fields

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_webinar_polls(self, webinarId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get webinar poll reports

        API: GET /report/webinars/{webinarId}/polls

        Args:
            webinarId (str, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/webinars/{webinarId}/polls"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_webinar_qa(self, webinarId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get webinar Q&A report

        API: GET /report/webinars/{webinarId}/qa

        Args:
            webinarId (str, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/webinars/{webinarId}/qa"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_webinar_survey(self, webinarId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get webinar survey report

        API: GET /report/webinars/{webinarId}/survey

        Args:
            webinarId (str, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/webinars/{webinarId}/survey"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_sip_phone_phones(self, search_key: Optional[str] = None, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List SIP phones

        API: GET /sip_phones/phones

        Args:
            search_key (str, optional): original param name `search_key`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/sip_phones/phones"

        params: Dict[str, Any] = {}
        if search_key is not None:
            params['search_key'] = search_key
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def enable_sip_phone_phones(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Enable SIP phone

        API: POST /sip_phones/phones

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/sip_phones/phones"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_sip_phone_phones(self, phoneId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete SIP phone

        API: DELETE /sip_phones/phones/{phoneId}

        Args:
            phoneId (str, required): original param name `phoneId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/sip_phones/phones/{phoneId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_sip_phone_phones(self, phoneId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update SIP phone

        API: PATCH /sip_phones/phones/{phoneId}

        Args:
            phoneId (str, required): original param name `phoneId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/sip_phones/phones/{phoneId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def tsp(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get account's TSP information

        API: GET /tsp

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/tsp"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def tsp_update(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an account's TSP information

        API: PATCH /tsp

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/tsp"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_ts_ps(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List user's TSP accounts

        API: GET /users/{userId}/tsp

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/tsp"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_tsp_create(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a user's TSP account

        API: POST /users/{userId}/tsp

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/tsp"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def tsp_url_update(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Set global dial-in URL for a TSP user

        API: PATCH /users/{userId}/tsp/settings

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/tsp/settings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_tsp(self, userId: str, tspId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a user's TSP account

        API: GET /users/{userId}/tsp/{tspId}

        Args:
            userId (str, required): original param name `userId`
            tspId (str, required): original param name `tspId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/tsp/{tspId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_tsp_delete(self, userId: str, tspId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a user's TSP account

        API: DELETE /users/{userId}/tsp/{tspId}

        Args:
            userId (str, required): original param name `userId`
            tspId (str, required): original param name `tspId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/tsp/{tspId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_tsp_update(self, userId: str, tspId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a TSP account

        API: PATCH /users/{userId}/tsp/{tspId}

        Args:
            userId (str, required): original param name `userId`
            tspId (str, required): original param name `tspId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/tsp/{tspId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def trackingfield_list(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List tracking fields

        API: GET /tracking_fields

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/tracking_fields"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def trackingfield_create(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a tracking field

        API: POST /tracking_fields

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/tracking_fields"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def trackingfield_get(self, fieldId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a tracking field

        API: GET /tracking_fields/{fieldId}

        Args:
            fieldId (str, required): original param name `fieldId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/tracking_fields/{fieldId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def trackingfield_delete(self, fieldId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a tracking field

        API: DELETE /tracking_fields/{fieldId}

        Args:
            fieldId (str, required): original param name `fieldId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/tracking_fields/{fieldId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def trackingfield_update(self, fieldId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a tracking field

        API: PATCH /tracking_fields/{fieldId}

        Args:
            fieldId (str, required): original param name `fieldId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/tracking_fields/{fieldId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_webinar_chat_message_by_id(self, webinarId: int, messageId: str, file_ids: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a live webinar message

        API: DELETE /live_webinars/{webinarId}/chat/messages/{messageId}

        Args:
            webinarId (int, required): original param name `webinarId`
            messageId (str, required): original param name `messageId`
            file_ids (str, optional): original param name `file_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/live_webinars/{webinarId}/chat/messages/{messageId}"

        params: Dict[str, Any] = {}
        if file_ids is not None:
            params['file_ids'] = file_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_absentees(
        webinarId: str,
        occurrence_id: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get webinar absentees

        API: GET /past_webinars/{webinarId}/absentees

        Args:
            webinarId (str, required): original param name `webinarId`
            occurrence_id (str, optional): original param name `occurrence_id`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/past_webinars/{webinarId}/absentees"

        params: Dict[str, Any] = {}
        if occurrence_id is not None:
            params['occurrence_id'] = occurrence_id
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def past_webinars(self, webinarId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List past webinar instances

        API: GET /past_webinars/{webinarId}/instances

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/past_webinars/{webinarId}/instances"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_webinar_participants(self, webinarId: str, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List webinar participants

        API: GET /past_webinars/{webinarId}/participants

        Args:
            webinarId (str, required): original param name `webinarId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/past_webinars/{webinarId}/participants"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_past_webinar_poll_results(self, webinarId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List past webinar poll results

        API: GET /past_webinars/{webinarId}/polls

        Args:
            webinarId (str, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/past_webinars/{webinarId}/polls"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_past_webinar_qa(self, webinarId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List Q&As of a past webinar

        API: GET /past_webinars/{webinarId}/qa

        Args:
            webinarId (str, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/past_webinars/{webinarId}/qa"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_webinar_templates(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List webinar templates

        API: GET /users/{userId}/webinar_templates

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/webinar_templates"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_template_create(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a webinar template

        API: POST /users/{userId}/webinar_templates

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/webinar_templates"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinars(
        userId: str,
        type_param: Optional[str] = None,
        page_size: Optional[int] = None,
        page_number: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List webinars

        API: GET /users/{userId}/webinars

        Args:
            userId (str, required): original param name `userId`
            type_param (str, optional): original param name `type`
            page_size (int, optional): original param name `page_size`
            page_number (int, optional): original param name `page_number`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/webinars"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if page_size is not None:
            params['page_size'] = page_size
        if page_number is not None:
            params['page_number'] = page_number

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_create(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a webinar

        API: POST /users/{userId}/webinars

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/webinars"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar(self, webinarId: str, occurrence_id: Optional[str] = None, show_previous_occurrences: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a webinar

        API: GET /webinars/{webinarId}

        Args:
            webinarId (str, required): original param name `webinarId`
            occurrence_id (str, optional): original param name `occurrence_id`
            show_previous_occurrences (bool, optional): original param name `show_previous_occurrences`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}"

        params: Dict[str, Any] = {}
        if occurrence_id is not None:
            params['occurrence_id'] = occurrence_id
        if show_previous_occurrences is not None:
            params['show_previous_occurrences'] = show_previous_occurrences

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_delete(self, webinarId: int, occurrence_id: Optional[str] = None, cancel_webinar_reminder: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a webinar

        API: DELETE /webinars/{webinarId}

        Args:
            webinarId (int, required): original param name `webinarId`
            occurrence_id (str, optional): original param name `occurrence_id`
            cancel_webinar_reminder (bool, optional): original param name `cancel_webinar_reminder`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}"

        params: Dict[str, Any] = {}
        if occurrence_id is not None:
            params['occurrence_id'] = occurrence_id
        if cancel_webinar_reminder is not None:
            params['cancel_webinar_reminder'] = cancel_webinar_reminder

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_update(self, webinarId: int, occurrence_id: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a webinar

        API: PATCH /webinars/{webinarId}

        Args:
            webinarId (int, required): original param name `webinarId`
            occurrence_id (str, optional): original param name `occurrence_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}"

        params: Dict[str, Any] = {}
        if occurrence_id is not None:
            params['occurrence_id'] = occurrence_id

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_batch_webinar_registrants(self, webinarId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Perform batch registration

        API: POST /webinars/{webinarId}/batch_registrants

        Args:
            webinarId (str, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/batch_registrants"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_webinar_branding(self, webinarId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get webinar's session branding

        API: GET /webinars/{webinarId}/branding

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/branding"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_webinar_branding_name_tag(self, webinarId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a webinar's branding name tag

        API: POST /webinars/{webinarId}/branding/name_tags

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/branding/name_tags"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_webinar_branding_name_tag(self, webinarId: int, name_tag_ids: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a webinar's branding name tag

        API: DELETE /webinars/{webinarId}/branding/name_tags

        Args:
            webinarId (int, required): original param name `webinarId`
            name_tag_ids (str, optional): original param name `name_tag_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/branding/name_tags"

        params: Dict[str, Any] = {}
        if name_tag_ids is not None:
            params['name_tag_ids'] = name_tag_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_webinar_branding_name_tag(self, webinarId: int, nameTagId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a webinar's branding name tag

        API: PATCH /webinars/{webinarId}/branding/name_tags/{nameTagId}

        Args:
            webinarId (int, required): original param name `webinarId`
            nameTagId (str, required): original param name `nameTagId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/branding/name_tags/{nameTagId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def upload_webinar_branding_vb(self, webinarId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Upload a webinar's branding virtual background

        API: POST /webinars/{webinarId}/branding/virtual_backgrounds

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/branding/virtual_backgrounds"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_webinar_branding_vb(self, webinarId: int, ids: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a webinar's branding virtual backgrounds

        API: DELETE /webinars/{webinarId}/branding/virtual_backgrounds

        Args:
            webinarId (int, required): original param name `webinarId`
            ids (str, optional): original param name `ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/branding/virtual_backgrounds"

        params: Dict[str, Any] = {}
        if ids is not None:
            params['ids'] = ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def set_webinar_branding_vb(self, webinarId: int, id: Optional[str] = None, set_default_for_all_panelists: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Set webinar's default branding virtual background

        API: PATCH /webinars/{webinarId}/branding/virtual_backgrounds

        Args:
            webinarId (int, required): original param name `webinarId`
            id (str, optional): original param name `id`
            set_default_for_all_panelists (bool, optional): original param name `set_default_for_all_panelists`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/branding/virtual_backgrounds"

        params: Dict[str, Any] = {}
        if id is not None:
            params['id'] = id
        if set_default_for_all_panelists is not None:
            params['set_default_for_all_panelists'] = set_default_for_all_panelists

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def upload_webinar_branding_wallpaper(self, webinarId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Upload a webinar's branding wallpaper

        API: POST /webinars/{webinarId}/branding/wallpaper

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/branding/wallpaper"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_webinar_branding_wallpaper(self, webinarId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a webinar's branding wallpaper

        API: DELETE /webinars/{webinarId}/branding/wallpaper

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/branding/wallpaper"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_invite_links_create(self, webinarId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create webinar's invite links

        API: POST /webinars/{webinarId}/invite_links

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/invite_links"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_live_streaming_join_token(self, webinarId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a webinar's join token for live streaming

        API: GET /webinars/{webinarId}/jointoken/live_streaming

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/jointoken/live_streaming"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_local_archiving_archive_token(self, webinarId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a webinar's archive token for local archiving

        API: GET /webinars/{webinarId}/jointoken/local_archiving

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/jointoken/local_archiving"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_local_recording_join_token(self, webinarId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a webinar's join token for local recording

        API: GET /webinars/{webinarId}/jointoken/local_recording

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/jointoken/local_recording"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_webinar_live_stream_details(self, webinarId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get live stream details

        API: GET /webinars/{webinarId}/livestream

        Args:
            webinarId (str, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/livestream"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_live_stream_update(self, webinarId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a live stream

        API: PATCH /webinars/{webinarId}/livestream

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/livestream"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_live_stream_status_update(self, webinarId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update live stream status

        API: PATCH /webinars/{webinarId}/livestream/status

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/livestream/status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_panelists(self, webinarId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List panelists

        API: GET /webinars/{webinarId}/panelists

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/panelists"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_panelist_create(self, webinarId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add panelists

        API: POST /webinars/{webinarId}/panelists

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/panelists"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_panelists_delete(self, webinarId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove all panelists

        API: DELETE /webinars/{webinarId}/panelists

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/panelists"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_panelist_delete(self, webinarId: int, panelistId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove a panelist

        API: DELETE /webinars/{webinarId}/panelists/{panelistId}

        Args:
            webinarId (int, required): original param name `webinarId`
            panelistId (str, required): original param name `panelistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/panelists/{panelistId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_polls(self, webinarId: int, anonymous: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List a webinar's polls

        API: GET /webinars/{webinarId}/polls

        Args:
            webinarId (int, required): original param name `webinarId`
            anonymous (bool, optional): original param name `anonymous`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/polls"

        params: Dict[str, Any] = {}
        if anonymous is not None:
            params['anonymous'] = anonymous

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_poll_create(self, webinarId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a webinar's poll

        API: POST /webinars/{webinarId}/polls

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/polls"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_poll_get(self, webinarId: int, pollId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a webinar poll

        API: GET /webinars/{webinarId}/polls/{pollId}

        Args:
            webinarId (int, required): original param name `webinarId`
            pollId (str, required): original param name `pollId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/polls/{pollId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_poll_update(self, webinarId: int, pollId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a webinar poll

        API: PUT /webinars/{webinarId}/polls/{pollId}

        Args:
            webinarId (int, required): original param name `webinarId`
            pollId (str, required): original param name `pollId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/polls/{pollId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_poll_delete(self, webinarId: int, pollId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a webinar poll

        API: DELETE /webinars/{webinarId}/polls/{pollId}

        Args:
            webinarId (int, required): original param name `webinarId`
            pollId (str, required): original param name `pollId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/polls/{pollId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_registrants(
        webinarId: int,
        occurrence_id: Optional[str] = None,
        status: Optional[str] = None,
        tracking_source_id: Optional[str] = None,
        page_size: Optional[int] = None,
        page_number: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List webinar registrants

        API: GET /webinars/{webinarId}/registrants

        Args:
            webinarId (int, required): original param name `webinarId`
            occurrence_id (str, optional): original param name `occurrence_id`
            status (str, optional): original param name `status`
            tracking_source_id (str, optional): original param name `tracking_source_id`
            page_size (int, optional): original param name `page_size`
            page_number (int, optional): original param name `page_number`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/registrants"

        params: Dict[str, Any] = {}
        if occurrence_id is not None:
            params['occurrence_id'] = occurrence_id
        if status is not None:
            params['status'] = status
        if tracking_source_id is not None:
            params['tracking_source_id'] = tracking_source_id
        if page_size is not None:
            params['page_size'] = page_size
        if page_number is not None:
            params['page_number'] = page_number
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_registrant_create(self, webinarId: int, occurrence_ids: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a webinar registrant

        API: POST /webinars/{webinarId}/registrants

        Args:
            webinarId (int, required): original param name `webinarId`
            occurrence_ids (str, optional): original param name `occurrence_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/registrants"

        params: Dict[str, Any] = {}
        if occurrence_ids is not None:
            params['occurrence_ids'] = occurrence_ids

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_registrants_questions_get(self, webinarId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List registration questions

        API: GET /webinars/{webinarId}/registrants/questions

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/registrants/questions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_registrant_question_update(self, webinarId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update registration questions

        API: PATCH /webinars/{webinarId}/registrants/questions

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/registrants/questions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_registrant_status(self, webinarId: int, occurrence_id: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update registrant's status

        API: PUT /webinars/{webinarId}/registrants/status

        Args:
            webinarId (int, required): original param name `webinarId`
            occurrence_id (str, optional): original param name `occurrence_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/registrants/status"

        params: Dict[str, Any] = {}
        if occurrence_id is not None:
            params['occurrence_id'] = occurrence_id

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_registrant_get(self, webinarId: int, registrantId: str, occurrence_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a webinar registrant

        API: GET /webinars/{webinarId}/registrants/{registrantId}

        Args:
            webinarId (int, required): original param name `webinarId`
            registrantId (str, required): original param name `registrantId`
            occurrence_id (str, optional): original param name `occurrence_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/registrants/{registrantId}"

        params: Dict[str, Any] = {}
        if occurrence_id is not None:
            params['occurrence_id'] = occurrence_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_webinar_registrant(self, webinarId: int, registrantId: str, occurrence_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a webinar registrant

        API: DELETE /webinars/{webinarId}/registrants/{registrantId}

        Args:
            webinarId (int, required): original param name `webinarId`
            registrantId (str, required): original param name `registrantId`
            occurrence_id (str, optional): original param name `occurrence_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/registrants/{registrantId}"

        params: Dict[str, Any] = {}
        if occurrence_id is not None:
            params['occurrence_id'] = occurrence_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_webinar_sip_dialing_with_passcode(self, webinarId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a webinar SIP URI with passcode

        API: POST /webinars/{webinarId}/sip_dialing

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/sip_dialing"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_status(self, webinarId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update webinar status

        API: PUT /webinars/{webinarId}/status

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_survey_get(self, webinarId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a webinar survey

        API: GET /webinars/{webinarId}/survey

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/survey"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_survey_delete(self, webinarId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a webinar survey

        API: DELETE /webinars/{webinarId}/survey

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/survey"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_survey_update(self, webinarId: int, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a webinar survey

        API: PATCH /webinars/{webinarId}/survey

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/survey"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def webinar_token(self, webinarId: int, type_param: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get webinar's token

        API: GET /webinars/{webinarId}/token

        Args:
            webinarId (int, required): original param name `webinarId`
            type_param (str, optional): original param name `type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/token"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_tracking_sources(self, webinarId: int, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get webinar tracking sources

        API: GET /webinars/{webinarId}/tracking_sources

        Args:
            webinarId (int, required): original param name `webinarId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/webinars/{webinarId}/tracking_sources"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== Phone =====
    async def list_zoom_phone_account_settings(self, setting_types: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List an account's Zoom phone settings

        API: GET /phone/account_settings

        Args:
            setting_types (str, optional): original param name `setting_types`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/account_settings"

        params: Dict[str, Any] = {}
        if setting_types is not None:
            params['setting_types'] = setting_types

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_customize_outbound_caller_numbers(
        selected: Optional[bool] = None,
        site_id: Optional[str] = None,
        extension_type: Optional[str] = None,
        keyword: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List an account's customized outbound caller ID phone numbers

        API: GET /phone/outbound_caller_id/customized_numbers

        Args:
            selected (bool, optional): original param name `selected`
            site_id (str, optional): original param name `site_id`
            extension_type (str, optional): original param name `extension_type`
            keyword (str, optional): original param name `keyword`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/outbound_caller_id/customized_numbers"

        params: Dict[str, Any] = {}
        if selected is not None:
            params['selected'] = selected
        if site_id is not None:
            params['site_id'] = site_id
        if extension_type is not None:
            params['extension_type'] = extension_type
        if keyword is not None:
            params['keyword'] = keyword
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_outbound_caller_numbers(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add phone numbers for an account's customized outbound caller ID

        API: POST /phone/outbound_caller_id/customized_numbers

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/outbound_caller_id/customized_numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_outbound_caller_numbers(self, customize_ids: Optional[List[str]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete phone numbers for an account's customized outbound caller ID

        API: DELETE /phone/outbound_caller_id/customized_numbers

        Args:
            customize_ids (List[str], optional): original param name `customize_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/outbound_caller_id/customized_numbers"

        params: Dict[str, Any] = {}
        if customize_ids is not None:
            params['customize_ids'] = customize_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_alert_settings_with_paging_query(
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        module: Optional[int] = None,
        rule: Optional[int] = None,
        status: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List alert settings with paging query

        API: GET /phone/alert_settings

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            module (int, optional): original param name `module`
            rule (int, optional): original param name `rule`
            status (int, optional): original param name `status`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/alert_settings"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if module is not None:
            params['module'] = module
        if rule is not None:
            params['rule'] = rule
        if status is not None:
            params['status'] = status

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_an_alert_setting(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add an alert setting

        API: POST /phone/alert_settings

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/alert_settings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_alert_setting_details(self, alertSettingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get alert setting details

        API: GET /phone/alert_settings/{alertSettingId}

        Args:
            alertSettingId (str, required): original param name `alertSettingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/alert_settings/{alertSettingId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_an_alert_setting(self, alertSettingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an alert setting

        API: DELETE /phone/alert_settings/{alertSettingId}

        Args:
            alertSettingId (str, required): original param name `alertSettingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/alert_settings/{alertSettingId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_an_alert_setting(self, alertSettingId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an alert setting

        API: PATCH /phone/alert_settings/{alertSettingId}

        Args:
            alertSettingId (str, required): original param name `alertSettingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/alert_settings/{alertSettingId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_audio_item(self, audioId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get an audio item

        API: GET /phone/audios/{audioId}

        Args:
            audioId (str, required): original param name `audioId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/audios/{audioId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_audio_item(self, audioId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an audio item

        API: DELETE /phone/audios/{audioId}

        Args:
            audioId (str, required): original param name `audioId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/audios/{audioId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_audio_item(self, audioId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an audio item

        API: PATCH /phone/audios/{audioId}

        Args:
            audioId (str, required): original param name `audioId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/audios/{audioId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_audio_items(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List audio items

        API: GET /phone/users/{userId}/audios

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/audios"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_an_audio(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add an audio item for text-to-speech conversion

        API: POST /phone/users/{userId}/audios

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/audios"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_audio_item(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add audio items

        API: POST /phone/users/{userId}/audios/batch

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/audios/batch"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_auto_receptionists(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List auto receptionists

        API: GET /phone/auto_receptionists

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_auto_receptionist(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add an auto receptionist

        API: POST /phone/auto_receptionists

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_auto_receptionist_detail(self, autoReceptionistId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get an auto receptionist

        API: GET /phone/auto_receptionists/{autoReceptionistId}

        Args:
            autoReceptionistId (str, required): original param name `autoReceptionistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists/{autoReceptionistId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_auto_receptionist(self, autoReceptionistId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a non-primary auto receptionist

        API: DELETE /phone/auto_receptionists/{autoReceptionistId}

        Args:
            autoReceptionistId (str, required): original param name `autoReceptionistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists/{autoReceptionistId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_auto_receptionist(self, autoReceptionistId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an auto receptionist

        API: PATCH /phone/auto_receptionists/{autoReceptionistId}

        Args:
            autoReceptionistId (str, required): original param name `autoReceptionistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists/{autoReceptionistId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assign_phone_numbers_auto_receptionist(self, autoReceptionistId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign phone numbers

        API: POST /phone/auto_receptionists/{autoReceptionistId}/phone_numbers

        Args:
            autoReceptionistId (str, required): original param name `autoReceptionistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists/{autoReceptionistId}/phone_numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def unassign_all_phone_nums_auto_receptionist(self, autoReceptionistId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign all phone numbers

        API: DELETE /phone/auto_receptionists/{autoReceptionistId}/phone_numbers

        Args:
            autoReceptionistId (str, required): original param name `autoReceptionistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists/{autoReceptionistId}/phone_numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def unassign_a_phone_num_auto_receptionist(self, autoReceptionistId: str, phoneNumberId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign a phone number

        API: DELETE /phone/auto_receptionists/{autoReceptionistId}/phone_numbers/{phoneNumberId}

        Args:
            autoReceptionistId (str, required): original param name `autoReceptionistId`
            phoneNumberId (str, required): original param name `phoneNumberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists/{autoReceptionistId}/phone_numbers/{phoneNumberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_auto_receptionists_policy(self, autoReceptionistId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get an auto receptionist policy

        API: GET /phone/auto_receptionists/{autoReceptionistId}/policies

        Args:
            autoReceptionistId (str, required): original param name `autoReceptionistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists/{autoReceptionistId}/policies"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_auto_receptionist_policy(self, autoReceptionistId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an auto receptionist policy

        API: PATCH /phone/auto_receptionists/{autoReceptionistId}/policies

        Args:
            autoReceptionistId (str, required): original param name `autoReceptionistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists/{autoReceptionistId}/policies"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_policy(self, autoReceptionistId: str, policyType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a policy subsetting

        API: POST /phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}

        Args:
            autoReceptionistId (str, required): original param name `autoReceptionistId`
            policyType (str, required): original param name `policyType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_policy(self, autoReceptionistId: str, policyType: str, shared_ids: Optional[List[str]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a policy subsetting

        API: DELETE /phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}

        Args:
            autoReceptionistId (str, required): original param name `autoReceptionistId`
            policyType (str, required): original param name `policyType`
            shared_ids (List[str], required): original param name `shared_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}"

        params: Dict[str, Any] = {}
        if shared_ids is not None:
            params['shared_ids'] = shared_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_policy(self, autoReceptionistId: str, policyType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a policy subsetting

        API: PATCH /phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}

        Args:
            autoReceptionistId (str, required): original param name `autoReceptionistId`
            policyType (str, required): original param name `policyType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists/{autoReceptionistId}/policies/{policyType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_billing_account(self, site_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List billing accounts

        API: GET /phone/billing_accounts

        Args:
            site_id (str, optional): original param name `site_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/billing_accounts"

        params: Dict[str, Any] = {}
        if site_id is not None:
            params['site_id'] = site_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_a_billing_account(self, billingAccountId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get billing account details

        API: GET /phone/billing_accounts/{billingAccountId}

        Args:
            billingAccountId (str, required): original param name `billingAccountId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/billing_accounts/{billingAccountId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_blocked_list(self, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List blocked lists

        API: GET /phone/blocked_list

        Args:
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/blocked_list"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_anumber_to_blocked_list(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a blocked list

        API: POST /phone/blocked_list

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/blocked_list"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_a_blocked_list(self, blockedListId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get blocked list details

        API: GET /phone/blocked_list/{blockedListId}

        Args:
            blockedListId (str, required): original param name `blockedListId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/blocked_list/{blockedListId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_a_blocked_list(self, blockedListId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a blocked list

        API: DELETE /phone/blocked_list/{blockedListId}

        Args:
            blockedListId (str, required): original param name `blockedListId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/blocked_list/{blockedListId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_blocked_list(self, blockedListId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a blocked list

        API: PATCH /phone/blocked_list/{blockedListId}

        Args:
            blockedListId (str, required): original param name `blockedListId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/blocked_list/{blockedListId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_call_handling(self, extensionId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get call handling settings

        API: GET /phone/extension/{extensionId}/call_handling/settings

        Args:
            extensionId (str, required): original param name `extensionId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/extension/{extensionId}/call_handling/settings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_call_handling(self, extensionId: str, settingType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a call handling setting

        API: POST /phone/extension/{extensionId}/call_handling/settings/{settingType}

        Args:
            extensionId (str, required): original param name `extensionId`
            settingType (str, required): original param name `settingType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/extension/{extensionId}/call_handling/settings/{settingType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_call_handling(
        extensionId: str,
        settingType: str,
        call_forwarding_id: Optional[str] = None,
        holiday_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete a call handling setting

        API: DELETE /phone/extension/{extensionId}/call_handling/settings/{settingType}

        Args:
            extensionId (str, required): original param name `extensionId`
            settingType (str, required): original param name `settingType`
            call_forwarding_id (str, optional): original param name `call_forwarding_id`
            holiday_id (str, optional): original param name `holiday_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/extension/{extensionId}/call_handling/settings/{settingType}"

        params: Dict[str, Any] = {}
        if call_forwarding_id is not None:
            params['call_forwarding_id'] = call_forwarding_id
        if holiday_id is not None:
            params['holiday_id'] = holiday_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_call_handling(self, extensionId: str, settingType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a call handling setting

        API: PATCH /phone/extension/{extensionId}/call_handling/settings/{settingType}

        Args:
            extensionId (str, required): original param name `extensionId`
            settingType (str, required): original param name `settingType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/extension/{extensionId}/call_handling/settings/{settingType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_call_element(self, callElementId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get call element

        API: GET /phone/call_element/{callElementId}

        Args:
            callElementId (str, required): original param name `callElementId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_element/{callElementId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def account_call_history(
        page_size: Optional[int] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        next_page_token: Optional[str] = None,
        keyword: Optional[str] = None,
        directions: Optional[List[str]] = None,
        connect_types: Optional[List[str]] = None,
        number_types: Optional[List[str]] = None,
        call_types: Optional[List[str]] = None,
        extension_types: Optional[List[str]] = None,
        call_results: Optional[List[str]] = None,
        group_ids: Optional[List[str]] = None,
        site_ids: Optional[List[str]] = None,
        department: Optional[str] = None,
        cost_center: Optional[str] = None,
        time_type: Optional[str] = None,
        recording_status: Optional[str] = None,
        with_voicemail: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get account's call history

        API: GET /phone/call_history

        Args:
            page_size (int, optional): original param name `page_size`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            next_page_token (str, optional): original param name `next_page_token`
            keyword (str, optional): original param name `keyword`
            directions (List[str], optional): original param name `directions`
            connect_types (List[str], optional): original param name `connect_types`
            number_types (List[str], optional): original param name `number_types`
            call_types (List[str], optional): original param name `call_types`
            extension_types (List[str], optional): original param name `extension_types`
            call_results (List[str], optional): original param name `call_results`
            group_ids (List[str], optional): original param name `group_ids`
            site_ids (List[str], optional): original param name `site_ids`
            department (str, optional): original param name `department`
            cost_center (str, optional): original param name `cost_center`
            time_type (str, optional): original param name `time_type`
            recording_status (str, optional): original param name `recording_status`
            with_voicemail (bool, optional): original param name `with_voicemail`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_history"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if keyword is not None:
            params['keyword'] = keyword
        if directions is not None:
            params['directions'] = directions
        if connect_types is not None:
            params['connect_types'] = connect_types
        if number_types is not None:
            params['number_types'] = number_types
        if call_types is not None:
            params['call_types'] = call_types
        if extension_types is not None:
            params['extension_types'] = extension_types
        if call_results is not None:
            params['call_results'] = call_results
        if group_ids is not None:
            params['group_ids'] = group_ids
        if site_ids is not None:
            params['site_ids'] = site_ids
        if department is not None:
            params['department'] = department
        if cost_center is not None:
            params['cost_center'] = cost_center
        if time_type is not None:
            params['time_type'] = time_type
        if recording_status is not None:
            params['recording_status'] = recording_status
        if with_voicemail is not None:
            params['with_voicemail'] = with_voicemail

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_call_path(self, callHistoryUuid: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get call history

        API: GET /phone/call_history/{callHistoryUuid}

        Args:
            callHistoryUuid (str, required): original param name `callHistoryUuid`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_history/{callHistoryUuid}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_client_code_to_call_history(self, callLogId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a client code to a call history

        API: PATCH /phone/call_history/{callLogId}/client_code

        Args:
            callLogId (str, required): original param name `callLogId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_history/{callLogId}/client_code"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_call_history_detail(self, callHistoryId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get call history detail

        API: GET /phone/call_history_detail/{callHistoryId}

        Args:
            callHistoryId (str, required): original param name `callHistoryId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_history_detail/{callHistoryId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def account_call_logs(
        page_size: Optional[int] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        type_param: Optional[str] = None,
        next_page_token: Optional[str] = None,
        path: Optional[str] = None,
        time_type: Optional[str] = None,
        site_id: Optional[str] = None,
        charged_call_logs: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get account's call logs

        API: GET /phone/call_logs

        Args:
            page_size (int, optional): original param name `page_size`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            type_param (str, optional): original param name `type`
            next_page_token (str, optional): original param name `next_page_token`
            path (str, optional): original param name `path`
            time_type (str, optional): original param name `time_type`
            site_id (str, optional): original param name `site_id`
            charged_call_logs (bool, optional): original param name `charged_call_logs`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_logs"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if type_param is not None:
            params['type'] = type_param
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if path is not None:
            params['path'] = path
        if time_type is not None:
            params['time_type'] = time_type
        if site_id is not None:
            params['site_id'] = site_id
        if charged_call_logs is not None:
            params['charged_call_logs'] = charged_call_logs

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_call_log_details(self, callLogId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get call log details

        API: GET /phone/call_logs/{callLogId}

        Args:
            callLogId (str, required): original param name `callLogId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_logs/{callLogId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_client_code_to_call_log(self, callLogId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a client code to a call log

        API: PUT /phone/call_logs/{callLogId}/client_code

        Args:
            callLogId (str, required): original param name `callLogId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_logs/{callLogId}/client_code"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_user_ai_call_summary(self, userId: str, aiCallSummaryId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get User AI Call Summary Detail

        API: GET /phone/user/{userId}/ai_call_summary/{aiCallSummaryId}

        Args:
            userId (str, required): original param name `userId`
            aiCallSummaryId (str, required): original param name `aiCallSummaryId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/user/{userId}/ai_call_summary/{aiCallSummaryId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def phone_user_call_history(
        userId: str,
        page_size: Optional[int] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        next_page_token: Optional[str] = None,
        keyword: Optional[str] = None,
        directions: Optional[List[str]] = None,
        connect_types: Optional[List[str]] = None,
        number_types: Optional[List[str]] = None,
        call_types: Optional[List[str]] = None,
        extension_types: Optional[List[str]] = None,
        call_results: Optional[List[str]] = None,
        group_ids: Optional[List[str]] = None,
        site_ids: Optional[List[str]] = None,
        department: Optional[str] = None,
        cost_center: Optional[str] = None,
        time_type: Optional[str] = None,
        recording_status: Optional[str] = None,
        with_voicemail: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get user's call history

        API: GET /phone/users/{userId}/call_history

        Args:
            userId (str, required): original param name `userId`
            page_size (int, optional): original param name `page_size`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            next_page_token (str, optional): original param name `next_page_token`
            keyword (str, optional): original param name `keyword`
            directions (List[str], optional): original param name `directions`
            connect_types (List[str], optional): original param name `connect_types`
            number_types (List[str], optional): original param name `number_types`
            call_types (List[str], optional): original param name `call_types`
            extension_types (List[str], optional): original param name `extension_types`
            call_results (List[str], optional): original param name `call_results`
            group_ids (List[str], optional): original param name `group_ids`
            site_ids (List[str], optional): original param name `site_ids`
            department (str, optional): original param name `department`
            cost_center (str, optional): original param name `cost_center`
            time_type (str, optional): original param name `time_type`
            recording_status (str, optional): original param name `recording_status`
            with_voicemail (bool, optional): original param name `with_voicemail`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/call_history"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if keyword is not None:
            params['keyword'] = keyword
        if directions is not None:
            params['directions'] = directions
        if connect_types is not None:
            params['connect_types'] = connect_types
        if number_types is not None:
            params['number_types'] = number_types
        if call_types is not None:
            params['call_types'] = call_types
        if extension_types is not None:
            params['extension_types'] = extension_types
        if call_results is not None:
            params['call_results'] = call_results
        if group_ids is not None:
            params['group_ids'] = group_ids
        if site_ids is not None:
            params['site_ids'] = site_ids
        if department is not None:
            params['department'] = department
        if cost_center is not None:
            params['cost_center'] = cost_center
        if time_type is not None:
            params['time_type'] = time_type
        if recording_status is not None:
            params['recording_status'] = recording_status
        if with_voicemail is not None:
            params['with_voicemail'] = with_voicemail

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def sync_user_call_history(
        userId: str,
        sync_type: Optional[str] = None,
        count: Optional[int] = None,
        sync_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Sync user's call history

        API: GET /phone/users/{userId}/call_history/sync

        Args:
            userId (str, required): original param name `userId`
            sync_type (str, optional): original param name `sync_type`
            count (int, optional): original param name `count`
            sync_token (str, optional): original param name `sync_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/call_history/sync"

        params: Dict[str, Any] = {}
        if sync_type is not None:
            params['sync_type'] = sync_type
        if count is not None:
            params['count'] = count
        if sync_token is not None:
            params['sync_token'] = sync_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_user_call_history(self, userId: str, callLogId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a user's call history

        API: DELETE /phone/users/{userId}/call_history/{callLogId}

        Args:
            userId (str, required): original param name `userId`
            callLogId (str, required): original param name `callLogId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/call_history/{callLogId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def phone_user_call_logs(
        userId: str,
        page_size: Optional[int] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        type_param: Optional[str] = None,
        next_page_token: Optional[str] = None,
        phone_number: Optional[str] = None,
        time_type: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get user's call logs

        API: GET /phone/users/{userId}/call_logs

        Args:
            userId (str, required): original param name `userId`
            page_size (int, optional): original param name `page_size`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            type_param (str, optional): original param name `type`
            next_page_token (str, optional): original param name `next_page_token`
            phone_number (str, optional): original param name `phone_number`
            time_type (str, optional): original param name `time_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/call_logs"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if type_param is not None:
            params['type'] = type_param
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if phone_number is not None:
            params['phone_number'] = phone_number
        if time_type is not None:
            params['time_type'] = time_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def sync_user_call_logs(
        userId: str,
        sync_type: Optional[str] = None,
        count: Optional[int] = None,
        sync_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Sync user's call logs

        API: GET /phone/users/{userId}/call_logs/sync

        Args:
            userId (str, required): original param name `userId`
            sync_type (str, optional): original param name `sync_type`
            count (int, optional): original param name `count`
            sync_token (str, optional): original param name `sync_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/call_logs/sync"

        params: Dict[str, Any] = {}
        if sync_type is not None:
            params['sync_type'] = sync_type
        if count is not None:
            params['count'] = count
        if sync_token is not None:
            params['sync_token'] = sync_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_call_log(self, userId: str, callLogId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a user's call log

        API: DELETE /phone/users/{userId}/call_logs/{callLogId}

        Args:
            userId (str, required): original param name `userId`
            callLogId (str, required): original param name `callLogId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/call_logs/{callLogId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def callqueueanalytics(
        page_size: Optional[int] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        next_page_token: Optional[str] = None,
        site_id: Optional[str] = None,
        call_queue_ext_ids: Optional[List[str]] = None,
        department: Optional[str] = None,
        cost_center: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List call queue analytics

        API: GET /phone/call_queue_analytics

        Args:
            page_size (int, optional): original param name `page_size`
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            next_page_token (str, optional): original param name `next_page_token`
            site_id (str, optional): original param name `site_id`
            call_queue_ext_ids (List[str], optional): original param name `call_queue_ext_ids`
            department (str, optional): original param name `department`
            cost_center (str, optional): original param name `cost_center`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queue_analytics"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if site_id is not None:
            params['site_id'] = site_id
        if call_queue_ext_ids is not None:
            params['call_queue_ext_ids'] = call_queue_ext_ids
        if department is not None:
            params['department'] = department
        if cost_center is not None:
            params['cost_center'] = cost_center

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_call_queues(
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        site_id: Optional[str] = None,
        cost_center: Optional[str] = None,
        department: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List call queues

        API: GET /phone/call_queues

        Args:
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`
            site_id (str, optional): original param name `site_id`
            cost_center (str, optional): original param name `cost_center`
            department (str, optional): original param name `department`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size
        if site_id is not None:
            params['site_id'] = site_id
        if cost_center is not None:
            params['cost_center'] = cost_center
        if department is not None:
            params['department'] = department

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_call_queue(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a call queue

        API: POST /phone/call_queues

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_a_call_queue(self, callQueueId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get call queue details

        API: GET /phone/call_queues/{callQueueId}

        Args:
            callQueueId (str, required): original param name `callQueueId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues/{callQueueId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_a_call_queue(self, callQueueId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a call queue

        API: DELETE /phone/call_queues/{callQueueId}

        Args:
            callQueueId (str, required): original param name `callQueueId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues/{callQueueId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_call_queue(self, callQueueId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update call queue details

        API: PATCH /phone/call_queues/{callQueueId}

        Args:
            callQueueId (str, required): original param name `callQueueId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues/{callQueueId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_call_queue_members(self, callQueueId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List call queue members

        API: GET /phone/call_queues/{callQueueId}/members

        Args:
            callQueueId (str, required): original param name `callQueueId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues/{callQueueId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_members_to_call_queue(self, callQueueId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add members to a call queue

        API: POST /phone/call_queues/{callQueueId}/members

        Args:
            callQueueId (str, required): original param name `callQueueId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues/{callQueueId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def unassign_all_members(self, callQueueId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign all members

        API: DELETE /phone/call_queues/{callQueueId}/members

        Args:
            callQueueId (str, required): original param name `callQueueId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues/{callQueueId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def unassign_member_from_call_queue(self, callQueueId: str, memberId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign a member

        API: DELETE /phone/call_queues/{callQueueId}/members/{memberId}

        Args:
            callQueueId (str, required): original param name `callQueueId`
            memberId (str, required): original param name `memberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues/{callQueueId}/members/{memberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assign_phone_to_call_queue(self, callQueueId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign numbers to a call queue

        API: POST /phone/call_queues/{callQueueId}/phone_numbers

        Args:
            callQueueId (str, required): original param name `callQueueId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues/{callQueueId}/phone_numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def unassign_a_phone_num_call_queue(self, callQueueId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign all phone numbers

        API: DELETE /phone/call_queues/{callQueueId}/phone_numbers

        Args:
            callQueueId (str, required): original param name `callQueueId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues/{callQueueId}/phone_numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def un_assign_phone_num_call_queue(self, callQueueId: str, phoneNumberId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign a phone number

        API: DELETE /phone/call_queues/{callQueueId}/phone_numbers/{phoneNumberId}

        Args:
            callQueueId (str, required): original param name `callQueueId`
            phoneNumberId (str, required): original param name `phoneNumberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues/{callQueueId}/phone_numbers/{phoneNumberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_cq_policy_sub_setting(self, callQueueId: str, policyType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a policy subsetting to a call queue

        API: POST /phone/call_queues/{callQueueId}/policies/{policyType}

        Args:
            callQueueId (str, required): original param name `callQueueId`
            policyType (str, required): original param name `policyType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues/{callQueueId}/policies/{policyType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def remove_cq_policy_sub_setting(self, callQueueId: str, policyType: str, shared_ids: Optional[List[str]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a CQ policy setting

        API: DELETE /phone/call_queues/{callQueueId}/policies/{policyType}

        Args:
            callQueueId (str, required): original param name `callQueueId`
            policyType (str, required): original param name `policyType`
            shared_ids (List[str], required): original param name `shared_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues/{callQueueId}/policies/{policyType}"

        params: Dict[str, Any] = {}
        if shared_ids is not None:
            params['shared_ids'] = shared_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_cq_policy_sub_setting(self, callQueueId: str, policyType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a call queue's policy subsetting

        API: PATCH /phone/call_queues/{callQueueId}/policies/{policyType}

        Args:
            callQueueId (str, required): original param name `callQueueId`
            policyType (str, required): original param name `policyType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues/{callQueueId}/policies/{policyType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_call_queue_recordings(
        callQueueId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get call queue recordings

        API: GET /phone/call_queues/{callQueueId}/recordings

        Args:
            callQueueId (str, required): original param name `callQueueId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_queues/{callQueueId}/recordings"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_cr_phone_numbers(
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        assigned_status: Optional[str] = None,
        sub_account_id: Optional[str] = None,
        keyword: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List phone numbers

        API: GET /phone/carrier_reseller/numbers

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            assigned_status (str, optional): original param name `assigned_status`
            sub_account_id (str, optional): original param name `sub_account_id`
            keyword (str, optional): original param name `keyword`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/carrier_reseller/numbers"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if assigned_status is not None:
            params['assigned_status'] = assigned_status
        if sub_account_id is not None:
            params['sub_account_id'] = sub_account_id
        if keyword is not None:
            params['keyword'] = keyword

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_cr_phone_numbers(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create phone numbers

        API: POST /phone/carrier_reseller/numbers

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/carrier_reseller/numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def active_cr_phone_numbers(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Activate phone numbers

        API: PATCH /phone/carrier_reseller/numbers

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/carrier_reseller/numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_cr_phone_number(self, number: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a phone number

        API: DELETE /phone/carrier_reseller/numbers/{number}

        Args:
            number (str, required): original param name `number`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/carrier_reseller/numbers/{number}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_common_areas(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List common areas

        API: GET /phone/common_areas

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_common_area(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a common area

        API: POST /phone/common_areas

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def generateactivationcodesforcommonareas(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Generate activation codes for common areas

        API: POST /phone/common_areas/activation_code

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/activation_code"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_activation_codes(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List activation codes

        API: GET /phone/common_areas/activation_codes

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/activation_codes"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def apply_templateto_common_areas(self, templateId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Apply template to common areas

        API: POST /phone/common_areas/template_id/{templateId}

        Args:
            templateId (str, required): original param name `templateId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/template_id/{templateId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_a_common_area(self, commonAreaId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get common area details

        API: GET /phone/common_areas/{commonAreaId}

        Args:
            commonAreaId (str, required): original param name `commonAreaId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_common_area(self, commonAreaId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a common area

        API: DELETE /phone/common_areas/{commonAreaId}

        Args:
            commonAreaId (str, required): original param name `commonAreaId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_common_area(self, commonAreaId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update common area

        API: PATCH /phone/common_areas/{commonAreaId}

        Args:
            commonAreaId (str, required): original param name `commonAreaId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assign_calling_plans_to_common_area(self, commonAreaId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign calling plans to a common area

        API: POST /phone/common_areas/{commonAreaId}/calling_plans

        Args:
            commonAreaId (str, required): original param name `commonAreaId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/calling_plans"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def unassign_calling_plans_from_common_area(self, commonAreaId: str, type_param: str, billing_account_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign a calling plan from the common area

        API: DELETE /phone/common_areas/{commonAreaId}/calling_plans/{type}

        Args:
            commonAreaId (str, required): original param name `commonAreaId`
            type_param (str, required): original param name `type`
            billing_account_id (str, optional): original param name `billing_account_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/calling_plans/{type_param}"

        params: Dict[str, Any] = {}
        if billing_account_id is not None:
            params['billing_account_id'] = billing_account_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assign_phone_numbers_to_common_area(self, commonAreaId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign phone numbers to a common area

        API: POST /phone/common_areas/{commonAreaId}/phone_numbers

        Args:
            commonAreaId (str, required): original param name `commonAreaId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/phone_numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def unassign_phone_numbers_from_common_area(self, commonAreaId: str, phoneNumberId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign phone numbers from common area

        API: DELETE /phone/common_areas/{commonAreaId}/phone_numbers/{phoneNumberId}

        Args:
            commonAreaId (str, required): original param name `commonAreaId`
            phoneNumberId (str, required): original param name `phoneNumberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/phone_numbers/{phoneNumberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_common_area_pin_code(self, commonAreaId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update common area pin code

        API: PATCH /phone/common_areas/{commonAreaId}/pin_code

        Args:
            commonAreaId (str, required): original param name `commonAreaId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/pin_code"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_common_area_settings(self, commonAreaId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get common area settings

        API: GET /phone/common_areas/{commonAreaId}/settings

        Args:
            commonAreaId (str, required): original param name `commonAreaId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/settings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_common_area_setting(self, commonAreaId: str, settingType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add common area setting

        API: POST /phone/common_areas/{commonAreaId}/settings/{settingType}

        Args:
            commonAreaId (str, required): original param name `commonAreaId`
            settingType (str, required): original param name `settingType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/settings/{settingType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_common_area_setting(self, commonAreaId: str, settingType: str, device_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete common area setting

        API: DELETE /phone/common_areas/{commonAreaId}/settings/{settingType}

        Args:
            commonAreaId (str, required): original param name `commonAreaId`
            settingType (str, required): original param name `settingType`
            device_id (str, required): original param name `device_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/settings/{settingType}"

        params: Dict[str, Any] = {}
        if device_id is not None:
            params['device_id'] = device_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_common_area_setting(self, commonAreaId: str, settingType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update common area setting

        API: PATCH /phone/common_areas/{commonAreaId}/settings/{settingType}

        Args:
            commonAreaId (str, required): original param name `commonAreaId`
            settingType (str, required): original param name `settingType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/settings/{settingType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_call_logs_metrics(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        site_id: Optional[str] = None,
        quality_type: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List call logs

        API: GET /phone/metrics/call_logs

        Args:
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            site_id (str, optional): original param name `site_id`
            quality_type (str, optional): original param name `quality_type`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/metrics/call_logs"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if site_id is not None:
            params['site_id'] = site_id
        if quality_type is not None:
            params['quality_type'] = quality_type
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_call_qo_s(self, callId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get call QoS

        API: GET /phone/metrics/call_logs/{callId}/qos

        Args:
            callId (str, required): original param name `callId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/metrics/call_logs/{callId}/qos"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_call_log_metrics_details(self, call_id: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get call details from call log

        API: GET /phone/metrics/call_logs/{call_id}

        Args:
            call_id (str, required): original param name `call_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/metrics/call_logs/{call_id}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_user_default_emergency_address(
        status: Optional[str] = None,
        site_id: Optional[str] = None,
        keyword: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List default emergency address users

        API: GET /phone/metrics/emergency_services/default_emergency_address/users

        Args:
            status (str, required): original param name `status`
            site_id (str, optional): original param name `site_id`
            keyword (str, optional): original param name `keyword`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/metrics/emergency_services/default_emergency_address/users"

        params: Dict[str, Any] = {}
        if status is not None:
            params['status'] = status
        if site_id is not None:
            params['site_id'] = site_id
        if keyword is not None:
            params['keyword'] = keyword
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_user_detectable_personal_location(
        status: Optional[str] = None,
        site_id: Optional[str] = None,
        keyword: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List detectable personal location users

        API: GET /phone/metrics/emergency_services/detectable_personal_location/users

        Args:
            status (str, required): original param name `status`
            site_id (str, optional): original param name `site_id`
            keyword (str, optional): original param name `keyword`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/metrics/emergency_services/detectable_personal_location/users"

        params: Dict[str, Any] = {}
        if status is not None:
            params['status'] = status
        if site_id is not None:
            params['site_id'] = site_id
        if keyword is not None:
            params['keyword'] = keyword
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_user_location_sharing_permission(
        site_id: Optional[str] = None,
        keyword: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List users permission for location sharing

        API: GET /phone/metrics/emergency_services/location_sharing_permission/users

        Args:
            site_id (str, optional): original param name `site_id`
            keyword (str, optional): original param name `keyword`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/metrics/emergency_services/location_sharing_permission/users"

        params: Dict[str, Any] = {}
        if site_id is not None:
            params['site_id'] = site_id
        if keyword is not None:
            params['keyword'] = keyword
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_user_nomadic_emergency_services(
        status: Optional[str] = None,
        site_id: Optional[str] = None,
        keyword: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List nomadic emergency services users

        API: GET /phone/metrics/emergency_services/nomadic_emergency_services/users

        Args:
            status (str, required): original param name `status`
            site_id (str, optional): original param name `site_id`
            keyword (str, optional): original param name `keyword`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/metrics/emergency_services/nomadic_emergency_services/users"

        params: Dict[str, Any] = {}
        if status is not None:
            params['status'] = status
        if site_id is not None:
            params['site_id'] = site_id
        if keyword is not None:
            params['keyword'] = keyword
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_phone_realtimelocation(
        location_type: Optional[str] = None,
        site_id: Optional[str] = None,
        keyword: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List real time location for IP phones

        API: GET /phone/metrics/emergency_services/realtime_location/devices

        Args:
            location_type (str, required): original param name `location_type`
            site_id (str, optional): original param name `site_id`
            keyword (str, optional): original param name `keyword`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/metrics/emergency_services/realtime_location/devices"

        params: Dict[str, Any] = {}
        if location_type is not None:
            params['location_type'] = location_type
        if site_id is not None:
            params['site_id'] = site_id
        if keyword is not None:
            params['keyword'] = keyword
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_user_realtime_location(
        location_type: Optional[str] = None,
        site_id: Optional[str] = None,
        keyword: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List real time location for users

        API: GET /phone/metrics/emergency_services/realtime_location/users

        Args:
            location_type (str, required): original param name `location_type`
            site_id (str, optional): original param name `site_id`
            keyword (str, optional): original param name `keyword`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/metrics/emergency_services/realtime_location/users"

        params: Dict[str, Any] = {}
        if location_type is not None:
            params['location_type'] = location_type
        if site_id is not None:
            params['site_id'] = site_id
        if keyword is not None:
            params['keyword'] = keyword
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_tracked_locations(
        type_param: Optional[int] = None,
        site_id: Optional[str] = None,
        location_type: Optional[str] = None,
        keyword: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List tracked locations

        API: GET /phone/metrics/location_tracking

        Args:
            type_param (int, optional): original param name `type`
            site_id (str, optional): original param name `site_id`
            location_type (str, optional): original param name `location_type`
            keyword (str, optional): original param name `keyword`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/metrics/location_tracking"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if site_id is not None:
            params['site_id'] = site_id
        if location_type is not None:
            params['location_type'] = location_type
        if keyword is not None:
            params['keyword'] = keyword

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_past_call_metrics(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        phone_number: Optional[str] = None,
        extension_number: Optional[str] = None,
        quality_type: Optional[str] = None,
        department: Optional[str] = None,
        cost_center: Optional[str] = None,
        directions: Optional[List[str]] = None,
        durations: Optional[List[int]] = None,
        site_id: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List past call metrics

        API: GET /phone/metrics/past_calls

        Args:
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            phone_number (str, optional): original param name `phone_number`
            extension_number (str, optional): original param name `extension_number`
            quality_type (str, optional): original param name `quality_type`
            department (str, optional): original param name `department`
            cost_center (str, optional): original param name `cost_center`
            directions (List[str], optional): original param name `directions`
            durations (List[int], optional): original param name `durations`
            site_id (str, optional): original param name `site_id`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/metrics/past_calls"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if phone_number is not None:
            params['phone_number'] = phone_number
        if extension_number is not None:
            params['extension_number'] = extension_number
        if quality_type is not None:
            params['quality_type'] = quality_type
        if department is not None:
            params['department'] = department
        if cost_center is not None:
            params['cost_center'] = cost_center
        if directions is not None:
            params['directions'] = directions
        if durations is not None:
            params['durations'] = durations
        if site_id is not None:
            params['site_id'] = site_id
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_device_line_key_setting(self, deviceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get device line keys information

        API: GET /phone/devices/{deviceId}/line_keys

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/devices/{deviceId}/line_keys"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def batch_update_device_line_key_setting(self, deviceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Batch update device line key position

        API: PATCH /phone/devices/{deviceId}/line_keys

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/devices/{deviceId}/line_keys"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_users_from_directory(
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        in_directory: Optional[bool] = None,
        site_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List users in directory

        API: GET /phone/dial_by_name_directory/extensions

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            in_directory (bool, optional): original param name `in_directory`
            site_id (str, required): original param name `site_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/dial_by_name_directory/extensions"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if in_directory is not None:
            params['in_directory'] = in_directory
        if site_id is not None:
            params['site_id'] = site_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_users_to_directory(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add users to a directory

        API: POST /phone/dial_by_name_directory/extensions

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/dial_by_name_directory/extensions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_users_from_directory(self, site_id: Optional[str] = None, extension_ids: Optional[List[str]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete users from a directory

        API: DELETE /phone/dial_by_name_directory/extensions

        Args:
            site_id (str, required): original param name `site_id`
            extension_ids (List[str], optional): original param name `extension_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/dial_by_name_directory/extensions"

        params: Dict[str, Any] = {}
        if site_id is not None:
            params['site_id'] = site_id
        if extension_ids is not None:
            params['extension_ids'] = extension_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_users_from_directory_by_site(
        siteId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        in_directory: Optional[bool] = None,
        site_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List users in a directory by site

        API: GET /phone/sites/{siteId}/dial_by_name_directory/extensions

        Args:
            siteId (str, required): original param name `siteId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            in_directory (bool, optional): original param name `in_directory`
            site_id (str, optional): original param name `site_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/dial_by_name_directory/extensions"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if in_directory is not None:
            params['in_directory'] = in_directory
        if site_id is not None:
            params['site_id'] = site_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_users_to_directory_by_site(self, siteId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add users to a directory of a site

        API: POST /phone/sites/{siteId}/dial_by_name_directory/extensions

        Args:
            siteId (str, required): original param name `siteId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/dial_by_name_directory/extensions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_users_from_directory_by_site(self, siteId: str, site_id: Optional[str] = None, extension_ids: Optional[List[str]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete users from a directory of a site

        API: DELETE /phone/sites/{siteId}/dial_by_name_directory/extensions

        Args:
            siteId (str, required): original param name `siteId`
            site_id (str, optional): original param name `site_id`
            extension_ids (List[str], optional): original param name `extension_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/dial_by_name_directory/extensions"

        params: Dict[str, Any] = {}
        if site_id is not None:
            params['site_id'] = site_id
        if extension_ids is not None:
            params['extension_ids'] = extension_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_emergency_addresses(
        site_id: Optional[str] = None,
        user_id: Optional[str] = None,
        level: Optional[int] = None,
        status: Optional[int] = None,
        address_keyword: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List emergency addresses

        API: GET /phone/emergency_addresses

        Args:
            site_id (str, optional): original param name `site_id`
            user_id (str, optional): original param name `user_id`
            level (int, optional): original param name `level`
            status (int, optional): original param name `status`
            address_keyword (str, optional): original param name `address_keyword`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/emergency_addresses"

        params: Dict[str, Any] = {}
        if site_id is not None:
            params['site_id'] = site_id
        if user_id is not None:
            params['user_id'] = user_id
        if level is not None:
            params['level'] = level
        if status is not None:
            params['status'] = status
        if address_keyword is not None:
            params['address_keyword'] = address_keyword
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_emergency_address(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add an emergency address

        API: POST /phone/emergency_addresses

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/emergency_addresses"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_emergency_address(self, emergencyAddressId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get emergency address details

        API: GET /phone/emergency_addresses/{emergencyAddressId}

        Args:
            emergencyAddressId (str, required): original param name `emergencyAddressId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/emergency_addresses/{emergencyAddressId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_emergency_address(self, emergencyAddressId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an emergency address

        API: DELETE /phone/emergency_addresses/{emergencyAddressId}

        Args:
            emergencyAddressId (str, required): original param name `emergencyAddressId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/emergency_addresses/{emergencyAddressId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_emergency_address(self, emergencyAddressId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an emergency address

        API: PATCH /phone/emergency_addresses/{emergencyAddressId}

        Args:
            emergencyAddressId (str, required): original param name `emergencyAddressId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/emergency_addresses/{emergencyAddressId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def batch_add_locations(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Batch add emergency service locations

        API: POST /phone/batch_locations

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/batch_locations"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_locations(self, next_page_token: Optional[str] = None, page_size: Optional[int] = None, site_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List emergency service locations

        API: GET /phone/locations

        Args:
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`
            site_id (str, optional): original param name `site_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/locations"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size
        if site_id is not None:
            params['site_id'] = site_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_location(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add an emergency service location

        API: POST /phone/locations

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/locations"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_location(self, locationId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get emergency service location details

        API: GET /phone/locations/{locationId}

        Args:
            locationId (str, required): original param name `locationId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/locations/{locationId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_location(self, locationId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an emergency location

        API: DELETE /phone/locations/{locationId}

        Args:
            locationId (str, required): original param name `locationId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/locations/{locationId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_location(self, locationId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update emergency service location

        API: PATCH /phone/locations/{locationId}

        Args:
            locationId (str, required): original param name `locationId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/locations/{locationId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_external_contacts(self, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List external contacts

        API: GET /phone/external_contacts

        Args:
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/external_contacts"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_external_contact(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add an external contact

        API: POST /phone/external_contacts

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/external_contacts"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_a_external_contact(self, externalContactId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get external contact details

        API: GET /phone/external_contacts/{externalContactId}

        Args:
            externalContactId (str, required): original param name `externalContactId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/external_contacts/{externalContactId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_a_external_contact(self, externalContactId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an external contact

        API: DELETE /phone/external_contacts/{externalContactId}

        Args:
            externalContactId (str, required): original param name `externalContactId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/external_contacts/{externalContactId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_external_contact(self, externalContactId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update external contact

        API: PATCH /phone/external_contacts/{externalContactId}

        Args:
            externalContactId (str, required): original param name `externalContactId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/external_contacts/{externalContactId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getuser_sfaxlogs(
        extensionId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        sender_number: Optional[str] = None,
        receiver_number: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get extension's fax logs

        API: GET /phone/extension/{extensionId}/fax/logs

        Args:
            extensionId (str, required): original param name `extensionId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            sender_number (str, optional): original param name `sender_number`
            receiver_number (str, optional): original param name `receiver_number`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/extension/{extensionId}/fax/logs"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if sender_number is not None:
            params['sender_number'] = sender_number
        if receiver_number is not None:
            params['receiver_number'] = receiver_number

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_account_s_fax_logs(
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        site_id: Optional[str] = None,
        sender_number: Optional[str] = None,
        receiver_number: Optional[str] = None,
        extension_type: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get account's fax logs

        API: GET /phone/fax/logs

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            site_id (str, optional): original param name `site_id`
            sender_number (str, optional): original param name `sender_number`
            receiver_number (str, optional): original param name `receiver_number`
            extension_type (str, optional): original param name `extension_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/fax/logs"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if site_id is not None:
            params['site_id'] = site_id
        if sender_number is not None:
            params['sender_number'] = sender_number
        if receiver_number is not None:
            params['receiver_number'] = receiver_number
        if extension_type is not None:
            params['extension_type'] = extension_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_fax_log_details(self, faxLogId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get fax log details

        API: GET /phone/fax/logs/{faxLogId}

        Args:
            faxLogId (str, required): original param name `faxLogId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/fax/logs/{faxLogId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def downloadfaxfile(self, faxLogId: str, fileId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Download fax file

        API: GET /phone/fax/logs/{faxLogId}/file/{fileId}

        Args:
            faxLogId (str, required): original param name `faxLogId`
            fileId (str, required): original param name `fileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/fax/logs/{faxLogId}/file/{fileId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_firmware_rules(self, site_id: Optional[str] = None, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List firmware update rules

        API: GET /phone/firmware_update_rules

        Args:
            site_id (str, optional): original param name `site_id`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/firmware_update_rules"

        params: Dict[str, Any] = {}
        if site_id is not None:
            params['site_id'] = site_id
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_firmware_rule(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a firmware update rule

        API: POST /phone/firmware_update_rules

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/firmware_update_rules"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_firmware_rule_detail(self, ruleId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get firmware update rule information

        API: GET /phone/firmware_update_rules/{ruleId}

        Args:
            ruleId (str, required): original param name `ruleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/firmware_update_rules/{ruleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_firmware_update_rule(self, ruleId: str, restart_type: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete firmware update rule

        API: DELETE /phone/firmware_update_rules/{ruleId}

        Args:
            ruleId (str, required): original param name `ruleId`
            restart_type (int, optional): original param name `restart_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/firmware_update_rules/{ruleId}"

        params: Dict[str, Any] = {}
        if restart_type is not None:
            params['restart_type'] = restart_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_firmware_rule(self, ruleId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update firmware update rule

        API: PATCH /phone/firmware_update_rules/{ruleId}

        Args:
            ruleId (str, required): original param name `ruleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/firmware_update_rules/{ruleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_firmwares(self, is_update: Optional[bool] = None, site_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List updatable firmwares

        API: GET /phone/firmwares

        Args:
            is_update (bool, optional): original param name `is_update`
            site_id (str, optional): original param name `site_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/firmwares"

        params: Dict[str, Any] = {}
        if is_update is not None:
            params['is_update'] = is_update
        if site_id is not None:
            params['site_id'] = site_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_gcp(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, site_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List group call pickup objects

        API: GET /phone/group_call_pickup

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            site_id (str, optional): original param name `site_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/group_call_pickup"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if site_id is not None:
            params['site_id'] = site_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_gcp(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a group call pickup object

        API: POST /phone/group_call_pickup

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/group_call_pickup"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_gcp(self, groupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get call pickup group by ID

        API: GET /phone/group_call_pickup/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/group_call_pickup/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_gcp(self, groupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete group call pickup objects

        API: DELETE /phone/group_call_pickup/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/group_call_pickup/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_gcp(self, groupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update the group call pickup information

        API: PATCH /phone/group_call_pickup/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/group_call_pickup/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_gcp_members(
        groupId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        site_id: Optional[str] = None,
        extension_type: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List call pickup group members

        API: GET /phone/group_call_pickup/{groupId}/members

        Args:
            groupId (str, required): original param name `groupId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            site_id (str, optional): original param name `site_id`
            extension_type (str, optional): original param name `extension_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/group_call_pickup/{groupId}/members"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if site_id is not None:
            params['site_id'] = site_id
        if extension_type is not None:
            params['extension_type'] = extension_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_gcp_members(self, groupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add members to a call pickup group

        API: POST /phone/group_call_pickup/{groupId}/members

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/group_call_pickup/{groupId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def remove_gcp_members(self, groupId: str, extensionId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove members from call pickup group

        API: DELETE /phone/group_call_pickup/{groupId}/members/{extensionId}

        Args:
            groupId (str, required): original param name `groupId`
            extensionId (str, required): original param name `extensionId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/group_call_pickup/{groupId}/members/{extensionId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_group_policy_details(self, groupId: str, policyType: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get group policy details

        API: GET /phone/groups/{groupId}/policies/{policyType}

        Args:
            groupId (str, required): original param name `groupId`
            policyType (str, required): original param name `policyType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/groups/{groupId}/policies/{policyType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_group_policy(self, groupId: str, policyType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update group policy

        API: PATCH /phone/groups/{groupId}/policies/{policyType}

        Args:
            groupId (str, required): original param name `groupId`
            policyType (str, required): original param name `policyType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/groups/{groupId}/policies/{policyType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_group_phone_settings(self, groupId: str, setting_types: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get group phone settings

        API: GET /phone/groups/{groupId}/settings

        Args:
            groupId (str, required): original param name `groupId`
            setting_types (str, optional): original param name `setting_types`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/groups/{groupId}/settings"

        params: Dict[str, Any] = {}
        if setting_types is not None:
            params['setting_types'] = setting_types

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_auto_receptionist_ivr(self, autoReceptionistId: str, hours_type: Optional[str] = None, holiday_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get auto receptionist IVR

        API: GET /phone/auto_receptionists/{autoReceptionistId}/ivr

        Args:
            autoReceptionistId (str, required): original param name `autoReceptionistId`
            hours_type (str, optional): original param name `hours_type`
            holiday_id (str, optional): original param name `holiday_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists/{autoReceptionistId}/ivr"

        params: Dict[str, Any] = {}
        if hours_type is not None:
            params['hours_type'] = hours_type
        if holiday_id is not None:
            params['holiday_id'] = holiday_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_auto_receptionist_ivr(self, autoReceptionistId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update auto receptionist IVR

        API: PATCH /phone/auto_receptionists/{autoReceptionistId}/ivr

        Args:
            autoReceptionistId (str, required): original param name `autoReceptionistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/auto_receptionists/{autoReceptionistId}/ivr"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_extension_level_inbound_block_rules(
        extensionId: str,
        keyword: Optional[str] = None,
        match_type: Optional[str] = None,
        type_param: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List an extension's inbound block rules

        API: GET /phone/extension/{extensionId}/inbound_blocked/rules

        Args:
            extensionId (str, required): original param name `extensionId`
            keyword (str, optional): original param name `keyword`
            match_type (str, optional): original param name `match_type`
            type_param (str, optional): original param name `type`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/extension/{extensionId}/inbound_blocked/rules"

        params: Dict[str, Any] = {}
        if keyword is not None:
            params['keyword'] = keyword
        if match_type is not None:
            params['match_type'] = match_type
        if type_param is not None:
            params['type'] = type_param
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_extensiont_level_inbound_block_rules(self, extensionId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add an extension's inbound block rule

        API: POST /phone/extension/{extensionId}/inbound_blocked/rules

        Args:
            extensionId (str, required): original param name `extensionId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/extension/{extensionId}/inbound_blocked/rules"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_extensiont_level_inbound_block_rules(self, extensionId: str, blocked_rule_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an extension's inbound block rule

        API: DELETE /phone/extension/{extensionId}/inbound_blocked/rules

        Args:
            extensionId (str, required): original param name `extensionId`
            blocked_rule_id (str, required): original param name `blocked_rule_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/extension/{extensionId}/inbound_blocked/rules"

        params: Dict[str, Any] = {}
        if blocked_rule_id is not None:
            params['blocked_rule_id'] = blocked_rule_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_account_level_inbound_blocked_statistics(
        keyword: Optional[str] = None,
        match_type: Optional[str] = None,
        type_param: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List an account's inbound blocked statistics

        API: GET /phone/inbound_blocked/extension_rules/statistics

        Args:
            keyword (str, optional): original param name `keyword`
            match_type (str, optional): original param name `match_type`
            type_param (str, optional): original param name `type`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/inbound_blocked/extension_rules/statistics"

        params: Dict[str, Any] = {}
        if keyword is not None:
            params['keyword'] = keyword
        if match_type is not None:
            params['match_type'] = match_type
        if type_param is not None:
            params['type'] = type_param
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_account_level_inbound_blocked_statistics(self, blocked_statistic_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an account's inbound blocked statistics

        API: DELETE /phone/inbound_blocked/extension_rules/statistics

        Args:
            blocked_statistic_id (str, required): original param name `blocked_statistic_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/inbound_blocked/extension_rules/statistics"

        params: Dict[str, Any] = {}
        if blocked_statistic_id is not None:
            params['blocked_statistic_id'] = blocked_statistic_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def mark_phone_number_as_blocked_for_all_extensions(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Mark a phone number as blocked for all extensions

        API: PATCH /phone/inbound_blocked/extension_rules/statistics/blocked_for_all

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/inbound_blocked/extension_rules/statistics/blocked_for_all"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_account_level_inbound_block_rules(
        keyword: Optional[str] = None,
        match_type: Optional[str] = None,
        type_param: Optional[str] = None,
        status: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List an account's inbound block rules

        API: GET /phone/inbound_blocked/rules

        Args:
            keyword (str, optional): original param name `keyword`
            match_type (str, optional): original param name `match_type`
            type_param (str, optional): original param name `type`
            status (str, optional): original param name `status`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/inbound_blocked/rules"

        params: Dict[str, Any] = {}
        if keyword is not None:
            params['keyword'] = keyword
        if match_type is not None:
            params['match_type'] = match_type
        if type_param is not None:
            params['type'] = type_param
        if status is not None:
            params['status'] = status
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_account_level_inbound_block_rules(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add an account's inbound block rule

        API: POST /phone/inbound_blocked/rules

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/inbound_blocked/rules"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_account_level_inbound_block_rules(self, blocked_rule_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an account's inbound block rule

        API: DELETE /phone/inbound_blocked/rules

        Args:
            blocked_rule_id (str, required): original param name `blocked_rule_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/inbound_blocked/rules"

        params: Dict[str, Any] = {}
        if blocked_rule_id is not None:
            params['blocked_rule_id'] = blocked_rule_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_account_level_inbound_block_rule(self, blockedRuleId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an account's inbound block rule

        API: PATCH /phone/inbound_blocked/rules/{blockedRuleId}

        Args:
            blockedRuleId (str, required): original param name `blockedRuleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/inbound_blocked/rules/{blockedRuleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_line_key_setting(self, extensionId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get line key position and settings information

        API: GET /phone/extension/{extensionId}/line_keys

        Args:
            extensionId (str, required): original param name `extensionId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/extension/{extensionId}/line_keys"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def batch_update_line_key_setting(self, extensionId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Batch update line key position and settings information

        API: PATCH /phone/extension/{extensionId}/line_keys

        Args:
            extensionId (str, required): original param name `extensionId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/extension/{extensionId}/line_keys"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_line_key(self, extensionId: str, lineKeyId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a line key setting.

        API: DELETE /phone/extension/{extensionId}/line_keys/{lineKeyId}

        Args:
            extensionId (str, required): original param name `extensionId`
            lineKeyId (str, required): original param name `lineKeyId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/extension/{extensionId}/line_keys/{lineKeyId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_monitoring_group(
        type_param: Optional[int] = None,
        site_id: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get a list of monitoring groups on an account

        API: GET /phone/monitoring_groups

        Args:
            type_param (int, optional): original param name `type`
            site_id (str, optional): original param name `site_id`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/monitoring_groups"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if site_id is not None:
            params['site_id'] = site_id
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_monitoring_group(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a monitoring group

        API: POST /phone/monitoring_groups

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/monitoring_groups"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_monitoring_group_by_id(self, monitoringGroupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get monitoring group by ID

        API: GET /phone/monitoring_groups/{monitoringGroupId}

        Args:
            monitoringGroupId (str, required): original param name `monitoringGroupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/monitoring_groups/{monitoringGroupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_monitoring_group(self, monitoringGroupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a monitoring group

        API: DELETE /phone/monitoring_groups/{monitoringGroupId}

        Args:
            monitoringGroupId (str, required): original param name `monitoringGroupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/monitoring_groups/{monitoringGroupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_monitoring_group(self, monitoringGroupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a monitoring group

        API: PATCH /phone/monitoring_groups/{monitoringGroupId}

        Args:
            monitoringGroupId (str, required): original param name `monitoringGroupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/monitoring_groups/{monitoringGroupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_members(
        monitoringGroupId: str,
        member_type: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get members of a monitoring group

        API: GET /phone/monitoring_groups/{monitoringGroupId}/monitor_members

        Args:
            monitoringGroupId (str, required): original param name `monitoringGroupId`
            member_type (str, required): original param name `member_type`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/monitoring_groups/{monitoringGroupId}/monitor_members"

        params: Dict[str, Any] = {}
        if member_type is not None:
            params['member_type'] = member_type
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_members(self, monitoringGroupId: str, member_type: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add members to a monitoring group

        API: POST /phone/monitoring_groups/{monitoringGroupId}/monitor_members

        Args:
            monitoringGroupId (str, required): original param name `monitoringGroupId`
            member_type (str, required): original param name `member_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/monitoring_groups/{monitoringGroupId}/monitor_members"

        params: Dict[str, Any] = {}
        if member_type is not None:
            params['member_type'] = member_type

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def remove_members(self, monitoringGroupId: str, member_type: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove all monitors or monitored members from a monitoring group

        API: DELETE /phone/monitoring_groups/{monitoringGroupId}/monitor_members

        Args:
            monitoringGroupId (str, required): original param name `monitoringGroupId`
            member_type (str, required): original param name `member_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/monitoring_groups/{monitoringGroupId}/monitor_members"

        params: Dict[str, Any] = {}
        if member_type is not None:
            params['member_type'] = member_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def remove_member(self, monitoringGroupId: str, memberExtensionId: str, member_type: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove a member from a monitoring group

        API: DELETE /phone/monitoring_groups/{monitoringGroupId}/monitor_members/{memberExtensionId}

        Args:
            monitoringGroupId (str, required): original param name `monitoringGroupId`
            memberExtensionId (str, required): original param name `memberExtensionId`
            member_type (str, optional): original param name `member_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/monitoring_groups/{monitoringGroupId}/monitor_members/{memberExtensionId}"

        params: Dict[str, Any] = {}
        if member_type is not None:
            params['member_type'] = member_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_common_area_outbound_calling_countries_and_regions(self, commonAreaId: str, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get common area level outbound calling countries and regions

        API: GET /phone/common_areas/{commonAreaId}/outbound_calling/countries_regions

        Args:
            commonAreaId (str, required): original param name `commonAreaId`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/outbound_calling/countries_regions"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_common_area_outbound_calling_countries_or_regions(self, commonAreaId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update common area level outbound calling countries or regions

        API: PATCH /phone/common_areas/{commonAreaId}/outbound_calling/countries_regions

        Args:
            commonAreaId (str, required): original param name `commonAreaId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/outbound_calling/countries_regions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_common_area_outbound_calling_exception_rule(
        commonAreaId: str,
        country: Optional[str] = None,
        keyword: Optional[str] = None,
        match_type: Optional[str] = None,
        status: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List common area level outbound calling exception rules

        API: GET /phone/common_areas/{commonAreaId}/outbound_calling/exception_rules

        Args:
            commonAreaId (str, required): original param name `commonAreaId`
            country (str, optional): original param name `country`
            keyword (str, optional): original param name `keyword`
            match_type (str, optional): original param name `match_type`
            status (str, optional): original param name `status`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/outbound_calling/exception_rules"

        params: Dict[str, Any] = {}
        if country is not None:
            params['country'] = country
        if keyword is not None:
            params['keyword'] = keyword
        if match_type is not None:
            params['match_type'] = match_type
        if status is not None:
            params['status'] = status
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_common_area_outbound_calling_exception_rule(self, commonAreaId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add common area level outbound calling exception rule

        API: POST /phone/common_areas/{commonAreaId}/outbound_calling/exception_rules

        Args:
            commonAreaId (str, required): original param name `commonAreaId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/outbound_calling/exception_rules"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_common_area_outbound_calling_exception_rule(self, commonAreaId: str, exceptionRuleId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete common area level outbound calling exception rule

        API: DELETE /phone/common_areas/{commonAreaId}/outbound_calling/exception_rules/{exceptionRuleId}

        Args:
            commonAreaId (str, required): original param name `commonAreaId`
            exceptionRuleId (str, required): original param name `exceptionRuleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/outbound_calling/exception_rules/{exceptionRuleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_common_area_outbound_calling_exception_rule(self, commonAreaId: str, exceptionRuleId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update common area level outbound calling exception rule

        API: PATCH /phone/common_areas/{commonAreaId}/outbound_calling/exception_rules/{exceptionRuleId}

        Args:
            commonAreaId (str, required): original param name `commonAreaId`
            exceptionRuleId (str, required): original param name `exceptionRuleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/common_areas/{commonAreaId}/outbound_calling/exception_rules/{exceptionRuleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_account_outbound_calling_countries_and_regions(self, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get account level outbound calling countries and regions

        API: GET /phone/outbound_calling/countries_regions

        Args:
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/outbound_calling/countries_regions"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_account_outbound_calling_countries_or_regions(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update account level outbound calling countries or regions

        API: PATCH /phone/outbound_calling/countries_regions

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/outbound_calling/countries_regions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_account_outbound_calling_exception_rule(
        country: Optional[str] = None,
        keyword: Optional[str] = None,
        match_type: Optional[str] = None,
        status: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List account level outbound calling exception rules

        API: GET /phone/outbound_calling/exception_rules

        Args:
            country (str, optional): original param name `country`
            keyword (str, optional): original param name `keyword`
            match_type (str, optional): original param name `match_type`
            status (str, optional): original param name `status`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/outbound_calling/exception_rules"

        params: Dict[str, Any] = {}
        if country is not None:
            params['country'] = country
        if keyword is not None:
            params['keyword'] = keyword
        if match_type is not None:
            params['match_type'] = match_type
        if status is not None:
            params['status'] = status
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_account_outbound_calling_exception_rule(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add account level outbound calling exception rule

        API: POST /phone/outbound_calling/exception_rules

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/outbound_calling/exception_rules"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_account_outbound_calling_exception_rule(self, exceptionRuleId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete account level outbound calling exception rule

        API: DELETE /phone/outbound_calling/exception_rules/{exceptionRuleId}

        Args:
            exceptionRuleId (str, required): original param name `exceptionRuleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/outbound_calling/exception_rules/{exceptionRuleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_account_outbound_calling_exception_rule(self, exceptionRuleId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update account level outbound calling exception rule

        API: PATCH /phone/outbound_calling/exception_rules/{exceptionRuleId}

        Args:
            exceptionRuleId (str, required): original param name `exceptionRuleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/outbound_calling/exception_rules/{exceptionRuleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_site_outbound_calling_countries_and_regions(self, siteId: str, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get site level outbound calling countries and regions

        API: GET /phone/sites/{siteId}/outbound_calling/countries_regions

        Args:
            siteId (str, required): original param name `siteId`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/outbound_calling/countries_regions"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_site_outbound_calling_countries_or_regions(self, siteId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update site level outbound calling countries or regions

        API: PATCH /phone/sites/{siteId}/outbound_calling/countries_regions

        Args:
            siteId (str, required): original param name `siteId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/outbound_calling/countries_regions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_site_outbound_calling_exception_rule(
        siteId: str,
        country: Optional[str] = None,
        keyword: Optional[str] = None,
        match_type: Optional[str] = None,
        status: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List site level outbound calling exception rules

        API: GET /phone/sites/{siteId}/outbound_calling/exception_rules

        Args:
            siteId (str, required): original param name `siteId`
            country (str, optional): original param name `country`
            keyword (str, optional): original param name `keyword`
            match_type (str, optional): original param name `match_type`
            status (str, optional): original param name `status`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/outbound_calling/exception_rules"

        params: Dict[str, Any] = {}
        if country is not None:
            params['country'] = country
        if keyword is not None:
            params['keyword'] = keyword
        if match_type is not None:
            params['match_type'] = match_type
        if status is not None:
            params['status'] = status
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_site_outbound_calling_exception_rule(self, siteId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add site level outbound calling exception rule

        API: POST /phone/sites/{siteId}/outbound_calling/exception_rules

        Args:
            siteId (str, required): original param name `siteId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/outbound_calling/exception_rules"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_site_outbound_calling_exception_rule(self, siteId: str, exceptionRuleId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete site level outbound calling exception rule

        API: DELETE /phone/sites/{siteId}/outbound_calling/exception_rules/{exceptionRuleId}

        Args:
            siteId (str, required): original param name `siteId`
            exceptionRuleId (str, required): original param name `exceptionRuleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/outbound_calling/exception_rules/{exceptionRuleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_site_outbound_calling_exception_rule(self, siteId: str, exceptionRuleId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update site level outbound calling exception rule

        API: PATCH /phone/sites/{siteId}/outbound_calling/exception_rules/{exceptionRuleId}

        Args:
            siteId (str, required): original param name `siteId`
            exceptionRuleId (str, required): original param name `exceptionRuleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/outbound_calling/exception_rules/{exceptionRuleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_user_outbound_calling_countries_and_regions(self, userId: str, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get user level outbound calling countries and regions

        API: GET /phone/users/{userId}/outbound_calling/countries_regions

        Args:
            userId (str, required): original param name `userId`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/outbound_calling/countries_regions"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_user_outbound_calling_countries_or_regions(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update user level outbound calling countries or regions

        API: PATCH /phone/users/{userId}/outbound_calling/countries_regions

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/outbound_calling/countries_regions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_user_outbound_calling_exception_rule(
        userId: str,
        country: Optional[str] = None,
        keyword: Optional[str] = None,
        match_type: Optional[str] = None,
        status: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List user level outbound calling exception rules

        API: GET /phone/users/{userId}/outbound_calling/exception_rules

        Args:
            userId (str, required): original param name `userId`
            country (str, optional): original param name `country`
            keyword (str, optional): original param name `keyword`
            match_type (str, optional): original param name `match_type`
            status (str, optional): original param name `status`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/outbound_calling/exception_rules"

        params: Dict[str, Any] = {}
        if country is not None:
            params['country'] = country
        if keyword is not None:
            params['keyword'] = keyword
        if match_type is not None:
            params['match_type'] = match_type
        if status is not None:
            params['status'] = status
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_user_outbound_calling_exception_rule(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add user level outbound calling exception rule

        API: POST /phone/users/{userId}/outbound_calling/exception_rules

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/outbound_calling/exception_rules"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_user_outbound_calling_exception_rule(self, userId: str, exceptionRuleId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete user level outbound calling exception rule

        API: DELETE /phone/users/{userId}/outbound_calling/exception_rules/{exceptionRuleId}

        Args:
            userId (str, required): original param name `userId`
            exceptionRuleId (str, required): original param name `exceptionRuleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/outbound_calling/exception_rules/{exceptionRuleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_user_outbound_calling_exception_rule(self, userId: str, exceptionRuleId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update user level outbound calling exception rule

        API: PATCH /phone/users/{userId}/outbound_calling/exception_rules/{exceptionRuleId}

        Args:
            userId (str, required): original param name `userId`
            exceptionRuleId (str, required): original param name `exceptionRuleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/outbound_calling/exception_rules/{exceptionRuleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_phone_devices(
        type_param: Optional[str] = None,
        assignee_type: Optional[str] = None,
        device_source: Optional[str] = None,
        location_status: Optional[str] = None,
        site_id: Optional[str] = None,
        device_type: Optional[str] = None,
        keyword: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List devices

        API: GET /phone/devices

        Args:
            type_param (str, required): original param name `type`
            assignee_type (str, optional): original param name `assignee_type`
            device_source (str, optional): original param name `device_source`
            location_status (str, optional): original param name `location_status`
            site_id (str, optional): original param name `site_id`
            device_type (str, optional): original param name `device_type`
            keyword (str, optional): original param name `keyword`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/devices"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if assignee_type is not None:
            params['assignee_type'] = assignee_type
        if device_source is not None:
            params['device_source'] = device_source
        if location_status is not None:
            params['location_status'] = location_status
        if site_id is not None:
            params['site_id'] = site_id
        if device_type is not None:
            params['device_type'] = device_type
        if keyword is not None:
            params['keyword'] = keyword
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_phone_device(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a device

        API: POST /phone/devices

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/devices"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def sync_phone_device(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Sync deskphones

        API: POST /phone/devices/sync

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/devices/sync"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_a_device(self, deviceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get device details

        API: GET /phone/devices/{deviceId}

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/devices/{deviceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_a_device(self, deviceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a device

        API: DELETE /phone/devices/{deviceId}

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/devices/{deviceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_a_device(self, deviceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a device

        API: PATCH /phone/devices/{deviceId}

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/devices/{deviceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_extensions_to_a_device(self, deviceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign an entity to a device

        API: POST /phone/devices/{deviceId}/extensions

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/devices/{deviceId}/extensions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_extension_from_a_device(self, deviceId: str, extensionId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign an entity from the device

        API: DELETE /phone/devices/{deviceId}/extensions/{extensionId}

        Args:
            deviceId (str, required): original param name `deviceId`
            extensionId (str, required): original param name `extensionId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/devices/{deviceId}/extensions/{extensionId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_provision_template_to_device(self, deviceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update provision template of a device

        API: PUT /phone/devices/{deviceId}/provision_templates

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/devices/{deviceId}/provision_templates"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def reboot_phone_device(self, deviceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Reboot a desk phone

        API: POST /phone/devices/{deviceId}/reboot

        Args:
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/devices/{deviceId}/reboot"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_smartphones(
        site_id: Optional[str] = None,
        keyword: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List Smartphones

        API: GET /phone/smartphones

        Args:
            site_id (str, optional): original param name `site_id`
            keyword (str, optional): original param name `keyword`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/smartphones"

        params: Dict[str, Any] = {}
        if site_id is not None:
            params['site_id'] = site_id
        if keyword is not None:
            params['keyword'] = keyword
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_byoc_number(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add BYOC phone numbers

        API: POST /phone/byoc_numbers

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/byoc_numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_account_phone_numbers(
        next_page_token: Optional[str] = None,
        type_param: Optional[str] = None,
        extension_type: Optional[str] = None,
        page_size: Optional[int] = None,
        number_type: Optional[str] = None,
        pending_numbers: Optional[bool] = None,
        site_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List phone numbers

        API: GET /phone/numbers

        Args:
            next_page_token (str, optional): original param name `next_page_token`
            type_param (str, optional): original param name `type`
            extension_type (str, optional): original param name `extension_type`
            page_size (int, optional): original param name `page_size`
            number_type (str, optional): original param name `number_type`
            pending_numbers (bool, optional): original param name `pending_numbers`
            site_id (str, optional): original param name `site_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/numbers"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if type_param is not None:
            params['type'] = type_param
        if extension_type is not None:
            params['extension_type'] = extension_type
        if page_size is not None:
            params['page_size'] = page_size
        if number_type is not None:
            params['number_type'] = number_type
        if pending_numbers is not None:
            params['pending_numbers'] = pending_numbers
        if site_id is not None:
            params['site_id'] = site_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_unassigned_phone_numbers(self, phone_numbers: Optional[List[str]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete unassigned phone numbers

        API: DELETE /phone/numbers

        Args:
            phone_numbers (List[str], required): original param name `phone_numbers`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/numbers"

        params: Dict[str, Any] = {}
        if phone_numbers is not None:
            params['phone_numbers'] = phone_numbers

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_site_for_unassigned_phone_numbers(self, siteId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a site's unassigned phone numbers

        API: PATCH /phone/numbers/sites/{siteId}

        Args:
            siteId (str, required): original param name `siteId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/numbers/sites/{siteId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_phone_number_details(self, phoneNumberId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a phone number

        API: GET /phone/numbers/{phoneNumberId}

        Args:
            phoneNumberId (str, required): original param name `phoneNumberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/numbers/{phoneNumberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_phone_number_details(self, phoneNumberId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a phone number

        API: PATCH /phone/numbers/{phoneNumberId}

        Args:
            phoneNumberId (str, required): original param name `phoneNumberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/numbers/{phoneNumberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assign_phone_number(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign a phone number to a user

        API: POST /phone/users/{userId}/phone_numbers

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/phone_numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def unassign_phone_number(self, userId: str, phoneNumberId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign a phone number

        API: DELETE /phone/users/{userId}/phone_numbers/{phoneNumberId}

        Args:
            userId (str, required): original param name `userId`
            phoneNumberId (str, required): original param name `phoneNumberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/phone_numbers/{phoneNumberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_calling_plans(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List calling plans

        API: GET /phone/calling_plans

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/calling_plans"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_phone_plans(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List plan information

        API: GET /phone/plans

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/plans"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_phone_roles(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List phone roles

        API: GET /phone/roles

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/roles"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def duplicate_phone_role(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Duplicate a phone role

        API: POST /phone/roles

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/roles"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_role_information_1(self, roleId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get role information

        API: GET /phone/roles/{roleId}

        Args:
            roleId (str, required): original param name `roleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/roles/{roleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_phone_role(self, roleId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a phone role

        API: DELETE /phone/roles/{roleId}

        Args:
            roleId (str, required): original param name `roleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/roles/{roleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_phone_role(self, roleId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a phone role

        API: PATCH /phone/roles/{roleId}

        Args:
            roleId (str, required): original param name `roleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/roles/{roleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_role_members(self, roleId: str, in_role: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List members in a role

        API: GET /phone/roles/{roleId}/members

        Args:
            roleId (str, required): original param name `roleId`
            in_role (bool, optional): original param name `in_role`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/roles/{roleId}/members"

        params: Dict[str, Any] = {}
        if in_role is not None:
            params['in_role'] = in_role

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_role_members_1(self, roleId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add members to roles

        API: POST /phone/roles/{roleId}/members

        Args:
            roleId (str, required): original param name `roleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/roles/{roleId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def del_role_members(self, roleId: str, user_ids: Optional[List[str]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete members in a role

        API: DELETE /phone/roles/{roleId}/members

        Args:
            roleId (str, required): original param name `roleId`
            user_ids (List[str], required): original param name `user_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/roles/{roleId}/members"

        params: Dict[str, Any] = {}
        if user_ids is not None:
            params['user_ids'] = user_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_phone_role_targets(
        roleId: str,
        is_default: Optional[bool] = None,
        user_id: Optional[str] = None,
        selected: Optional[bool] = None,
        target_type: Optional[str] = None,
        site_id: Optional[str] = None,
        keyword: Optional[str] = None,
        page_size: Optional[str] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List phone role targets

        API: GET /phone/roles/{roleId}/targets

        Args:
            roleId (str, required): original param name `roleId`
            is_default (bool, optional): original param name `is_default`
            user_id (str, optional): original param name `user_id`
            selected (bool, optional): original param name `selected`
            target_type (str, optional): original param name `target_type`
            site_id (str, optional): original param name `site_id`
            keyword (str, optional): original param name `keyword`
            page_size (str, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/roles/{roleId}/targets"

        params: Dict[str, Any] = {}
        if is_default is not None:
            params['is_default'] = is_default
        if user_id is not None:
            params['user_id'] = user_id
        if selected is not None:
            params['selected'] = selected
        if target_type is not None:
            params['target_type'] = target_type
        if site_id is not None:
            params['site_id'] = site_id
        if keyword is not None:
            params['keyword'] = keyword
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_phone_role_targets(self, roleId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add phone role targets

        API: POST /phone/roles/{roleId}/targets

        Args:
            roleId (str, required): original param name `roleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/roles/{roleId}/targets"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_phone_role_targets(self, roleId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete phone role targets

        API: DELETE /phone/roles/{roleId}/targets

        Args:
            roleId (str, required): original param name `roleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/roles/{roleId}/targets"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_private_directory_members(
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        keyword: Optional[str] = None,
        site_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List private directory members

        API: GET /phone/private_directory/members

        Args:
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`
            keyword (str, optional): original param name `keyword`
            site_id (str, optional): original param name `site_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/private_directory/members"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size
        if keyword is not None:
            params['keyword'] = keyword
        if site_id is not None:
            params['site_id'] = site_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_members_to_a_private_directory(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add members to a private directory

        API: POST /phone/private_directory/members

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/private_directory/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def remove_a_member_from_a_private_directory(self, extensionId: str, site_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove a member from a private directory

        API: DELETE /phone/private_directory/members/{extensionId}

        Args:
            extensionId (str, required): original param name `extensionId`
            site_id (str, optional): original param name `site_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/private_directory/members/{extensionId}"

        params: Dict[str, Any] = {}
        if site_id is not None:
            params['site_id'] = site_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_a_private_directory_member(self, extensionId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a private directory member

        API: PATCH /phone/private_directory/members/{extensionId}

        Args:
            extensionId (str, required): original param name `extensionId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/private_directory/members/{extensionId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_carrier_peering_phone_numbers(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, phone_number: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List carrier peering phone numbers.

        API: GET /phone/carrier_peering/numbers

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            phone_number (str, optional): original param name `phone_number`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/carrier_peering/numbers"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if phone_number is not None:
            params['phone_number'] = phone_number

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_peering_phone_numbers(
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        phone_number: Optional[str] = None,
        carrier_code: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List peering phone numbers

        API: GET /phone/peering/numbers

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            phone_number (str, optional): original param name `phone_number`
            carrier_code (int, optional): original param name `carrier_code`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/peering/numbers"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if phone_number is not None:
            params['phone_number'] = phone_number
        if carrier_code is not None:
            params['carrier_code'] = carrier_code

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_peering_phone_numbers(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add peering phone numbers

        API: POST /phone/peering/numbers

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/peering/numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_peering_phone_numbers(self, carrier_code: Optional[int] = None, phone_numbers: Optional[List[str]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove peering phone numbers

        API: DELETE /phone/peering/numbers

        Args:
            carrier_code (int, optional): original param name `carrier_code`
            phone_numbers (List[str], required): original param name `phone_numbers`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/peering/numbers"

        params: Dict[str, Any] = {}
        if carrier_code is not None:
            params['carrier_code'] = carrier_code
        if phone_numbers is not None:
            params['phone_numbers'] = phone_numbers

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_peering_phone_numbers(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update peering phone numbers

        API: PATCH /phone/peering/numbers

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/peering/numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_account_provision_template(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List provision templates

        API: GET /phone/provision_templates

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/provision_templates"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_provision_template(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a provision template

        API: POST /phone/provision_templates

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/provision_templates"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_provision_template(self, templateId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a provision template

        API: GET /phone/provision_templates/{templateId}

        Args:
            templateId (str, required): original param name `templateId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/provision_templates/{templateId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_provision_template(self, templateId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a provision template

        API: DELETE /phone/provision_templates/{templateId}

        Args:
            templateId (str, required): original param name `templateId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/provision_templates/{templateId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_provision_template(self, templateId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a provision template

        API: PATCH /phone/provision_templates/{templateId}

        Args:
            templateId (str, required): original param name `templateId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/provision_templates/{templateId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_phone_recordings_by_call_id_or_call_log_id(self, id: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get recording by call ID

        API: GET /phone/call_logs/{id}/recordings

        Args:
            id (str, required): original param name `id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/call_logs/{id}/recordings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def phone_download_recording_file(self, fileId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Download a phone recording

        API: GET /phone/recording/download/{fileId}

        Args:
            fileId (str, required): original param name `fileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/recording/download/{fileId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def phone_download_recording_transcript(self, recordingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Download a phone recording transcript

        API: GET /phone/recording_transcript/download/{recordingId}

        Args:
            recordingId (str, required): original param name `recordingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/recording_transcript/download/{recordingId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_phone_recordings(
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        owner_type: Optional[str] = None,
        recording_type: Optional[str] = None,
        site_id: Optional[str] = None,
        query_date_type: Optional[str] = None,
        group_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get call recordings

        API: GET /phone/recordings

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            owner_type (str, optional): original param name `owner_type`
            recording_type (str, optional): original param name `recording_type`
            site_id (str, optional): original param name `site_id`
            query_date_type (str, optional): original param name `query_date_type`
            group_id (str, optional): original param name `group_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/recordings"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if owner_type is not None:
            params['owner_type'] = owner_type
        if recording_type is not None:
            params['recording_type'] = recording_type
        if site_id is not None:
            params['site_id'] = site_id
        if query_date_type is not None:
            params['query_date_type'] = query_date_type
        if group_id is not None:
            params['group_id'] = group_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_call_recording(self, recordingId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a call recording

        API: DELETE /phone/recordings/{recordingId}

        Args:
            recordingId (str, required): original param name `recordingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/recordings/{recordingId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_auto_delete_field(self, recordingId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update auto delete field

        API: PATCH /phone/recordings/{recordingId}

        Args:
            recordingId (str, required): original param name `recordingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/recordings/{recordingId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_recording_status(self, recordingId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update Recording Status

        API: PUT /phone/recordings/{recordingId}/status

        Args:
            recordingId (str, required): original param name `recordingId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/recordings/{recordingId}/status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def phone_user_recordings(
        userId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get user's recordings

        API: GET /phone/users/{userId}/recordings

        Args:
            userId (str, required): original param name `userId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/recordings"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_call_charges_usage_report(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        billing_account_id: Optional[str] = None,
        show_charges_only: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get call charges usage report

        API: GET /phone/reports/call_charges

        Args:
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            billing_account_id (str, optional): original param name `billing_account_id`
            show_charges_only (bool, optional): original param name `show_charges_only`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/reports/call_charges"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if billing_account_id is not None:
            params['billing_account_id'] = billing_account_id
        if show_charges_only is not None:
            params['show_charges_only'] = show_charges_only

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getfaxchargesusagereport(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        fax_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get fax charges usage report

        API: GET /phone/reports/fax_charges

        Args:
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            fax_id (str, optional): original param name `fax_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/reports/fax_charges"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if fax_id is not None:
            params['fax_id'] = fax_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_ps_operation_logs(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        category_type: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get operation logs report

        API: GET /phone/reports/operationlogs

        Args:
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            category_type (str, optional): original param name `category_type`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/reports/operationlogs"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if category_type is not None:
            params['category_type'] = category_type
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_sms_charges_usage_report(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        show_charges_only: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get SMS/MMS charges usage report

        API: GET /phone/reports/sms_charges

        Args:
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            show_charges_only (bool, optional): original param name `show_charges_only`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/reports/sms_charges"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if show_charges_only is not None:
            params['show_charges_only'] = show_charges_only

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_routing_rule(self, site_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List directory backup routing rules

        API: GET /phone/routing_rules

        Args:
            site_id (str, optional): original param name `site_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/routing_rules"

        params: Dict[str, Any] = {}
        if site_id is not None:
            params['site_id'] = site_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_routing_rule(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add directory backup routing rule

        API: POST /phone/routing_rules

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/routing_rules"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_routing_rule(self, routingRuleId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get directory backup routing rule

        API: GET /phone/routing_rules/{routingRuleId}

        Args:
            routingRuleId (str, required): original param name `routingRuleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/routing_rules/{routingRuleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_routing_rule(self, routingRuleId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete directory backup routing rule

        API: DELETE /phone/routing_rules/{routingRuleId}

        Args:
            routingRuleId (str, required): original param name `routingRuleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/routing_rules/{routingRuleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_routing_rule(self, routingRuleId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update directory backup routing rule

        API: PATCH /phone/routing_rules/{routingRuleId}

        Args:
            routingRuleId (str, required): original param name `routingRuleId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/routing_rules/{routingRuleId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def post_sms_message(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Post SMS message

        API: POST /phone/sms/messages

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sms/messages"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def account_sms_session(
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        session_type: Optional[str] = None,
        phone_number: Optional[str] = None,
        filter_type: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get account's SMS sessions

        API: GET /phone/sms/sessions

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            session_type (str, optional): original param name `session_type`
            phone_number (str, optional): original param name `phone_number`
            filter_type (str, optional): original param name `filter_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sms/sessions"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if session_type is not None:
            params['session_type'] = session_type
        if phone_number is not None:
            params['phone_number'] = phone_number
        if filter_type is not None:
            params['filter_type'] = filter_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def sms_session_details(
        sessionId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        sort: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get SMS session details

        API: GET /phone/sms/sessions/{sessionId}

        Args:
            sessionId (str, required): original param name `sessionId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            sort (int, optional): original param name `sort`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sms/sessions/{sessionId}"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if sort is not None:
            params['sort'] = sort

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def sms_by_message_id(self, sessionId: str, messageId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get SMS by message ID

        API: GET /phone/sms/sessions/{sessionId}/messages/{messageId}

        Args:
            sessionId (str, required): original param name `sessionId`
            messageId (str, required): original param name `messageId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sms/sessions/{sessionId}/messages/{messageId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def sms_session_sync(
        sessionId: str,
        sync_type: Optional[str] = None,
        count: Optional[int] = None,
        sync_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Sync SMS by session ID

        API: GET /phone/sms/sessions/{sessionId}/sync

        Args:
            sessionId (str, required): original param name `sessionId`
            sync_type (str, optional): original param name `sync_type`
            count (int, optional): original param name `count`
            sync_token (str, optional): original param name `sync_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sms/sessions/{sessionId}/sync"

        params: Dict[str, Any] = {}
        if sync_type is not None:
            params['sync_type'] = sync_type
        if count is not None:
            params['count'] = count
        if sync_token is not None:
            params['sync_token'] = sync_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_sms_session(
        userId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        session_type: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        phone_number: Optional[str] = None,
        filter_type: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get user's SMS sessions

        API: GET /phone/users/{userId}/sms/sessions

        Args:
            userId (str, required): original param name `userId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            session_type (str, optional): original param name `session_type`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            phone_number (str, optional): original param name `phone_number`
            filter_type (str, optional): original param name `filter_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/sms/sessions"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if session_type is not None:
            params['session_type'] = session_type
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if phone_number is not None:
            params['phone_number'] = phone_number
        if filter_type is not None:
            params['filter_type'] = filter_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_sms_sessions(
        userId: str,
        sync_type: Optional[str] = None,
        sync_token: Optional[str] = None,
        count: Optional[int] = None,
        session_type: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List user's SMS sessions in descending order

        API: GET /phone/users/{userId}/sms/sessions/sync

        Args:
            userId (str, required): original param name `userId`
            sync_type (str, required): original param name `sync_type`
            sync_token (str, optional): original param name `sync_token`
            count (int, optional): original param name `count`
            session_type (str, optional): original param name `session_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/sms/sessions/sync"

        params: Dict[str, Any] = {}
        if sync_type is not None:
            params['sync_type'] = sync_type
        if sync_token is not None:
            params['sync_token'] = sync_token
        if count is not None:
            params['count'] = count
        if session_type is not None:
            params['session_type'] = session_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_account_sms_campaigns(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List SMS campaigns

        API: GET /phone/sms_campaigns

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sms_campaigns"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_sms_campaign(self, smsCampaignId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get an SMS campaign

        API: GET /phone/sms_campaigns/{smsCampaignId}

        Args:
            smsCampaignId (str, required): original param name `smsCampaignId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sms_campaigns/{smsCampaignId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assign_campaign_phone_numbers(self, smsCampaignId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign a phone number to SMS campaign

        API: POST /phone/sms_campaigns/{smsCampaignId}/phone_numbers

        Args:
            smsCampaignId (str, required): original param name `smsCampaignId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sms_campaigns/{smsCampaignId}/phone_numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_number_campaign_opt_status(self, smsCampaignId: str, consumer_phone_number: Optional[str] = None, zoom_phone_user_numbers: Optional[List[str]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List opt statuses of phone numbers assigned to SMS campaign

        API: GET /phone/sms_campaigns/{smsCampaignId}/phone_numbers/opt_status

        Args:
            smsCampaignId (str, required): original param name `smsCampaignId`
            consumer_phone_number (str, required): original param name `consumer_phone_number`
            zoom_phone_user_numbers (List[str], required): original param name `zoom_phone_user_numbers`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sms_campaigns/{smsCampaignId}/phone_numbers/opt_status"

        params: Dict[str, Any] = {}
        if consumer_phone_number is not None:
            params['consumer_phone_number'] = consumer_phone_number
        if zoom_phone_user_numbers is not None:
            params['zoom_phone_user_numbers'] = zoom_phone_user_numbers

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_number_campaign_opt_status(self, smsCampaignId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update opt statuses of phone numbers assigned to SMS campaign

        API: PATCH /phone/sms_campaigns/{smsCampaignId}/phone_numbers/opt_status

        Args:
            smsCampaignId (str, required): original param name `smsCampaignId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sms_campaigns/{smsCampaignId}/phone_numbers/opt_status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def unassign_campaign_phone_number(self, smsCampaignId: str, phoneNumberId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign a phone number

        API: DELETE /phone/sms_campaigns/{smsCampaignId}/phone_numbers/{phoneNumberId}

        Args:
            smsCampaignId (str, required): original param name `smsCampaignId`
            phoneNumberId (str, required): original param name `phoneNumberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sms_campaigns/{smsCampaignId}/phone_numbers/{phoneNumberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_user_number_campaign_opt_status(self, userId: str, consumer_phone_numbers: Optional[List[str]] = None, zoom_phone_user_numbers: Optional[List[str]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List user's opt statuses of phone numbers

        API: GET /phone/user/{userId}/sms_campaigns/phone_numbers/opt_status

        Args:
            userId (str, required): original param name `userId`
            consumer_phone_numbers (List[str], required): original param name `consumer_phone_numbers`
            zoom_phone_user_numbers (List[str], required): original param name `zoom_phone_user_numbers`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/user/{userId}/sms_campaigns/phone_numbers/opt_status"

        params: Dict[str, Any] = {}
        if consumer_phone_numbers is not None:
            params['consumer_phone_numbers'] = consumer_phone_numbers
        if zoom_phone_user_numbers is not None:
            params['zoom_phone_user_numbers'] = zoom_phone_user_numbers

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_setting_templates(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, site_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List setting templates

        API: GET /phone/setting_templates

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            site_id (str, optional): original param name `site_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/setting_templates"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if site_id is not None:
            params['site_id'] = site_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_setting_template(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a setting template

        API: POST /phone/setting_templates

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/setting_templates"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_setting_template(self, templateId: str, custom_query_fields: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get setting template details

        API: GET /phone/setting_templates/{templateId}

        Args:
            templateId (str, required): original param name `templateId`
            custom_query_fields (str, optional): original param name `custom_query_fields`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/setting_templates/{templateId}"

        params: Dict[str, Any] = {}
        if custom_query_fields is not None:
            params['custom_query_fields'] = custom_query_fields

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_setting_template(self, templateId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a setting template

        API: PATCH /phone/setting_templates/{templateId}

        Args:
            templateId (str, required): original param name `templateId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/setting_templates/{templateId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_account_policy_details(self, policyType: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get account policy details

        API: GET /phone/policies/{policyType}

        Args:
            policyType (str, required): original param name `policyType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/policies/{policyType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_account_policy(self, policyType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update account policy

        API: PATCH /phone/policies/{policyType}

        Args:
            policyType (str, required): original param name `policyType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/policies/{policyType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_ported_numbers(self, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List ported numbers

        API: GET /phone/ported_numbers/orders

        Args:
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/ported_numbers/orders"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_ported_numbers_details(self, orderId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get ported number details

        API: GET /phone/ported_numbers/orders/{orderId}

        Args:
            orderId (str, required): original param name `orderId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/ported_numbers/orders/{orderId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def phone_setting(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get phone account settings

        API: GET /phone/settings

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/settings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_phone_settings(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update phone account settings

        API: PATCH /phone/settings

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/settings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_sip_groups(self, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List SIP groups

        API: GET /phone/sip_groups

        Args:
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sip_groups"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_byocsip_trunk(self, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List BYOC SIP trunks

        API: GET /phone/sip_trunk/trunks

        Args:
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sip_trunk/trunks"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_shared_line_appearances(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List shared line appearances

        API: GET /phone/shared_line_appearances

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_appearances"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_shared_line_groups(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List shared line groups

        API: GET /phone/shared_line_groups

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_a_shared_line_group(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a shared line group

        API: POST /phone/shared_line_groups

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_a_shared_line_group(self, sharedLineGroupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a shared line group

        API: GET /phone/shared_line_groups/{sharedLineGroupId}

        Args:
            sharedLineGroupId (str, required): original param name `sharedLineGroupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups/{sharedLineGroupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_shared_line_group_policy(self, sharedLineGroupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a shared line group policy

        API: GET /phone/shared_line_groups/{sharedLineGroupId}/policies

        Args:
            sharedLineGroupId (str, required): original param name `sharedLineGroupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups/{sharedLineGroupId}/policies"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_shared_line_group_policy(self, sharedLineGroupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a shared line group policy

        API: PATCH /phone/shared_line_groups/{sharedLineGroupId}/policies

        Args:
            sharedLineGroupId (str, required): original param name `sharedLineGroupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups/{sharedLineGroupId}/policies"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_a_shared_line_group(self, slgId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a shared line group

        API: DELETE /phone/shared_line_groups/{slgId}

        Args:
            slgId (str, required): original param name `slgId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups/{slgId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_a_shared_line_group(self, slgId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a shared line group

        API: PATCH /phone/shared_line_groups/{slgId}

        Args:
            slgId (str, required): original param name `slgId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups/{slgId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_members_to_shared_line_group(self, slgId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add members to a shared line group

        API: POST /phone/shared_line_groups/{slgId}/members

        Args:
            slgId (str, required): original param name `slgId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups/{slgId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_members_of_slg(self, slgId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign members from a shared line group

        API: DELETE /phone/shared_line_groups/{slgId}/members

        Args:
            slgId (str, required): original param name `slgId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups/{slgId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_a_member_slg(self, slgId: str, memberId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign a member from a shared line group

        API: DELETE /phone/shared_line_groups/{slgId}/members/{memberId}

        Args:
            slgId (str, required): original param name `slgId`
            memberId (str, required): original param name `memberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups/{slgId}/members/{memberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assign_phone_numbers_slg(self, slgId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign phone numbers

        API: POST /phone/shared_line_groups/{slgId}/phone_numbers

        Args:
            slgId (str, required): original param name `slgId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups/{slgId}/phone_numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_phone_numbers_slg(self, slgId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign all phone numbers

        API: DELETE /phone/shared_line_groups/{slgId}/phone_numbers

        Args:
            slgId (str, required): original param name `slgId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups/{slgId}/phone_numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_a_phone_number_slg(self, slgId: str, phoneNumberId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign a phone number

        API: DELETE /phone/shared_line_groups/{slgId}/phone_numbers/{phoneNumberId}

        Args:
            slgId (str, required): original param name `slgId`
            phoneNumberId (str, required): original param name `phoneNumberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups/{slgId}/phone_numbers/{phoneNumberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_slg_policy_sub_setting(self, slgId: str, policyType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a policy setting to a shared line group

        API: POST /phone/shared_line_groups/{slgId}/policies/{policyType}

        Args:
            slgId (str, required): original param name `slgId`
            policyType (str, required): original param name `policyType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups/{slgId}/policies/{policyType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def remove_slg_policy_sub_setting(self, slgId: str, policyType: str, shared_ids: Optional[List[str]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an SLG policy setting

        API: DELETE /phone/shared_line_groups/{slgId}/policies/{policyType}

        Args:
            slgId (str, required): original param name `slgId`
            policyType (str, required): original param name `policyType`
            shared_ids (List[str], required): original param name `shared_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups/{slgId}/policies/{policyType}"

        params: Dict[str, Any] = {}
        if shared_ids is not None:
            params['shared_ids'] = shared_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_slg_policy_sub_setting(self, slgId: str, policyType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an SLG policy setting

        API: PATCH /phone/shared_line_groups/{slgId}/policies/{policyType}

        Args:
            slgId (str, required): original param name `slgId`
            policyType (str, required): original param name `policyType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/shared_line_groups/{slgId}/policies/{policyType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_phone_sites(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List phone sites

        API: GET /phone/sites

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_phone_site(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a phone site

        API: POST /phone/sites

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_a_site(self, siteId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get phone site details

        API: GET /phone/sites/{siteId}

        Args:
            siteId (str, required): original param name `siteId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_phone_site(self, siteId: str, transfer_site_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a phone site

        API: DELETE /phone/sites/{siteId}

        Args:
            siteId (str, required): original param name `siteId`
            transfer_site_id (str, required): original param name `transfer_site_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}"

        params: Dict[str, Any] = {}
        if transfer_site_id is not None:
            params['transfer_site_id'] = transfer_site_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_site_details(self, siteId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update phone site details

        API: PATCH /phone/sites/{siteId}

        Args:
            siteId (str, required): original param name `siteId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_site_customize_outbound_caller_numbers(
        siteId: str,
        selected: Optional[bool] = None,
        site_id: Optional[str] = None,
        extension_type: Optional[str] = None,
        keyword: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List customized outbound caller ID phone numbers

        API: GET /phone/sites/{siteId}/outbound_caller_id/customized_numbers

        Args:
            siteId (str, required): original param name `siteId`
            selected (bool, optional): original param name `selected`
            site_id (str, optional): original param name `site_id`
            extension_type (str, optional): original param name `extension_type`
            keyword (str, optional): original param name `keyword`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/outbound_caller_id/customized_numbers"

        params: Dict[str, Any] = {}
        if selected is not None:
            params['selected'] = selected
        if site_id is not None:
            params['site_id'] = site_id
        if extension_type is not None:
            params['extension_type'] = extension_type
        if keyword is not None:
            params['keyword'] = keyword
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_site_outbound_caller_numbers(self, siteId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add customized outbound caller ID phone numbers

        API: POST /phone/sites/{siteId}/outbound_caller_id/customized_numbers

        Args:
            siteId (str, required): original param name `siteId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/outbound_caller_id/customized_numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_site_outbound_caller_numbers(self, siteId: str, customize_ids: Optional[List[str]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove customized outbound caller ID phone numbers

        API: DELETE /phone/sites/{siteId}/outbound_caller_id/customized_numbers

        Args:
            siteId (str, required): original param name `siteId`
            customize_ids (List[str], optional): original param name `customize_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/outbound_caller_id/customized_numbers"

        params: Dict[str, Any] = {}
        if customize_ids is not None:
            params['customize_ids'] = customize_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_site_setting_for_type(self, siteId: str, settingType: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a phone site setting

        API: GET /phone/sites/{siteId}/settings/{settingType}

        Args:
            siteId (str, required): original param name `siteId`
            settingType (str, required): original param name `settingType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/settings/{settingType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_site_setting(self, siteId: str, settingType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a site setting

        API: POST /phone/sites/{siteId}/settings/{settingType}

        Args:
            siteId (str, required): original param name `siteId`
            settingType (str, required): original param name `settingType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/settings/{settingType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_site_setting(
        siteId: str,
        settingType: str,
        device_type: Optional[str] = None,
        holiday_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete a site setting

        API: DELETE /phone/sites/{siteId}/settings/{settingType}

        Args:
            siteId (str, required): original param name `siteId`
            settingType (str, required): original param name `settingType`
            device_type (str, optional): original param name `device_type`
            holiday_id (str, optional): original param name `holiday_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/settings/{settingType}"

        params: Dict[str, Any] = {}
        if device_type is not None:
            params['device_type'] = device_type
        if holiday_id is not None:
            params['holiday_id'] = holiday_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_site_setting(self, siteId: str, settingType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update the site setting

        API: PATCH /phone/sites/{siteId}/settings/{settingType}

        Args:
            siteId (str, required): original param name `siteId`
            settingType (str, required): original param name `settingType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/sites/{siteId}/settings/{settingType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_phone_users(
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        site_id: Optional[str] = None,
        calling_type: Optional[int] = None,
        status: Optional[str] = None,
        department: Optional[str] = None,
        cost_center: Optional[str] = None,
        keyword: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List phone users

        API: GET /phone/users

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            site_id (str, optional): original param name `site_id`
            calling_type (int, optional): original param name `calling_type`
            status (str, optional): original param name `status`
            department (str, optional): original param name `department`
            cost_center (str, optional): original param name `cost_center`
            keyword (str, optional): original param name `keyword`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if site_id is not None:
            params['site_id'] = site_id
        if calling_type is not None:
            params['calling_type'] = calling_type
        if status is not None:
            params['status'] = status
        if department is not None:
            params['department'] = department
        if cost_center is not None:
            params['cost_center'] = cost_center
        if keyword is not None:
            params['keyword'] = keyword

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_users_properties_in_batch(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update multiple users' properties in batch

        API: PUT /phone/users/batch

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/batch"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def batch_add_users(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Batch add users

        API: POST /phone/users/batch

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/batch"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def phone_user(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a user's profile

        API: GET /phone/users/{userId}

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_user_profile(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a user's profile

        API: PATCH /phone/users/{userId}

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_calling_plan(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update user's calling plan

        API: PUT /phone/users/{userId}/calling_plans

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/calling_plans"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assign_calling_plan(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign calling plan to a user

        API: POST /phone/users/{userId}/calling_plans

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/calling_plans"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def unassign_calling_plan(self, userId: str, planType: str, billing_account_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Unassign user's calling plan

        API: DELETE /phone/users/{userId}/calling_plans/{planType}

        Args:
            userId (str, required): original param name `userId`
            planType (str, required): original param name `planType`
            billing_account_id (str, optional): original param name `billing_account_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/calling_plans/{planType}"

        params: Dict[str, Any] = {}
        if billing_account_id is not None:
            params['billing_account_id'] = billing_account_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_user_customize_outbound_caller_numbers(
        userId: str,
        selected: Optional[bool] = None,
        site_id: Optional[str] = None,
        extension_type: Optional[str] = None,
        keyword: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List users' phone numbers for a customized outbound caller ID

        API: GET /phone/users/{userId}/outbound_caller_id/customized_numbers

        Args:
            userId (str, required): original param name `userId`
            selected (bool, optional): original param name `selected`
            site_id (str, optional): original param name `site_id`
            extension_type (str, optional): original param name `extension_type`
            keyword (str, optional): original param name `keyword`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/outbound_caller_id/customized_numbers"

        params: Dict[str, Any] = {}
        if selected is not None:
            params['selected'] = selected
        if site_id is not None:
            params['site_id'] = site_id
        if extension_type is not None:
            params['extension_type'] = extension_type
        if keyword is not None:
            params['keyword'] = keyword
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_user_outbound_caller_numbers(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add phone numbers for users' customized outbound caller ID

        API: POST /phone/users/{userId}/outbound_caller_id/customized_numbers

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/outbound_caller_id/customized_numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_user_outbound_caller_numbers(self, userId: str, customize_ids: Optional[List[str]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove users' customized outbound caller ID phone numbers

        API: DELETE /phone/users/{userId}/outbound_caller_id/customized_numbers

        Args:
            userId (str, required): original param name `userId`
            customize_ids (List[str], optional): original param name `customize_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/outbound_caller_id/customized_numbers"

        params: Dict[str, Any] = {}
        if customize_ids is not None:
            params['customize_ids'] = customize_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_user_policy_details(self, userId: str, policyType: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get user policy details

        API: GET /phone/users/{userId}/policies/{policyType}

        Args:
            userId (str, required): original param name `userId`
            policyType (str, required): original param name `policyType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/policies/{policyType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_user_policy(self, userId: str, policyType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update user policy

        API: PATCH /phone/users/{userId}/policies/{policyType}

        Args:
            userId (str, required): original param name `userId`
            policyType (str, required): original param name `policyType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/policies/{policyType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def phone_user_settings(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a user's profile settings

        API: GET /phone/users/{userId}/settings

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/settings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_user_settings(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a user's profile settings

        API: PATCH /phone/users/{userId}/settings

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/settings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_user_setting(self, userId: str, settingType: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a user's shared access setting

        API: POST /phone/users/{userId}/settings/{settingType}

        Args:
            userId (str, required): original param name `userId`
            settingType (str, required): original param name `settingType`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/settings/{settingType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_user_setting(
        userId: str,
        settingType: str,
        shared_id: Optional[str] = None,
        assistant_extension_id: Optional[str] = None,
        device_id: Optional[str] = None,
        intercom_extension_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete a user's shared access setting

        API: DELETE /phone/users/{userId}/settings/{settingType}

        Args:
            userId (str, required): original param name `userId`
            settingType (str, required): original param name `settingType`
            shared_id (str, optional): original param name `shared_id`
            assistant_extension_id (str, optional): original param name `assistant_extension_id`
            device_id (str, optional): original param name `device_id`
            intercom_extension_id (str, optional): original param name `intercom_extension_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/settings/{settingType}"

        params: Dict[str, Any] = {}
        if shared_id is not None:
            params['shared_id'] = shared_id
        if assistant_extension_id is not None:
            params['assistant_extension_id'] = assistant_extension_id
        if device_id is not None:
            params['device_id'] = device_id
        if intercom_extension_id is not None:
            params['intercom_extension_id'] = intercom_extension_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_user_setting(self, settingType: str, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a user's shared access setting

        API: PATCH /phone/users/{userId}/settings/{settingType}

        Args:
            settingType (str, required): original param name `settingType`
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/settings/{settingType}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_voicemail_details_by_call_id_or_call_log_id(self, userId: str, id: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get user voicemail details from a call log

        API: GET /phone/users/{userId}/call_logs/{id}/voice_mail

        Args:
            userId (str, required): original param name `userId`
            id (str, required): original param name `id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/call_logs/{id}/voice_mail"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def phone_user_voice_mails(
        userId: str,
        page_size: Optional[int] = None,
        status: Optional[str] = None,
        next_page_token: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        trash: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get user's voicemails

        API: GET /phone/users/{userId}/voice_mails

        Args:
            userId (str, required): original param name `userId`
            page_size (int, optional): original param name `page_size`
            status (str, optional): original param name `status`
            next_page_token (str, optional): original param name `next_page_token`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            trash (bool, optional): original param name `trash`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/users/{userId}/voice_mails"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if status is not None:
            params['status'] = status
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if trash is not None:
            params['trash'] = trash

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def account_voice_mails(
        page_size: Optional[int] = None,
        status: Optional[str] = None,
        site_id: Optional[str] = None,
        owner_type: Optional[str] = None,
        voicemail_type: Optional[str] = None,
        next_page_token: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        trashed: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get account voicemails

        API: GET /phone/voice_mails

        Args:
            page_size (int, optional): original param name `page_size`
            status (str, optional): original param name `status`
            site_id (str, optional): original param name `site_id`
            owner_type (str, optional): original param name `owner_type`
            voicemail_type (str, optional): original param name `voicemail_type`
            next_page_token (str, optional): original param name `next_page_token`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            trashed (bool, optional): original param name `trashed`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/voice_mails"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if status is not None:
            params['status'] = status
        if site_id is not None:
            params['site_id'] = site_id
        if owner_type is not None:
            params['owner_type'] = owner_type
        if voicemail_type is not None:
            params['voicemail_type'] = voicemail_type
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if trashed is not None:
            params['trashed'] = trashed

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def phone_download_voicemail_file(self, fileId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Download a phone voicemail

        API: GET /phone/voice_mails/download/{fileId}

        Args:
            fileId (str, required): original param name `fileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/voice_mails/download/{fileId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_voicemail_details(self, voicemailId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get voicemail details

        API: GET /phone/voice_mails/{voicemailId}

        Args:
            voicemailId (str, required): original param name `voicemailId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/voice_mails/{voicemailId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_voicemail(self, voicemailId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a voicemail

        API: DELETE /phone/voice_mails/{voicemailId}

        Args:
            voicemailId (str, required): original param name `voicemailId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/voice_mails/{voicemailId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_voicemail_read_status(self, voicemailId: str, read_status: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update Voicemail Read Status

        API: PATCH /phone/voice_mails/{voicemailId}

        Args:
            voicemailId (str, required): original param name `voicemailId`
            read_status (str, required): original param name `read_status`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/voice_mails/{voicemailId}"

        params: Dict[str, Any] = {}
        if read_status is not None:
            params['read_status'] = read_status

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_zoom_rooms(
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        site_id: Optional[str] = None,
        calling_type: Optional[int] = None,
        keyword: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List Zoom Rooms under Zoom Phone license

        API: GET /phone/rooms

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            site_id (str, optional): original param name `site_id`
            calling_type (int, optional): original param name `calling_type`
            keyword (str, optional): original param name `keyword`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/rooms"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if site_id is not None:
            params['site_id'] = site_id
        if calling_type is not None:
            params['calling_type'] = calling_type
        if keyword is not None:
            params['keyword'] = keyword

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_zoom_room(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a Zoom Room to a Zoom Phone

        API: POST /phone/rooms

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/rooms"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_unassigned_zoom_rooms(self, keyword: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List Zoom Rooms without Zoom Phone assignment

        API: GET /phone/rooms/unassigned

        Args:
            keyword (str, optional): original param name `keyword`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/rooms/unassigned"

        params: Dict[str, Any] = {}
        if keyword is not None:
            params['keyword'] = keyword

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_zoom_room(self, roomId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a Zoom Room under Zoom Phone license

        API: GET /phone/rooms/{roomId}

        Args:
            roomId (str, required): original param name `roomId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/rooms/{roomId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def remove_zoom_room(self, roomId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove a Zoom Room from a ZP account

        API: DELETE /phone/rooms/{roomId}

        Args:
            roomId (str, required): original param name `roomId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/rooms/{roomId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_zoom_room(self, roomId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a Zoom Room under Zoom Phone license

        API: PATCH /phone/rooms/{roomId}

        Args:
            roomId (str, required): original param name `roomId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/rooms/{roomId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assign_calling_plan_to_room(self, roomId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign calling plans to a Zoom Room

        API: POST /phone/rooms/{roomId}/calling_plans

        Args:
            roomId (str, required): original param name `roomId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/rooms/{roomId}/calling_plans"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def unassign_calling_plan_from_room(self, roomId: str, type_param: int, billing_account_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove a calling plan from a Zoom Room

        API: DELETE /phone/rooms/{roomId}/calling_plans/{type}

        Args:
            roomId (str, required): original param name `roomId`
            type_param (int, required): original param name `type`
            billing_account_id (str, optional): original param name `billing_account_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/rooms/{roomId}/calling_plans/{type_param}"

        params: Dict[str, Any] = {}
        if billing_account_id is not None:
            params['billing_account_id'] = billing_account_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assign_phone_number_to_zoom_room(self, roomId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign phone numbers to a Zoom Room

        API: POST /phone/rooms/{roomId}/phone_numbers

        Args:
            roomId (str, required): original param name `roomId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/rooms/{roomId}/phone_numbers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def unassign_phone_number_from_zoom_room(self, roomId: str, phoneNumberId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove a phone number from a Zoom Room

        API: DELETE /phone/rooms/{roomId}/phone_numbers/{phoneNumberId}

        Args:
            roomId (str, required): original param name `roomId`
            phoneNumberId (str, required): original param name `phoneNumberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/phone/rooms/{roomId}/phone_numbers/{phoneNumberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== QSS =====
    async def dashboard_meeting_participants_qos_summary(self, meetingId: str, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List meeting participants QoS Summary

        API: GET /metrics/meetings/{meetingId}/participants/qos_summary

        Args:
            meetingId (str, required): original param name `meetingId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/meetings/{meetingId}/participants/qos_summary"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def dashboard_webinar_participants_qos_summary(self, webinarId: str, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List webinar participants QoS Summary

        API: GET /metrics/webinars/{webinarId}/participants/qos_summary

        Args:
            webinarId (str, required): original param name `webinarId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/metrics/webinars/{webinarId}/participants/qos_summary"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def session_users_qos_summary(self, sessionId: str, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List session users QoS Summary

        API: GET /videosdk/sessions/{sessionId}/users/qos_summary

        Args:
            sessionId (str, required): original param name `sessionId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/videosdk/sessions/{sessionId}/users/qos_summary"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== Rooms =====
    async def config_zoom_room_controller_apps(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Config Zoom Room Controller Apps

        API: POST /rooms/controller/apps/config

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/controller/apps/config"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def invitation_list(
        invite_location_id: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        data_scope: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get a list of visitors by location

        API: GET /visitor/invitation

        Args:
            invite_location_id (str, optional): original param name `invite_location_id`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            data_scope (str, optional): original param name `data_scope`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/visitor/invitation"

        params: Dict[str, Any] = {}
        if invite_location_id is not None:
            params['invite_location_id'] = invite_location_id
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if data_scope is not None:
            params['data_scope'] = data_scope
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_invitation(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Send an invitation

        API: POST /visitor/invitation

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/visitor/invitation"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_invitation(self, invitationId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Invitation details by invitationID

        API: GET /visitor/invitation/{invitationId}

        Args:
            invitationId (str, required): original param name `invitationId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/visitor/invitation/{invitationId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_invitation(self, invitationId: str, cancel: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an Invitation

        API: DELETE /visitor/invitation/{invitationId}

        Args:
            invitationId (str, required): original param name `invitationId`
            cancel (bool, optional): original param name `cancel`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/visitor/invitation/{invitationId}"

        params: Dict[str, Any] = {}
        if cancel is not None:
            params['cancel'] = cancel

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_invitation(self, invitationId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an invitation

        API: PATCH /visitor/invitation/{invitationId}

        Args:
            invitationId (str, required): original param name `invitationId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/visitor/invitation/{invitationId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def checkin_visitor(self, invitationId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Check in a visitor

        API: POST /visitor/invitation/{invitationId}/checkin

        Args:
            invitationId (str, required): original param name `invitationId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/visitor/invitation/{invitationId}/checkin"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_workspaces(
        location_id: Optional[str] = None,
        workspace_name: Optional[str] = None,
        workspace_type: Optional[str] = None,
        reserve_user: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List workspaces

        API: GET /workspaces

        Args:
            location_id (str, required): original param name `location_id`
            workspace_name (str, optional): original param name `workspace_name`
            workspace_type (str, optional): original param name `workspace_type`
            reserve_user (str, optional): original param name `reserve_user`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces"

        params: Dict[str, Any] = {}
        if location_id is not None:
            params['location_id'] = location_id
        if workspace_name is not None:
            params['workspace_name'] = workspace_name
        if workspace_type is not None:
            params['workspace_type'] = workspace_type
        if reserve_user is not None:
            params['reserve_user'] = reserve_user
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_workspace(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a workspace

        API: POST /workspaces

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getaworkspaceadditionalenhancements(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        reserve_user: Optional[str] = None,
        location_id: Optional[str] = None,
        workspace_type: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List workspace additional information with time range

        API: GET /workspaces/additional_informations

        Args:
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            reserve_user (str, optional): original param name `reserve_user`
            location_id (str, required): original param name `location_id`
            workspace_type (str, optional): original param name `workspace_type`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/additional_informations"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if reserve_user is not None:
            params['reserve_user'] = reserve_user
        if location_id is not None:
            params['location_id'] = location_id
        if workspace_type is not None:
            params['workspace_type'] = workspace_type
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getallworkspaceassets(self, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get all workspace assets

        API: GET /workspaces/assets

        Args:
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/assets"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def adda_workspaceasset(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a workspace asset

        API: POST /workspaces/assets

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/assets"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_workspace_asset(self, assetId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a workspace asset

        API: GET /workspaces/assets/{assetId}

        Args:
            assetId (str, required): original param name `assetId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/assets/{assetId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def deletea_workspaceasset(self, assetId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a workspace asset

        API: DELETE /workspaces/assets/{assetId}

        Args:
            assetId (str, required): original param name `assetId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/assets/{assetId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def patch_workspaceasset(self, assetId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Edit a workspace asset

        API: PATCH /workspaces/assets/{assetId}

        Args:
            assetId (str, required): original param name `assetId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/assets/{assetId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def reservation_event(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Check in/out of a reservation

        API: POST /workspaces/events

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/events"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_or_update_a_workspace_floor_map(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add or Update a Workspace floor map

        API: POST /workspaces/floormap/files

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/floormap/files"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_workspace_settings(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update workspace settings

        API: PATCH /workspaces/settings

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/settings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_hot_desk_usage(self, location_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a location's hot desk usage

        API: GET /workspaces/usage

        Args:
            location_id (str, required): original param name `location_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/usage"

        params: Dict[str, Any] = {}
        if location_id is not None:
            params['location_id'] = location_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_workspace_calendar_free_busy_event(self, userId: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get  Workspace Calendar Free/Busy Event

        API: GET /workspaces/users/{userId}/calendar/settings

        Args:
            userId (str, optional): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/users/{userId}/calendar/settings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def set_calendar_free_busy_event(self, userId: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Set Workspace Calendar Free/Busy Event

        API: POST /workspaces/users/{userId}/calendar/settings

        Args:
            userId (str, optional): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/users/{userId}/calendar/settings"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_list_reservations(self, userId: str, from_param: Optional[str] = None, to: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a user's workspace's reservations

        API: GET /workspaces/users/{userId}/reservations

        Args:
            userId (str, required): original param name `userId`
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/users/{userId}/reservations"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_workspace_floor_map(self, locationId: str, remove_child: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete Workspace floor map

        API: DELETE /workspaces/{locationId}/background

        Args:
            locationId (str, required): original param name `locationId`
            remove_child (bool, optional): original param name `remove_child`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/{locationId}/background"

        params: Dict[str, Any] = {}
        if remove_child is not None:
            params['remove_child'] = remove_child

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_workspace(self, workspaceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a workspace

        API: GET /workspaces/{workspaceId}

        Args:
            workspaceId (str, required): original param name `workspaceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/{workspaceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_workspace(self, workspaceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a workspace

        API: DELETE /workspaces/{workspaceId}

        Args:
            workspaceId (str, required): original param name `workspaceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/{workspaceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_workspace(self, workspaceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a workspace

        API: PATCH /workspaces/{workspaceId}

        Args:
            workspaceId (str, required): original param name `workspaceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/{workspaceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getadeskassignment(self, workspaceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a desk assignment

        API: GET /workspaces/{workspaceId}/assignment

        Args:
            workspaceId (str, required): original param name `workspaceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/{workspaceId}/assignment"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def set_a_desk_assignment(self, workspaceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Set a desk assignment

        API: PUT /workspaces/{workspaceId}/assignment

        Args:
            workspaceId (str, required): original param name `workspaceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/{workspaceId}/assignment"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def deleteadeskassignment(self, workspaceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a desk assignment

        API: DELETE /workspaces/{workspaceId}/assignment

        Args:
            workspaceId (str, required): original param name `workspaceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/{workspaceId}/assignment"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_workspace_qr_code(self, workspaceId: str, type_param: Optional[str] = None, ttl: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a workspace QR code

        API: GET /workspaces/{workspaceId}/qr_code

        Args:
            workspaceId (str, required): original param name `workspaceId`
            type_param (str, optional): original param name `type`
            ttl (int, optional): original param name `ttl`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/{workspaceId}/qr_code"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if ttl is not None:
            params['ttl'] = ttl

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_reservations(
        workspaceId: str,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        user_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get a workspace's reservations

        API: GET /workspaces/{workspaceId}/reservations

        Args:
            workspaceId (str, required): original param name `workspaceId`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            user_id (str, optional): original param name `user_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/{workspaceId}/reservations"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if user_id is not None:
            params['user_id'] = user_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_reservation(self, workspaceId: str, check_in: Optional[bool] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a reservation

        API: POST /workspaces/{workspaceId}/reservations

        Args:
            workspaceId (str, required): original param name `workspaceId`
            check_in (bool, optional): original param name `check_in`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/{workspaceId}/reservations"

        params: Dict[str, Any] = {}
        if check_in is not None:
            params['check_in'] = check_in

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_getaworkspacereservationbyreservation_id(self, workspaceId: str, reservationId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a workspace reservation by reservationId

        API: GET /workspaces/{workspaceId}/reservations/{reservationId}

        Args:
            workspaceId (str, required): original param name `workspaceId`
            reservationId (str, required): original param name `reservationId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/{workspaceId}/reservations/{reservationId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_reservation(self, workspaceId: str, reservationId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a reservation

        API: DELETE /workspaces/{workspaceId}/reservations/{reservationId}

        Args:
            workspaceId (str, required): original param name `workspaceId`
            reservationId (str, required): original param name `reservationId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/{workspaceId}/reservations/{reservationId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_reservation(self, workspaceId: str, reservationId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a reservation

        API: PATCH /workspaces/{workspaceId}/reservations/{reservationId}

        Args:
            workspaceId (str, required): original param name `workspaceId`
            reservationId (str, required): original param name `reservationId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/{workspaceId}/reservations/{reservationId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def listworkspacereservationquestionnaires(self, workspaceId: str, reservationId: str, subject: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List workspace reservation questionnaires

        API: GET /workspaces/{workspaceId}/reservations/{reservationId}/questionnaires

        Args:
            workspaceId (str, required): original param name `workspaceId`
            reservationId (str, required): original param name `reservationId`
            subject (str, required): original param name `subject`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/workspaces/{workspaceId}/reservations/{reservationId}/questionnaires"

        params: Dict[str, Any] = {}
        if subject is not None:
            params['subject'] = subject

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_zoom_rooms_1(
        status: Optional[str] = None,
        tag_ids: Optional[str] = None,
        type_param: Optional[str] = None,
        unassigned_rooms: Optional[bool] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        location_id: Optional[str] = None,
        query_name: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List Zoom Rooms

        API: GET /rooms

        Args:
            status (str, optional): original param name `status`
            tag_ids (str, optional): original param name `tag_ids`
            type_param (str, optional): original param name `type`
            unassigned_rooms (bool, optional): original param name `unassigned_rooms`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            location_id (str, optional): original param name `location_id`
            query_name (str, optional): original param name `query_name`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms"

        params: Dict[str, Any] = {}
        if status is not None:
            params['status'] = status
        if tag_ids is not None:
            params['tag_ids'] = tag_ids
        if type_param is not None:
            params['type'] = type_param
        if unassigned_rooms is not None:
            params['unassigned_rooms'] = unassigned_rooms
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if location_id is not None:
            params['location_id'] = location_id
        if query_name is not None:
            params['query_name'] = query_name

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_a_room(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a Zoom Room

        API: POST /rooms

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_digital_signage_content(
        type_param: Optional[str] = None,
        folder_id: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List digital signage contents

        API: GET /rooms/digital_signage

        Args:
            type_param (str, optional): original param name `type`
            folder_id (str, optional): original param name `folder_id`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/digital_signage"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if folder_id is not None:
            params['folder_id'] = folder_id
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def manage_e911signage(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update E911 digital signage

        API: PATCH /rooms/events

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/events"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def zoom_rooms_controls(self, id: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Use Zoom Room controls

        API: PATCH /rooms/{id}/events

        Args:
            id (str, required): original param name `id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{id}/events"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_zr_settings(self, id: str, setting_type: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Zoom Room settings

        API: GET /rooms/{id}/settings

        Args:
            id (str, required): original param name `id`
            setting_type (str, required): original param name `setting_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{id}/settings"

        params: Dict[str, Any] = {}
        if setting_type is not None:
            params['setting_type'] = setting_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_zr_settings(self, id: str, setting_type: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update Zoom Room settings

        API: PATCH /rooms/{id}/settings

        Args:
            id (str, required): original param name `id`
            setting_type (str, optional): original param name `setting_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{id}/settings"

        params: Dict[str, Any] = {}
        if setting_type is not None:
            params['setting_type'] = setting_type

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_zr_profile(self, roomId: str, regenerate_activation_code: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Zoom Room profile

        API: GET /rooms/{roomId}

        Args:
            roomId (str, required): original param name `roomId`
            regenerate_activation_code (bool, optional): original param name `regenerate_activation_code`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}"

        params: Dict[str, Any] = {}
        if regenerate_activation_code is not None:
            params['regenerate_activation_code'] = regenerate_activation_code

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_a_zoom_room(self, roomId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a Zoom Room

        API: DELETE /rooms/{roomId}

        Args:
            roomId (str, required): original param name `roomId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_room_profile(self, roomId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a Zoom Room profile

        API: PATCH /rooms/{roomId}

        Args:
            roomId (str, required): original param name `roomId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_room_profiles(self, roomId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List device profiles

        API: GET /rooms/{roomId}/device_profiles

        Args:
            roomId (str, required): original param name `roomId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}/device_profiles"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_room_device_profile(self, roomId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a device profile

        API: POST /rooms/{roomId}/device_profiles

        Args:
            roomId (str, required): original param name `roomId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}/device_profiles"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_room_devices(self, roomId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get device information

        API: GET /rooms/{roomId}/device_profiles/devices

        Args:
            roomId (str, required): original param name `roomId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}/device_profiles/devices"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_room_profile(self, roomId: str, deviceProfileId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a device profile

        API: GET /rooms/{roomId}/device_profiles/{deviceProfileId}

        Args:
            roomId (str, required): original param name `roomId`
            deviceProfileId (str, required): original param name `deviceProfileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}/device_profiles/{deviceProfileId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_room_profile(self, roomId: str, deviceProfileId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a device profile

        API: DELETE /rooms/{roomId}/device_profiles/{deviceProfileId}

        Args:
            roomId (str, required): original param name `roomId`
            deviceProfileId (str, required): original param name `deviceProfileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}/device_profiles/{deviceProfileId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_device_profile(self, roomId: str, deviceProfileId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a device profile

        API: PATCH /rooms/{roomId}/device_profiles/{deviceProfileId}

        Args:
            roomId (str, required): original param name `roomId`
            deviceProfileId (str, required): original param name `deviceProfileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}/device_profiles/{deviceProfileId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_zr_devices(self, roomId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List Zoom Room devices

        API: GET /rooms/{roomId}/devices

        Args:
            roomId (str, required): original param name `roomId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}/devices"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def change_zr_location(self, roomId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Change a Zoom Room's location

        API: PUT /rooms/{roomId}/location

        Args:
            roomId (str, required): original param name `roomId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}/location"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_zr_sensor_data(
        roomId: str,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        device_id: Optional[str] = None,
        sensor_type: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get Zoom Room sensor data

        API: GET /rooms/{roomId}/sensor_data

        Args:
            roomId (str, required): original param name `roomId`
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            device_id (str, optional): original param name `device_id`
            sensor_type (str, optional): original param name `sensor_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}/sensor_data"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if device_id is not None:
            params['device_id'] = device_id
        if sensor_type is not None:
            params['sensor_type'] = sensor_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_webzrc_url(self, roomId: str, pre_authenticated_link: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Zoom Rooms virtual controller URL

        API: GET /rooms/{roomId}/virtual_controller

        Args:
            roomId (str, required): original param name `roomId`
            pre_authenticated_link (bool, optional): original param name `pre_authenticated_link`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}/virtual_controller"

        params: Dict[str, Any] = {}
        if pre_authenticated_link is not None:
            params['pre_authenticated_link'] = pre_authenticated_link

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_zr_account_profile(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Zoom Room account profile

        API: GET /rooms/account_profile

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/account_profile"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_zr_acc_profile(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update Zoom Room account profile

        API: PATCH /rooms/account_profile

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/account_profile"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_zr_account_settings(self, setting_type: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Zoom Room account settings

        API: GET /rooms/account_settings

        Args:
            setting_type (str, required): original param name `setting_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/account_settings"

        params: Dict[str, Any] = {}
        if setting_type is not None:
            params['setting_type'] = setting_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_zoom_room_acc_settings(self, setting_type: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update Zoom Room account settings

        API: PATCH /rooms/account_settings

        Args:
            setting_type (str, required): original param name `setting_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/account_settings"

        params: Dict[str, Any] = {}
        if setting_type is not None:
            params['setting_type'] = setting_type

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_calendar_services(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List calendar services

        API: GET /rooms/calendar/services

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/calendar/services"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_a_calendar_service(self, serviceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a calendar service

        API: DELETE /rooms/calendar/services/{serviceId}

        Args:
            serviceId (str, required): original param name `serviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/calendar/services/{serviceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_calendar_resources_by_service_id(self, serviceId: str, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List calendar resources by calendar service

        API: GET /rooms/calendar/services/{serviceId}/resources

        Args:
            serviceId (str, required): original param name `serviceId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/calendar/services/{serviceId}/resources"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_a_calendar_resource_to_calendar_service(self, serviceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a calendar resource to a calendar service

        API: POST /rooms/calendar/services/{serviceId}/resources

        Args:
            serviceId (str, required): original param name `serviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/calendar/services/{serviceId}/resources"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_calendar_resource_by_id(self, serviceId: str, resourceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a calendar resource by ID

        API: GET /rooms/calendar/services/{serviceId}/resources/{resourceId}

        Args:
            serviceId (str, required): original param name `serviceId`
            resourceId (str, required): original param name `resourceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/calendar/services/{serviceId}/resources/{resourceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_a_calendar_resource(self, serviceId: str, resourceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a calendar resource

        API: DELETE /rooms/calendar/services/{serviceId}/resources/{resourceId}

        Args:
            serviceId (str, required): original param name `serviceId`
            resourceId (str, required): original param name `resourceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/calendar/services/{serviceId}/resources/{resourceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def sync_a_calendar_service(self, serviceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Start calendar service sync process

        API: PUT /rooms/calendar/services/{serviceId}/sync

        Args:
            serviceId (str, required): original param name `serviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/calendar/services/{serviceId}/sync"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_zoom_roomsbackgroundimagelibrarycontents(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, folder_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List Zoom Rooms background image library contents

        API: GET /rooms/content/background/contents

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            folder_id (str, optional): original param name `folder_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/background/contents"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if folder_id is not None:
            params['folder_id'] = folder_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_zoom_rooms_background_image_library_content(self, contentId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Zoom Rooms background image library content

        API: GET /rooms/content/background/contents/{contentId}

        Args:
            contentId (str, required): original param name `contentId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/background/contents/{contentId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_zoom_rooms_background_image_library_content(self, contentId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete Zoom Rooms Background Image Library Content

        API: DELETE /rooms/content/background/contents/{contentId}

        Args:
            contentId (str, required): original param name `contentId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/background/contents/{contentId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_default_zoom_rooms_background_image_librarycontents(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List default Zoom Rooms background image library contents

        API: GET /rooms/content/background/defaults

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/background/defaults"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_zoom_rooms_background_library_folders(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List Zoom Rooms Background Image Library Folders

        API: GET /rooms/content/background/folders

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/background/folders"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_zoom_rooms_background_library_folder(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add Zoom Rooms Background Image Library Folder

        API: POST /rooms/content/background/folders

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/background/folders"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_zoom_rooms_background_library_folder(self, folderId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Zoom Rooms Background Image Library Folder

        API: GET /rooms/content/background/folders/{folderId}

        Args:
            folderId (str, required): original param name `folderId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/background/folders/{folderId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_zoom_rooms_background_library_folder(self, folderId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete Zoom Rooms Background Image Library Folder

        API: DELETE /rooms/content/background/folders/{folderId}

        Args:
            folderId (str, required): original param name `folderId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/background/folders/{folderId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def updatea_zoom_rooms_background_library_folder_name(self, folderId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update Zoom Rooms Background Image Library Folder

        API: PATCH /rooms/content/background/folders/{folderId}

        Args:
            folderId (str, required): original param name `folderId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/background/folders/{folderId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_listdigitalsignagecontentitems(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List Digital Signage content items

        API: GET /rooms/content/digital_signage/contents

        Args:
            page_size (int, required): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/contents"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def addadigitalsignage_url(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a digital signage URL

        API: POST /rooms/content/digital_signage/contents

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/contents"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getdigitalsignagecontentitem(self, contentId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Digital Signage content item

        API: GET /rooms/content/digital_signage/contents/{contentId}

        Args:
            contentId (str, required): original param name `contentId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/contents/{contentId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def deleteadigitalsignagecontentitem(self, contentId: str, remove_from_library_only: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a Digital Signage content item

        API: DELETE /rooms/content/digital_signage/contents/{contentId}

        Args:
            contentId (str, required): original param name `contentId`
            remove_from_library_only (bool, optional): original param name `remove_from_library_only`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/contents/{contentId}"

        params: Dict[str, Any] = {}
        if remove_from_library_only is not None:
            params['remove_from_library_only'] = remove_from_library_only

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def updateadigitalsignagecontentitemattributes(self, contentId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a Digital Signage content item attributes

        API: PATCH /rooms/content/digital_signage/contents/{contentId}

        Args:
            contentId (str, required): original param name `contentId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/contents/{contentId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def addadigitalsignagecontentfolder(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a digital signage content folder

        API: POST /rooms/content/digital_signage/folders

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/folders"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getdigitalsignagecontentfolderdetails(self, folderId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Digital Signage content folder

        API: GET /rooms/content/digital_signage/folders/{folderId}

        Args:
            folderId (str, required): original param name `folderId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/folders/{folderId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def deleteadigitalsignagecontentfolder(self, folderId: str, remove_from_library_only: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a Digital Signage content folder

        API: DELETE /rooms/content/digital_signage/folders/{folderId}

        Args:
            folderId (str, required): original param name `folderId`
            remove_from_library_only (bool, optional): original param name `remove_from_library_only`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/folders/{folderId}"

        params: Dict[str, Any] = {}
        if remove_from_library_only is not None:
            params['remove_from_library_only'] = remove_from_library_only

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def updateadigitalsignagecontentfolder(self, folderId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a digital signage content folder

        API: PATCH /rooms/content/digital_signage/folders/{folderId}

        Args:
            folderId (str, required): original param name `folderId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/folders/{folderId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_digital_signagelibraryplaylists(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List Digital Signage library playlists

        API: GET /rooms/content/digital_signage/playlists

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/playlists"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def adda_digital_signagelibraryplaylist(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a Digital Signage library playlist

        API: POST /rooms/content/digital_signage/playlists

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/playlists"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_digital_signagelibraryplaylist(self, playlistId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Digital Signage library playlist

        API: GET /rooms/content/digital_signage/playlists/{playlistId}

        Args:
            playlistId (str, required): original param name `playlistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/playlists/{playlistId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_digital_signagelibraryplaylist(self, playlistId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete Digital Signage library playlist

        API: DELETE /rooms/content/digital_signage/playlists/{playlistId}

        Args:
            playlistId (str, required): original param name `playlistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/playlists/{playlistId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def updatea_digital_signagelibraryplaylist(self, playlistId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a Digital Signage library playlist

        API: PATCH /rooms/content/digital_signage/playlists/{playlistId}

        Args:
            playlistId (str, required): original param name `playlistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/playlists/{playlistId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_digital_signagelibraryplaylistcontentitems(self, playlistId: str, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Digital Signage library playlist content items

        API: GET /rooms/content/digital_signage/playlists/{playlistId}/contents

        Args:
            playlistId (str, required): original param name `playlistId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/playlists/{playlistId}/contents"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_digital_signagelibraryplaylistcontentitems(self, playlistId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update Digital Signage library playlist content items

        API: PUT /rooms/content/digital_signage/playlists/{playlistId}/contents

        Args:
            playlistId (str, required): original param name `playlistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/playlists/{playlistId}/contents"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_digital_signagelibraryplaylistpublishedrooms(self, playlistId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List Digital Signage library playlist published rooms

        API: GET /rooms/content/digital_signage/playlists/{playlistId}/rooms

        Args:
            playlistId (str, required): original param name `playlistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/playlists/{playlistId}/rooms"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_digital_signagelibraryplaylistpublishedrooms(self, playlistId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update Digital Signage library playlist published rooms

        API: PUT /rooms/content/digital_signage/playlists/{playlistId}/rooms

        Args:
            playlistId (str, required): original param name `playlistId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/content/digital_signage/playlists/{playlistId}/rooms"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_zoom_rooms_background_image_library_content(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update Zoom Rooms background image library content

        API: PUT /zrbackground/files

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/zrbackground/files"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_zoom_rooms_background_image_library_content(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add Zoom Rooms background image library content

        API: POST /zrbackground/files

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/zrbackground/files"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def updateadigitalsignageimageorvideofile(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a Digital Signage image or video file

        API: PUT /zrdigitalsignage/files

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/zrdigitalsignage/files"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def adddigitalsignageimageorvideo(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a digital signage image or video

        API: POST /zrdigitalsignage/files

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/zrdigitalsignage/files"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_device_1(self, roomId: str, deviceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a Zoom Room user device

        API: DELETE /rooms/{roomId}/devices/{deviceId}

        Args:
            roomId (str, required): original param name `roomId`
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}/devices/{deviceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def change_zoom_rooms_app_version(self, roomId: str, deviceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Change Zoom Rooms app version

        API: PUT /rooms/{roomId}/devices/{deviceId}/app_version

        Args:
            roomId (str, required): original param name `roomId`
            deviceId (str, required): original param name `deviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}/devices/{deviceId}/app_version"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_zr_locations(
        parent_location_id: Optional[str] = None,
        type_param: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List Zoom Room locations

        API: GET /rooms/locations

        Args:
            parent_location_id (str, optional): original param name `parent_location_id`
            type_param (str, optional): original param name `type`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/locations"

        params: Dict[str, Any] = {}
        if parent_location_id is not None:
            params['parent_location_id'] = parent_location_id
        if type_param is not None:
            params['type'] = type_param
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_azr_location(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a location

        API: POST /rooms/locations

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/locations"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_zr_location_structure(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Zoom Room location structure

        API: GET /rooms/locations/structure

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/locations/structure"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_zoom_rooms_location_structure(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update Zoom Rooms location structure

        API: PUT /rooms/locations/structure

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/locations/structure"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_zr_location_profile(self, locationId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get Zoom Room location profile

        API: GET /rooms/locations/{locationId}

        Args:
            locationId (str, required): original param name `locationId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/locations/{locationId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_azr_location(self, locationId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a location

        API: DELETE /rooms/locations/{locationId}

        Args:
            locationId (str, required): original param name `locationId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/locations/{locationId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_zr_location_profile(self, locationId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update Zoom Room location profile

        API: PATCH /rooms/locations/{locationId}

        Args:
            locationId (str, required): original param name `locationId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/locations/{locationId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def change_parent_location(self, locationId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Change the assigned parent location

        API: PUT /rooms/locations/{locationId}/location

        Args:
            locationId (str, required): original param name `locationId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/locations/{locationId}/location"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_zr_location_settings(self, locationId: str, setting_type: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get location settings

        API: GET /rooms/locations/{locationId}/settings

        Args:
            locationId (str, required): original param name `locationId`
            setting_type (str, required): original param name `setting_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/locations/{locationId}/settings"

        params: Dict[str, Any] = {}
        if setting_type is not None:
            params['setting_type'] = setting_type

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_zr_location_settings(self, locationId: str, setting_type: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update location settings

        API: PATCH /rooms/locations/{locationId}/settings

        Args:
            locationId (str, required): original param name `locationId`
            setting_type (str, required): original param name `setting_type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/locations/{locationId}/settings"

        params: Dict[str, Any] = {}
        if setting_type is not None:
            params['setting_type'] = setting_type

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assign_tags_to_zoom_rooms_by_location_id(self, locationId: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign Tags to Zoom Rooms By Location ID

        API: PATCH /rooms/locations/{locationId}/tags

        Args:
            locationId (str, optional): original param name `locationId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/locations/{locationId}/tags"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_zoom_room_tags(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List all Zoom Room Tags

        API: GET /rooms/tags

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, required): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/tags"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_zoom_room_tag(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a new Zoom Rooms Tag

        API: POST /rooms/tags

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/tags"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_zoom_room_tag(self, tagId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete Tag

        API: DELETE /rooms/tags/{tagId}

        Args:
            tagId (str, required): original param name `tagId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/tags/{tagId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def edit_zoom_room_tag(self, tagId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Edit Tag

        API: PATCH /rooms/tags/{tagId}

        Args:
            tagId (str, required): original param name `tagId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/tags/{tagId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def unassign_zoom_room_tag(self, roomId: str, tag_ids: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Un-assign Tags from a Zoom Room

        API: DELETE /rooms/{roomId}/tags

        Args:
            roomId (str, required): original param name `roomId`
            tag_ids (str, required): original param name `tag_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}/tags"

        params: Dict[str, Any] = {}
        if tag_ids is not None:
            params['tag_ids'] = tag_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assign_tags_to_a_zoom_room(self, roomId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign Tags to a Zoom Room

        API: PATCH /rooms/{roomId}/tags

        Args:
            roomId (str, required): original param name `roomId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/rooms/{roomId}/tags"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== Scheduler =====
    async def getroutingresponse(self, formId: str, responseId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        get routing response

        API: GET /scheduler/routing/forms/{formId}/response/{responseId}

        Args:
            formId (str, required): original param name `formId`
            responseId (str, required): original param name `responseId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/routing/forms/{formId}/response/{responseId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_analytics(
        to: Optional[str] = None,
        from_param: Optional[str] = None,
        time_zone: Optional[str] = None,
        user_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Report analytics

        API: GET /scheduler/analytics

        Args:
            to (str, optional): original param name `to`
            from_param (str, optional): original param name `from`
            time_zone (str, optional): original param name `time_zone`
            user_id (str, optional): original param name `user_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/analytics"

        params: Dict[str, Any] = {}
        if to is not None:
            params['to'] = to
        if from_param is not None:
            params['from'] = from_param
        if time_zone is not None:
            params['time_zone'] = time_zone
        if user_id is not None:
            params['user_id'] = user_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_availability(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, user_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List availability

        API: GET /scheduler/availability

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            user_id (str, optional): original param name `user_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/availability"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if user_id is not None:
            params['user_id'] = user_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def insert_availability(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Insert availability

        API: POST /scheduler/availability

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/availability"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_availability(self, availabilityId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get availability

        API: GET /scheduler/availability/{availabilityId}

        Args:
            availabilityId (str, required): original param name `availabilityId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/availability/{availabilityId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_availability(self, availabilityId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete availability

        API: DELETE /scheduler/availability/{availabilityId}

        Args:
            availabilityId (str, required): original param name `availabilityId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/availability/{availabilityId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def patch_availability(self, availabilityId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Patch availability

        API: PATCH /scheduler/availability/{availabilityId}

        Args:
            availabilityId (str, required): original param name `availabilityId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/availability/{availabilityId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_scheduled_events(
        to: Optional[str] = None,
        from_param: Optional[str] = None,
        page_size: Optional[int] = None,
        order_by: Optional[str] = None,
        time_zone: Optional[str] = None,
        next_page_token: Optional[str] = None,
        show_deleted: Optional[bool] = None,
        event_type: Optional[str] = None,
        user_id: Optional[str] = None,
        search: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List scheduled events

        API: GET /scheduler/events

        Args:
            to (str, optional): original param name `to`
            from_param (str, optional): original param name `from`
            page_size (int, optional): original param name `page_size`
            order_by (str, optional): original param name `order_by`
            time_zone (str, optional): original param name `time_zone`
            next_page_token (str, optional): original param name `next_page_token`
            show_deleted (bool, optional): original param name `show_deleted`
            event_type (str, optional): original param name `event_type`
            user_id (str, optional): original param name `user_id`
            search (str, optional): original param name `search`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/events"

        params: Dict[str, Any] = {}
        if to is not None:
            params['to'] = to
        if from_param is not None:
            params['from'] = from_param
        if page_size is not None:
            params['page_size'] = page_size
        if order_by is not None:
            params['order_by'] = order_by
        if time_zone is not None:
            params['time_zone'] = time_zone
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if show_deleted is not None:
            params['show_deleted'] = show_deleted
        if event_type is not None:
            params['event_type'] = event_type
        if user_id is not None:
            params['user_id'] = user_id
        if search is not None:
            params['search'] = search

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_scheduled_events(self, eventId: str, user_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get scheduled events

        API: GET /scheduler/events/{eventId}

        Args:
            eventId (str, required): original param name `eventId`
            user_id (str, optional): original param name `user_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/events/{eventId}"

        params: Dict[str, Any] = {}
        if user_id is not None:
            params['user_id'] = user_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_scheduled_events(self, eventId: str, user_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete scheduled events

        API: DELETE /scheduler/events/{eventId}

        Args:
            eventId (str, required): original param name `eventId`
            user_id (str, optional): original param name `user_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/events/{eventId}"

        params: Dict[str, Any] = {}
        if user_id is not None:
            params['user_id'] = user_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def patch_scheduled_events(self, eventId: str, user_id: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Patch scheduled events

        API: PATCH /scheduler/events/{eventId}

        Args:
            eventId (str, required): original param name `eventId`
            user_id (str, optional): original param name `user_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/events/{eventId}"

        params: Dict[str, Any] = {}
        if user_id is not None:
            params['user_id'] = user_id

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_scheduled_event_attendee(self, eventId: str, attendeeId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get scheduled event attendee

        API: GET /scheduler/events/{eventId}/attendees/{attendeeId}

        Args:
            eventId (str, required): original param name `eventId`
            attendeeId (str, required): original param name `attendeeId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/events/{eventId}/attendees/{attendeeId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_schedules(
        to: Optional[str] = None,
        from_param: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        show_deleted: Optional[bool] = None,
        time_zone: Optional[str] = None,
        user_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List schedules

        API: GET /scheduler/schedules

        Args:
            to (str, optional): original param name `to`
            from_param (str, optional): original param name `from`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            show_deleted (bool, optional): original param name `show_deleted`
            time_zone (str, optional): original param name `time_zone`
            user_id (str, optional): original param name `user_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/schedules"

        params: Dict[str, Any] = {}
        if to is not None:
            params['to'] = to
        if from_param is not None:
            params['from'] = from_param
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if show_deleted is not None:
            params['show_deleted'] = show_deleted
        if time_zone is not None:
            params['time_zone'] = time_zone
        if user_id is not None:
            params['user_id'] = user_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def insert_schedule(self, user_id: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Insert schedules

        API: POST /scheduler/schedules

        Args:
            user_id (str, optional): original param name `user_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/schedules"

        params: Dict[str, Any] = {}
        if user_id is not None:
            params['user_id'] = user_id

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_schedule(self, scheduleId: str, user_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get schedules

        API: GET /scheduler/schedules/{scheduleId}

        Args:
            scheduleId (str, required): original param name `scheduleId`
            user_id (str, optional): original param name `user_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/schedules/{scheduleId}"

        params: Dict[str, Any] = {}
        if user_id is not None:
            params['user_id'] = user_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_schedules(self, scheduleId: str, user_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete schedules

        API: DELETE /scheduler/schedules/{scheduleId}

        Args:
            scheduleId (str, required): original param name `scheduleId`
            user_id (str, optional): original param name `user_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/schedules/{scheduleId}"

        params: Dict[str, Any] = {}
        if user_id is not None:
            params['user_id'] = user_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def patch_schedule(self, scheduleId: str, user_id: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Patch schedules

        API: PATCH /scheduler/schedules/{scheduleId}

        Args:
            scheduleId (str, required): original param name `scheduleId`
            user_id (str, optional): original param name `user_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/schedules/{scheduleId}"

        params: Dict[str, Any] = {}
        if user_id is not None:
            params['user_id'] = user_id

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def single_use_link(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Single use link

        API: POST /scheduler/schedules/single_use_link

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/schedules/single_use_link"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_shares(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create shares

        API: POST /scheduler/shares

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/shares"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_user(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get user

        API: GET /scheduler/users/{userId}

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scheduler/users/{userId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== SCIM2 =====
    async def group_scim2_list(self, startIndex: Optional[int] = None, count: Optional[int] = None, filter: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List groups

        API: GET /scim2/Groups

        Args:
            startIndex (int, optional): original param name `startIndex`
            count (int, optional): original param name `count`
            filter (str, optional): original param name `filter`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scim2/Groups"

        params: Dict[str, Any] = {}
        if startIndex is not None:
            params['startIndex'] = startIndex
        if count is not None:
            params['count'] = count
        if filter is not None:
            params['filter'] = filter

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_scim2_create(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a group

        API: POST /scim2/Groups

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scim2/Groups"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_scim2_get(self, groupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a group

        API: GET /scim2/Groups/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scim2/Groups/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_scim2_delete(self, groupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a group

        API: DELETE /scim2/Groups/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scim2/Groups/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_scim2_update(self, groupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a group

        API: PATCH /scim2/Groups/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scim2/Groups/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_scim2_list(self, startIndex: Optional[int] = None, count: Optional[int] = None, filter: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List users

        API: GET /scim2/Users

        Args:
            startIndex (int, optional): original param name `startIndex`
            count (int, optional): original param name `count`
            filter (str, optional): original param name `filter`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scim2/Users"

        params: Dict[str, Any] = {}
        if startIndex is not None:
            params['startIndex'] = startIndex
        if count is not None:
            params['count'] = count
        if filter is not None:
            params['filter'] = filter

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_scim2_create(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a user

        API: POST /scim2/Users

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scim2/Users"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_scim2_get(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a user

        API: GET /scim2/Users/{userId}

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scim2/Users/{userId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_scim2_update(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a user

        API: PUT /scim2/Users/{userId}

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scim2/Users/{userId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_scim2_delete(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a user

        API: DELETE /scim2/Users/{userId}

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scim2/Users/{userId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_adscim2_deactivate(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Deactivate a user

        API: PATCH /scim2/Users/{userId}

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/scim2/Users/{userId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== Team Chat =====
    async def get_channel_mention_group(self, channelId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List channel mention groups

        API: GET /chat/channels/{channelId}/mention_group

        Args:
            channelId (str, required): original param name `channelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/mention_group"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_channel_mention_group(self, channelId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a channel mention group

        API: POST /chat/channels/{channelId}/mention_group

        Args:
            channelId (str, required): original param name `channelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/mention_group"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_a_channel_mention_group(self, channelId: str, mentionGroupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a channel mention group

        API: DELETE /chat/channels/{channelId}/mention_group/{mentionGroupId}

        Args:
            channelId (str, required): original param name `channelId`
            mentionGroupId (str, required): original param name `mentionGroupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/mention_group/{mentionGroupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_channel_mention_group(self, channelId: str, mentionGroupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a channel mention group information

        API: PATCH /chat/channels/{channelId}/mention_group/{mentionGroupId}

        Args:
            channelId (str, required): original param name `channelId`
            mentionGroupId (str, required): original param name `mentionGroupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/mention_group/{mentionGroupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_the_members_of_mention_group(
        channelId: str,
        mentionGroupId: str,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List the members of a mention group

        API: GET /chat/channels/{channelId}/mention_group/{mentionGroupId}/members

        Args:
            channelId (str, required): original param name `channelId`
            mentionGroupId (str, required): original param name `mentionGroupId`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/mention_group/{mentionGroupId}/members"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_a_channel_members_to_mention_group(self, channelId: str, mentionGroupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add channel members to a mention group

        API: POST /chat/channels/{channelId}/mention_group/{mentionGroupId}/members

        Args:
            channelId (str, required): original param name `channelId`
            mentionGroupId (str, required): original param name `mentionGroupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/mention_group/{mentionGroupId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def remove_channel_mention_group_members(self, channelId: str, mentionGroupId: str, identifiers: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove channel mention group members

        API: DELETE /chat/channels/{channelId}/mention_group/{mentionGroupId}/members

        Args:
            channelId (str, required): original param name `channelId`
            mentionGroupId (str, required): original param name `mentionGroupId`
            identifiers (str, required): original param name `identifiers`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/mention_group/{mentionGroupId}/members"

        params: Dict[str, Any] = {}
        if identifiers is not None:
            params['identifiers'] = identifiers

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_all_channel_activity_logs(
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        activity_type: Optional[str] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        channel_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List channel activity logs

        API: GET /chat/activities/channels

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            activity_type (str, optional): original param name `activity_type`
            start_date (str, required): original param name `start_date`
            end_date (str, required): original param name `end_date`
            channel_id (str, optional): original param name `channel_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/activities/channels"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if activity_type is not None:
            params['activity_type'] = activity_type
        if start_date is not None:
            params['start_date'] = start_date
        if end_date is not None:
            params['end_date'] = end_date
        if channel_id is not None:
            params['channel_id'] = channel_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def perform_operations_on_channels(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Perform operations on channels

        API: PATCH /chat/channels/events

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/events"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_user_level_channel(self, channelId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a channel

        API: GET /chat/channels/{channelId}

        Args:
            channelId (str, required): original param name `channelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_user_level_channel(self, channelId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a channel

        API: DELETE /chat/channels/{channelId}

        Args:
            channelId (str, required): original param name `channelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_user_level_channel(self, channelId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a channel

        API: PATCH /chat/channels/{channelId}

        Args:
            channelId (str, required): original param name `channelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_user_level_channel_members(self, channelId: str, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List channel members

        API: GET /chat/channels/{channelId}/members

        Args:
            channelId (str, required): original param name `channelId`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/members"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def invite_user_level_channel_members(self, channelId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Invite channel members

        API: POST /chat/channels/{channelId}/members

        Args:
            channelId (str, required): original param name `channelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def batch_remove_channel_members(self, channelId: str, member_ids: Optional[str] = None, user_ids: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Batch remove members from a channel

        API: DELETE /chat/channels/{channelId}/members

        Args:
            channelId (str, required): original param name `channelId`
            member_ids (str, required): original param name `member_ids`
            user_ids (str, required): original param name `user_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/members"

        params: Dict[str, Any] = {}
        if member_ids is not None:
            params['member_ids'] = member_ids
        if user_ids is not None:
            params['user_ids'] = user_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_channel_members_groups(self, channelId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List channel members (Groups)

        API: GET /chat/channels/{channelId}/members/groups

        Args:
            channelId (str, required): original param name `channelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/members/groups"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def invite_channel_members_groups(self, channelId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Invite channel members (Groups)

        API: POST /chat/channels/{channelId}/members/groups

        Args:
            channelId (str, required): original param name `channelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/members/groups"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def remove_a_member_group(self, channelId: str, groupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove a member (group)

        API: DELETE /chat/channels/{channelId}/members/groups/{groupId}

        Args:
            channelId (str, required): original param name `channelId`
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/members/groups/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def join_channel(self, channelId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Join a channel

        API: POST /chat/channels/{channelId}/members/me

        Args:
            channelId (str, required): original param name `channelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/members/me"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def leave_channel(self, channelId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Leave a channel

        API: DELETE /chat/channels/{channelId}/members/me

        Args:
            channelId (str, required): original param name `channelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/members/me"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def remove_a_user_level_channel_member(self, channelId: str, identifier: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove a member

        API: DELETE /chat/channels/{channelId}/members/{identifier}

        Args:
            channelId (str, required): original param name `channelId`
            identifier (str, required): original param name `identifier`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/members/{identifier}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_channels(self, userId: str, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List user's channels

        API: GET /chat/users/{userId}/channels

        Args:
            userId (str, required): original param name `userId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/channels"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_channel(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a channel

        API: POST /chat/users/{userId}/channels

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/channels"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def batch_delete_channels_account_level(self, userId: str, channel_ids: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Batch delete channels

        API: DELETE /chat/users/{userId}/channels

        Args:
            userId (str, required): original param name `userId`
            channel_ids (str, required): original param name `channel_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/channels"

        params: Dict[str, Any] = {}
        if channel_ids is not None:
            params['channel_ids'] = channel_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_account_channels(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List account's public channels

        API: GET /chat/channels

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def search_channels(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Search user's or account's channels

        API: POST /chat/channels/search

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/search"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_channel_activity_logs(
        channelId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        activity_type: Optional[str] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List channel activity logs

        API: GET /chat/channels/{channelId}/activities

        Args:
            channelId (str, required): original param name `channelId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            activity_type (str, optional): original param name `activity_type`
            start_date (str, required): original param name `start_date`
            end_date (str, required): original param name `end_date`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/activities"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if activity_type is not None:
            params['activity_type'] = activity_type
        if start_date is not None:
            params['start_date'] = start_date
        if end_date is not None:
            params['end_date'] = end_date

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_channel_retention(self, channelId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get retention policy of a channel

        API: GET /chat/channels/{channelId}/retention

        Args:
            channelId (str, required): original param name `channelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/retention"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_channel_retention(self, channelId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update retention policy of a channel

        API: PATCH /chat/channels/{channelId}/retention

        Args:
            channelId (str, required): original param name `channelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/retention"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_channel(self, channelId: str, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a channel

        API: GET /chat/users/{userId}/channels/{channelId}

        Args:
            channelId (str, required): original param name `channelId`
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/channels/{channelId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_channel(self, channelId: str, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a channel

        API: DELETE /chat/users/{userId}/channels/{channelId}

        Args:
            channelId (str, required): original param name `channelId`
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/channels/{channelId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_channel(self, channelId: str, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a channel

        API: PATCH /chat/users/{userId}/channels/{channelId}

        Args:
            channelId (str, required): original param name `channelId`
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/channels/{channelId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_channel_administrators(
        userId: str,
        channelId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List channel administrators

        API: GET /chat/users/{userId}/channels/{channelId}/admins

        Args:
            userId (str, required): original param name `userId`
            channelId (str, required): original param name `channelId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/channels/{channelId}/admins"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def promote_channel_members_as_admin(self, userId: str, channelId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Promote channel members to administrators

        API: POST /chat/users/{userId}/channels/{channelId}/admins

        Args:
            userId (str, required): original param name `userId`
            channelId (str, required): original param name `channelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/channels/{channelId}/admins"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def batch_demote_channel_administrators(
        userId: str,
        channelId: str,
        admin_ids: Optional[str] = None,
        user_ids: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Batch demote channel administrators

        API: DELETE /chat/users/{userId}/channels/{channelId}/admins

        Args:
            userId (str, required): original param name `userId`
            channelId (str, required): original param name `channelId`
            admin_ids (str, required): original param name `admin_ids`
            user_ids (str, required): original param name `user_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/channels/{channelId}/admins"

        params: Dict[str, Any] = {}
        if admin_ids is not None:
            params['admin_ids'] = admin_ids
        if user_ids is not None:
            params['user_ids'] = user_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_channel_members(
        channelId: str,
        userId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List channel members

        API: GET /chat/users/{userId}/channels/{channelId}/members

        Args:
            channelId (str, required): original param name `channelId`
            userId (str, required): original param name `userId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/channels/{channelId}/members"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def invite_channel_members(self, channelId: str, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Invite channel members

        API: POST /chat/users/{userId}/channels/{channelId}/members

        Args:
            channelId (str, required): original param name `channelId`
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/channels/{channelId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def batch_remove_user_channel_members(self, channelId: str, userId: str, identifiers: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Batch remove members from a user's channel

        API: DELETE /chat/users/{userId}/channels/{channelId}/members

        Args:
            channelId (str, required): original param name `channelId`
            userId (str, required): original param name `userId`
            identifiers (str, required): original param name `identifiers`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/channels/{channelId}/members"

        params: Dict[str, Any] = {}
        if identifiers is not None:
            params['identifiers'] = identifiers

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def remove_a_channel_member(self, channelId: str, identifier: str, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove a member

        API: DELETE /chat/users/{userId}/channels/{channelId}/members/{identifier}

        Args:
            channelId (str, required): original param name `channelId`
            identifier (str, required): original param name `identifier`
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/channels/{channelId}/members/{identifier}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_custom_emojis(self, page_size: Optional[int] = None, search_key: Optional[str] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List custom emojis

        API: GET /chat/emoji

        Args:
            page_size (int, optional): original param name `page_size`
            search_key (str, optional): original param name `search_key`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/emoji"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if search_key is not None:
            params['search_key'] = search_key
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_a_custom_emoji(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a custom emoji

        API: POST /chat/emoji/files

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/emoji/files"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_custom_emoji(self, fileId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a custom emoji

        API: DELETE /chat/emoji/{fileId}

        Args:
            fileId (str, required): original param name `fileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/emoji/{fileId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_file_info(self, fileId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get file info

        API: GET /chat/files/{fileId}

        Args:
            fileId (str, required): original param name `fileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/files/{fileId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_chat_file(self, fileId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a chat file

        API: DELETE /chat/files/{fileId}

        Args:
            fileId (str, required): original param name `fileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/files/{fileId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def upload_a_chat_file(self, userId: str, postToPersonalChat: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Upload a chat file

        API: POST /chat/users/{userId}/files

        Args:
            userId (str, required): original param name `userId`
            postToPersonalChat (str, optional): original param name `postToPersonalChat`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/files"

        params: Dict[str, Any] = {}
        if postToPersonalChat is not None:
            params['postToPersonalChat'] = postToPersonalChat

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def send_chat_file(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Send a chat file

        API: POST /chat/users/{userId}/messages/files

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/messages/files"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def perform_message_of_channel(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Perform operations on the message of channel

        API: PATCH /chat/channel/message/events

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channel/message/events"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_channel_pinned_messages(
        channelId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        include_history: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List pinned history messages of channel

        API: GET /chat/channels/{channelId}/pinned

        Args:
            channelId (str, required): original param name `channelId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            include_history (bool, optional): original param name `include_history`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/channels/{channelId}/pinned"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if include_history is not None:
            params['include_history'] = include_history

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_forwarded_message(self, forwardId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a forwarded message

        API: GET /chat/forwarded_message/{forwardId}

        Args:
            forwardId (str, required): original param name `forwardId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/forwarded_message/{forwardId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def fetch_bookmarks(
        to_contact: Optional[str] = None,
        to_channel: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List bookmarks

        API: GET /chat/messages/bookmarks

        Args:
            to_contact (str, optional): original param name `to_contact`
            to_channel (str, optional): original param name `to_channel`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/messages/bookmarks"

        params: Dict[str, Any] = {}
        if to_contact is not None:
            params['to_contact'] = to_contact
        if to_channel is not None:
            params['to_channel'] = to_channel
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_or_remove_a_bookmark(self, message_id: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add or remove a bookmark

        API: PATCH /chat/messages/bookmarks

        Args:
            message_id (str, required): original param name `message_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/messages/bookmarks"

        params: Dict[str, Any] = {}
        if message_id is not None:
            params['message_id'] = message_id

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_scheduled_messages(
        to_contact: Optional[str] = None,
        to_channel: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List scheduled messages

        API: GET /chat/messages/schedule

        Args:
            to_contact (str, optional): original param name `to_contact`
            to_channel (str, optional): original param name `to_channel`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/messages/schedule"

        params: Dict[str, Any] = {}
        if to_contact is not None:
            params['to_contact'] = to_contact
        if to_channel is not None:
            params['to_channel'] = to_channel
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_schedule_message(self, draftId: str, to_contact: Optional[str] = None, to_channel: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a scheduled message

        API: DELETE /chat/messages/schedule/{draftId}

        Args:
            draftId (str, required): original param name `draftId`
            to_contact (str, optional): original param name `to_contact`
            to_channel (str, optional): original param name `to_channel`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/messages/schedule/{draftId}"

        params: Dict[str, Any] = {}
        if to_contact is not None:
            params['to_contact'] = to_contact
        if to_channel is not None:
            params['to_channel'] = to_channel

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_chat_messages(
        userId: str,
        to_contact: Optional[str] = None,
        to_channel: Optional[str] = None,
        date: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        include_deleted_and_edited_message: Optional[bool] = None,
        search_type: Optional[str] = None,
        search_key: Optional[str] = None,
        exclude_child_message: Optional[bool] = None,
        download_file_formats: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List user's chat messages

        API: GET /chat/users/{userId}/messages

        Args:
            userId (str, required): original param name `userId`
            to_contact (str, optional): original param name `to_contact`
            to_channel (str, optional): original param name `to_channel`
            date (str, optional): original param name `date`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            include_deleted_and_edited_message (bool, optional): original param name `include_deleted_and_edited_message`
            search_type (str, optional): original param name `search_type`
            search_key (str, optional): original param name `search_key`
            exclude_child_message (bool, optional): original param name `exclude_child_message`
            download_file_formats (str, optional): original param name `download_file_formats`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/messages"

        params: Dict[str, Any] = {}
        if to_contact is not None:
            params['to_contact'] = to_contact
        if to_channel is not None:
            params['to_channel'] = to_channel
        if date is not None:
            params['date'] = date
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if include_deleted_and_edited_message is not None:
            params['include_deleted_and_edited_message'] = include_deleted_and_edited_message
        if search_type is not None:
            params['search_type'] = search_type
        if search_key is not None:
            params['search_key'] = search_key
        if exclude_child_message is not None:
            params['exclude_child_message'] = exclude_child_message
        if download_file_formats is not None:
            params['download_file_formats'] = download_file_formats

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def senda_chat_message(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Send a chat message

        API: POST /chat/users/{userId}/messages

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/messages"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_chat_message(
        userId: str,
        messageId: str,
        to_contact: Optional[str] = None,
        to_channel: Optional[str] = None,
        download_file_formats: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get a message

        API: GET /chat/users/{userId}/messages/{messageId}

        Args:
            userId (str, required): original param name `userId`
            messageId (str, required): original param name `messageId`
            to_contact (str, optional): original param name `to_contact`
            to_channel (str, optional): original param name `to_channel`
            download_file_formats (str, optional): original param name `download_file_formats`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/messages/{messageId}"

        params: Dict[str, Any] = {}
        if to_contact is not None:
            params['to_contact'] = to_contact
        if to_channel is not None:
            params['to_channel'] = to_channel
        if download_file_formats is not None:
            params['download_file_formats'] = download_file_formats

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def edit_message(self, userId: str, messageId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a message

        API: PUT /chat/users/{userId}/messages/{messageId}

        Args:
            userId (str, required): original param name `userId`
            messageId (str, required): original param name `messageId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/messages/{messageId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_chat_message(
        userId: str,
        messageId: str,
        to_contact: Optional[str] = None,
        to_channel: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete a message

        API: DELETE /chat/users/{userId}/messages/{messageId}

        Args:
            userId (str, required): original param name `userId`
            messageId (str, required): original param name `messageId`
            to_contact (str, optional): original param name `to_contact`
            to_channel (str, optional): original param name `to_channel`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/messages/{messageId}"

        params: Dict[str, Any] = {}
        if to_contact is not None:
            params['to_contact'] = to_contact
        if to_channel is not None:
            params['to_channel'] = to_channel

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def react_message(self, userId: str, messageId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        React to a chat message

        API: PATCH /chat/users/{userId}/messages/{messageId}/emoji_reactions

        Args:
            userId (str, required): original param name `userId`
            messageId (str, required): original param name `messageId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/messages/{messageId}/emoji_reactions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def mark_message(self, userId: str, messageId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Mark message read or unread

        API: PATCH /chat/users/{userId}/messages/{messageId}/status

        Args:
            userId (str, required): original param name `userId`
            messageId (str, required): original param name `messageId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/messages/{messageId}/status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def retrieve_thread(
        userId: str,
        messageId: str,
        to_channel: Optional[str] = None,
        to_contact: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        limit: Optional[int] = None,
        sort: Optional[str] = None,
        need_main_message: Optional[bool] = None,
        need_emoji: Optional[bool] = None,
        need_attachment: Optional[bool] = None,
        need_rich_text: Optional[bool] = None,
        need_at_items: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Retrieve a thread

        API: GET /chat/users/{userId}/messages/{messageId}/thread

        Args:
            userId (str, required): original param name `userId`
            messageId (str, required): original param name `messageId`
            to_channel (str, optional): original param name `to_channel`
            to_contact (str, optional): original param name `to_contact`
            from_param (str, required): original param name `from`
            to (str, optional): original param name `to`
            limit (int, optional): original param name `limit`
            sort (str, optional): original param name `sort`
            need_main_message (bool, optional): original param name `need_main_message`
            need_emoji (bool, optional): original param name `need_emoji`
            need_attachment (bool, optional): original param name `need_attachment`
            need_rich_text (bool, optional): original param name `need_rich_text`
            need_at_items (bool, optional): original param name `need_at_items`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/messages/{messageId}/thread"

        params: Dict[str, Any] = {}
        if to_channel is not None:
            params['to_channel'] = to_channel
        if to_contact is not None:
            params['to_contact'] = to_contact
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if limit is not None:
            params['limit'] = limit
        if sort is not None:
            params['sort'] = sort
        if need_main_message is not None:
            params['need_main_message'] = need_main_message
        if need_emoji is not None:
            params['need_emoji'] = need_emoji
        if need_attachment is not None:
            params['need_attachment'] = need_attachment
        if need_rich_text is not None:
            params['need_rich_text'] = need_rich_text
        if need_at_items is not None:
            params['need_at_items'] = need_at_items

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def migrate_channel_members(self, channelId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Migrate channel members

        API: POST /chat/migration/channels/{channelId}/members

        Args:
            channelId (str, required): original param name `channelId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/migration/channels/{channelId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def migrate_chat_message_reactions(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Migrate chat message reactions

        API: POST /chat/migration/emoji_reactions

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/migration/emoji_reactions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_migration_channels_mapping(self, origin_platform: Optional[str] = None, origin_team_id: Optional[str] = None, origin_channel_ids: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get migrated Zoom channel IDs

        API: GET /chat/migration/mappings/channels

        Args:
            origin_platform (str, required): original param name `origin_platform`
            origin_team_id (str, required): original param name `origin_team_id`
            origin_channel_ids (str, required): original param name `origin_channel_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/migration/mappings/channels"

        params: Dict[str, Any] = {}
        if origin_platform is not None:
            params['origin_platform'] = origin_platform
        if origin_team_id is not None:
            params['origin_team_id'] = origin_team_id
        if origin_channel_ids is not None:
            params['origin_channel_ids'] = origin_channel_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_migration_users_mapping(self, origin_platform: Optional[str] = None, origin_team_id: Optional[str] = None, origin_user_ids: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get migrated Zoom user IDs

        API: GET /chat/migration/mappings/users

        Args:
            origin_platform (str, required): original param name `origin_platform`
            origin_team_id (str, optional): original param name `origin_team_id`
            origin_user_ids (str, required): original param name `origin_user_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/migration/mappings/users"

        params: Dict[str, Any] = {}
        if origin_platform is not None:
            params['origin_platform'] = origin_platform
        if origin_team_id is not None:
            params['origin_team_id'] = origin_team_id
        if origin_user_ids is not None:
            params['origin_user_ids'] = origin_user_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def migrate_chat_messages(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Migrate chat messages

        API: POST /chat/migration/messages

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/migration/messages"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def migrate_a_chat_channel(self, identifier: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Migrate a chat channel

        API: POST /chat/migration/users/{identifier}/channels

        Args:
            identifier (str, required): original param name `identifier`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/migration/users/{identifier}/channels"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def migrate1_1_conversation_or_channel_operations(self, identifier: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Migrate 1:1 conversation or channel operations

        API: POST /chat/migration/users/{identifier}/events

        Args:
            identifier (str, required): original param name `identifier`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/migration/users/{identifier}/events"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_reminder_for_message(self, messageId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a reminder message

        API: POST /chat/messages/{messageId}/reminder

        Args:
            messageId (str, required): original param name `messageId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/messages/{messageId}/reminder"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_reminder_for_message(self, messageId: str, to_contact: Optional[str] = None, to_channel: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a reminder for a message

        API: DELETE /chat/messages/{messageId}/reminder

        Args:
            messageId (str, required): original param name `messageId`
            to_contact (str, optional): original param name `to_contact`
            to_channel (str, optional): original param name `to_channel`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/messages/{messageId}/reminder"

        params: Dict[str, Any] = {}
        if to_contact is not None:
            params['to_contact'] = to_contact
        if to_channel is not None:
            params['to_channel'] = to_channel

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_reminders(
        to_contact: Optional[str] = None,
        to_channel: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List reminders

        API: GET /chat/reminder

        Args:
            to_contact (str, optional): original param name `to_contact`
            to_channel (str, optional): original param name `to_channel`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/reminder"

        params: Dict[str, Any] = {}
        if to_contact is not None:
            params['to_contact'] = to_contact
        if to_channel is not None:
            params['to_channel'] = to_channel
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def star_unstar_channel_contact(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Star or unstar a channel or contact user

        API: PATCH /chat/users/{userId}/events

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/events"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_chat_sessions(
        userId: str,
        type_param: Optional[str] = None,
        search_star: Optional[bool] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List a user's chat sessions

        API: GET /chat/users/{userId}/sessions

        Args:
            userId (str, required): original param name `userId`
            type_param (str, optional): original param name `type`
            search_star (bool, optional): original param name `search_star`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/sessions"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if search_star is not None:
            params['search_star'] = search_star
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_user_contacts(self, type_param: Optional[str] = None, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List user's contacts

        API: GET /chat/users/me/contacts

        Args:
            type_param (str, optional): original param name `type`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/me/contacts"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_user_contact(self, identifier: str, query_presence_status: Optional[bool] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get user's contact details

        API: GET /chat/users/me/contacts/{identifier}

        Args:
            identifier (str, required): original param name `identifier`
            query_presence_status (bool, optional): original param name `query_presence_status`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/me/contacts/{identifier}"

        params: Dict[str, Any] = {}
        if query_presence_status is not None:
            params['query_presence_status'] = query_presence_status

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def search_company_contacts(
        search_key: Optional[str] = None,
        query_presence_status: Optional[bool] = None,
        page_size: Optional[int] = None,
        contact_types: Optional[int] = None,
        user_status: Optional[str] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Search company contacts

        API: GET /contacts

        Args:
            search_key (str, required): original param name `search_key`
            query_presence_status (bool, optional): original param name `query_presence_status`
            page_size (int, optional): original param name `page_size`
            contact_types (int, optional): original param name `contact_types`
            user_status (str, optional): original param name `user_status`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/contacts"

        params: Dict[str, Any] = {}
        if search_key is not None:
            params['search_key'] = search_key
        if query_presence_status is not None:
            params['query_presence_status'] = query_presence_status
        if page_size is not None:
            params['page_size'] = page_size
        if contact_types is not None:
            params['contact_types'] = contact_types
        if user_status is not None:
            params['user_status'] = user_status
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def sendimmessages(self, chat_user: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Send IM messages

        API: POST /im/users/me/chat/messages

        Args:
            chat_user (str, optional): original param name `chat_user`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/im/users/me/chat/messages"

        params: Dict[str, Any] = {}
        if chat_user is not None:
            params['chat_user'] = chat_user

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def im_groups(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List IM directory groups

        API: GET /im/groups

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/im/groups"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def im_group_create(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create an IM directory group

        API: POST /im/groups

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/im/groups"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def im_group(self, groupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Retrieve an IM directory group

        API: GET /im/groups/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/im/groups/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def im_group_delete(self, groupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete an IM directory group

        API: DELETE /im/groups/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/im/groups/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def im_group_update(self, groupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update an IM directory group

        API: PATCH /im/groups/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/im/groups/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def im_group_members(
        groupId: str,
        page_size: Optional[int] = None,
        page_number: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List IM directory group members

        API: GET /im/groups/{groupId}/members

        Args:
            groupId (str, required): original param name `groupId`
            page_size (int, optional): original param name `page_size`
            page_number (int, optional): original param name `page_number`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/im/groups/{groupId}/members"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if page_number is not None:
            params['page_number'] = page_number
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def im_group_members_create(self, groupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add IM directory group members

        API: POST /im/groups/{groupId}/members

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/im/groups/{groupId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def im_group_members_delete(self, groupId: str, memberId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete IM directory group member

        API: DELETE /im/groups/{groupId}/members/{memberId}

        Args:
            groupId (str, required): original param name `groupId`
            memberId (str, required): original param name `memberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/im/groups/{groupId}/members/{memberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def send_new_contact_invitation(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Send new contact invitation

        API: POST /chat/users/{userId}/invitations

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/users/{userId}/invitations"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_legal_hold_matters(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List legal hold matters

        API: GET /chat/legalhold/matters

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/legalhold/matters"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_legal_hold_matter(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add a legal hold matter

        API: POST /chat/legalhold/matters

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/legalhold/matters"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_legal_hold_matters(self, matterId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete legal hold matters

        API: DELETE /chat/legalhold/matters/{matterId}

        Args:
            matterId (str, required): original param name `matterId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/legalhold/matters/{matterId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_legal_hold_matter(self, matterId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update legal hold matter

        API: PATCH /chat/legalhold/matters/{matterId}

        Args:
            matterId (str, required): original param name `matterId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/legalhold/matters/{matterId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_legal_hold_files(
        matterId: str,
        identifier: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List legal hold files by given matter

        API: GET /chat/legalhold/matters/{matterId}/files

        Args:
            matterId (str, required): original param name `matterId`
            identifier (str, required): original param name `identifier`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/legalhold/matters/{matterId}/files"

        params: Dict[str, Any] = {}
        if identifier is not None:
            params['identifier'] = identifier
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def download_legal_hold_files(self, matterId: str, file_key: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Download legal hold files for given matter

        API: GET /chat/legalhold/matters/{matterId}/files/download

        Args:
            matterId (str, required): original param name `matterId`
            file_key (str, required): original param name `file_key`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/legalhold/matters/{matterId}/files/download"

        params: Dict[str, Any] = {}
        if file_key is not None:
            params['file_key'] = file_key

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_chat_sessions(
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get chat sessions reports

        API: GET /report/chat/sessions

        Args:
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/chat/sessions"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def report_chat_messages(
        sessionId: str,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = None,
        include_fields: Optional[str] = None,
        include_bot_message: Optional[bool] = None,
        include_reactions: Optional[bool] = None,
        query_all_modifications: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get chat message reports

        API: GET /report/chat/sessions/{sessionId}

        Args:
            sessionId (str, required): original param name `sessionId`
            from_param (str, required): original param name `from`
            to (str, required): original param name `to`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`
            include_fields (str, optional): original param name `include_fields`
            include_bot_message (bool, optional): original param name `include_bot_message`
            include_reactions (bool, optional): original param name `include_reactions`
            query_all_modifications (bool, optional): original param name `query_all_modifications`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/report/chat/sessions/{sessionId}"

        params: Dict[str, Any] = {}
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size
        if include_fields is not None:
            params['include_fields'] = include_fields
        if include_bot_message is not None:
            params['include_bot_message'] = include_bot_message
        if include_reactions is not None:
            params['include_reactions'] = include_reactions
        if query_all_modifications is not None:
            params['query_all_modifications'] = query_all_modifications

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_shared_spaces(self, next_page_token: Optional[str] = None, page_size: Optional[str] = None, user_id: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List shared spaces

        API: GET /chat/spaces

        Args:
            next_page_token (str, optional): original param name `next_page_token`
            page_size (str, optional): original param name `page_size`
            user_id (str, optional): original param name `user_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/spaces"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size
        if user_id is not None:
            params['user_id'] = user_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_space(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a shared space

        API: POST /chat/spaces

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/spaces"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_a_shared_space(self, spaceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a shared space

        API: GET /chat/spaces/{spaceId}

        Args:
            spaceId (str, required): original param name `spaceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/spaces/{spaceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_space(self, spaceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a shared space

        API: DELETE /chat/spaces/{spaceId}

        Args:
            spaceId (str, required): original param name `spaceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/spaces/{spaceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_shared_space_settings(self, spaceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update shared space settings

        API: PATCH /chat/spaces/{spaceId}

        Args:
            spaceId (str, required): original param name `spaceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/spaces/{spaceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def promote_space_members(self, spaceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Promote shared space members to administrators

        API: POST /chat/spaces/{spaceId}/admins

        Args:
            spaceId (str, required): original param name `spaceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/spaces/{spaceId}/admins"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def demote_space_admins(self, spaceId: str, identifiers: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Demote shared space administrators to members

        API: DELETE /chat/spaces/{spaceId}/admins

        Args:
            spaceId (str, required): original param name `spaceId`
            identifiers (str, required): original param name `identifiers`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/spaces/{spaceId}/admins"

        params: Dict[str, Any] = {}
        if identifiers is not None:
            params['identifiers'] = identifiers

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_shared_space_channels(self, spaceId: str, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List shared space channels

        API: GET /chat/spaces/{spaceId}/channels

        Args:
            spaceId (str, required): original param name `spaceId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/spaces/{spaceId}/channels"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_shared_space_channels(self, spaceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Move shared space channels

        API: PATCH /chat/spaces/{spaceId}/channels

        Args:
            spaceId (str, required): original param name `spaceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/spaces/{spaceId}/channels"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_shared_space_members(
        spaceId: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        role: Optional[str] = None,
        status: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List shared space members

        API: GET /chat/spaces/{spaceId}/members

        Args:
            spaceId (str, required): original param name `spaceId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            role (str, optional): original param name `role`
            status (str, optional): original param name `status`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/spaces/{spaceId}/members"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if role is not None:
            params['role'] = role
        if status is not None:
            params['status'] = status

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_space_members(self, spaceId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add members to a shared space

        API: POST /chat/spaces/{spaceId}/members

        Args:
            spaceId (str, required): original param name `spaceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/spaces/{spaceId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_space_members(self, spaceId: str, identifiers: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove members from a shared space

        API: DELETE /chat/spaces/{spaceId}/members

        Args:
            spaceId (str, required): original param name `spaceId`
            identifiers (str, required): original param name `identifiers`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/spaces/{spaceId}/members"

        params: Dict[str, Any] = {}
        if identifiers is not None:
            params['identifiers'] = identifiers

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def transfer_space_owner(self, spaceId: str, identifier: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Transfer shared space ownership

        API: PATCH /chat/spaces/{spaceId}/owner

        Args:
            spaceId (str, required): original param name `spaceId`
            identifier (str, required): original param name `identifier`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/chat/spaces/{spaceId}/owner"

        params: Dict[str, Any] = {}
        if identifier is not None:
            params['identifier'] = identifier

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== Users =====
    async def contact_groups(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List contact groups

        API: GET /contacts/groups

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/contacts/groups"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def contact_group_create(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a contact group

        API: POST /contacts/groups

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/contacts/groups"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def contact_group(self, groupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a contact group

        API: GET /contacts/groups/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/contacts/groups/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def contact_group_delete(self, groupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a contact group

        API: DELETE /contacts/groups/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/contacts/groups/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def contact_group_update(self, groupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a contact group

        API: PATCH /contacts/groups/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/contacts/groups/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def contact_group_members(self, groupId: str, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List contact group members

        API: GET /contacts/groups/{groupId}/members

        Args:
            groupId (str, required): original param name `groupId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/contacts/groups/{groupId}/members"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def contact_group_member_add(self, groupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add contact group members

        API: POST /contacts/groups/{groupId}/members

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/contacts/groups/{groupId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def contact_group_member_remove(self, groupId: str, member_ids: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove members in a contact group

        API: DELETE /contacts/groups/{groupId}/members

        Args:
            groupId (str, required): original param name `groupId`
            member_ids (str, required): original param name `member_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/contacts/groups/{groupId}/members"

        params: Dict[str, Any] = {}
        if member_ids is not None:
            params['member_ids'] = member_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_divisions(self, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List divisions

        API: GET /divisions

        Args:
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/divisions"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def createadivision(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a division

        API: POST /divisions

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/divisions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getdivision(self, divisionId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a division

        API: GET /divisions/{divisionId}

        Args:
            divisionId (str, required): original param name `divisionId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/divisions/{divisionId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def deletedivision(self, divisionId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a division

        API: DELETE /divisions/{divisionId}

        Args:
            divisionId (str, required): original param name `divisionId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/divisions/{divisionId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def updateadivision(self, divisionId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a division

        API: PATCH /divisions/{divisionId}

        Args:
            divisionId (str, required): original param name `divisionId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/divisions/{divisionId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_division_members(self, divisionId: str, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List division members

        API: GET /divisions/{divisionId}/users

        Args:
            divisionId (str, required): original param name `divisionId`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/divisions/{divisionId}/users"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def assigndivision_member(self, divisionId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Assign a division

        API: POST /divisions/{divisionId}/users

        Args:
            divisionId (str, required): original param name `divisionId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/divisions/{divisionId}/users"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def groups(self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List groups

        API: GET /groups

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_create(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a group

        API: POST /groups

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group(self, groupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a group

        API: GET /groups/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_delete(self, groupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a group

        API: DELETE /groups/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_update(self, groupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a group

        API: PATCH /groups/{groupId}

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_admins(self, groupId: str, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List group admins

        API: GET /groups/{groupId}/admins

        Args:
            groupId (str, required): original param name `groupId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/admins"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_admins_create(self, groupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add group admins

        API: POST /groups/{groupId}/admins

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/admins"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_admins_delete(self, groupId: str, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a group admin

        API: DELETE /groups/{groupId}/admins/{userId}

        Args:
            groupId (str, required): original param name `groupId`
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/admins/{userId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_channels(self, groupId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List group channels

        API: GET /groups/{groupId}/channels

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/channels"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_group_lock_settings(self, groupId: str, option: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get locked settings

        API: GET /groups/{groupId}/lock_settings

        Args:
            groupId (str, required): original param name `groupId`
            option (str, optional): original param name `option`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/lock_settings"

        params: Dict[str, Any] = {}
        if option is not None:
            params['option'] = option

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_locked_settings(self, groupId: str, option: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update locked settings

        API: PATCH /groups/{groupId}/lock_settings

        Args:
            groupId (str, required): original param name `groupId`
            option (str, optional): original param name `option`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/lock_settings"

        params: Dict[str, Any] = {}
        if option is not None:
            params['option'] = option

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_members(
        groupId: str,
        page_size: Optional[int] = None,
        page_number: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List group members

        API: GET /groups/{groupId}/members

        Args:
            groupId (str, required): original param name `groupId`
            page_size (int, optional): original param name `page_size`
            page_number (int, optional): original param name `page_number`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/members"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if page_number is not None:
            params['page_number'] = page_number
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_members_create(self, groupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add group members

        API: POST /groups/{groupId}/members

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/members"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_members_delete(self, groupId: str, memberId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a group member

        API: DELETE /groups/{groupId}/members/{memberId}

        Args:
            groupId (str, required): original param name `groupId`
            memberId (str, required): original param name `memberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/members/{memberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_a_group_member(self, groupId: str, memberId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a group member

        API: PATCH /groups/{groupId}/members/{memberId}

        Args:
            groupId (str, required): original param name `groupId`
            memberId (str, required): original param name `memberId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/members/{memberId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_group_settings(self, groupId: str, option: Optional[str] = None, custom_query_fields: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a group's settings

        API: GET /groups/{groupId}/settings

        Args:
            groupId (str, required): original param name `groupId`
            option (str, optional): original param name `option`
            custom_query_fields (str, optional): original param name `custom_query_fields`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/settings"

        params: Dict[str, Any] = {}
        if option is not None:
            params['option'] = option
        if custom_query_fields is not None:
            params['custom_query_fields'] = custom_query_fields

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_group_settings(self, groupId: str, option: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a group's settings

        API: PATCH /groups/{groupId}/settings

        Args:
            groupId (str, required): original param name `groupId`
            option (str, optional): original param name `option`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/settings"

        params: Dict[str, Any] = {}
        if option is not None:
            params['option'] = option

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_settings_registration(self, groupId: str, type_param: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a group's webinar registration settings

        API: GET /groups/{groupId}/settings/registration

        Args:
            groupId (str, required): original param name `groupId`
            type_param (str, optional): original param name `type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/settings/registration"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def group_settings_registration_update(self, groupId: str, type_param: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a group's webinar registration settings

        API: PATCH /groups/{groupId}/settings/registration

        Args:
            groupId (str, required): original param name `groupId`
            type_param (str, optional): original param name `type`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/settings/registration"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def upload_group_vb(self, groupId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Upload Virtual Background files

        API: POST /groups/{groupId}/settings/virtual_backgrounds

        Args:
            groupId (str, required): original param name `groupId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/settings/virtual_backgrounds"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def del_group_vb(self, groupId: str, file_ids: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete Virtual Background files

        API: DELETE /groups/{groupId}/settings/virtual_backgrounds

        Args:
            groupId (str, required): original param name `groupId`
            file_ids (str, optional): original param name `file_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/groups/{groupId}/settings/virtual_backgrounds"

        params: Dict[str, Any] = {}
        if file_ids is not None:
            params['file_ids'] = file_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def users(
        status: Optional[str] = None,
        page_size: Optional[int] = None,
        role_id: Optional[str] = None,
        page_number: Optional[str] = None,
        include_fields: Optional[str] = None,
        next_page_token: Optional[str] = None,
        license: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List users

        API: GET /users

        Args:
            status (str, optional): original param name `status`
            page_size (int, optional): original param name `page_size`
            role_id (str, optional): original param name `role_id`
            page_number (str, optional): original param name `page_number`
            include_fields (str, optional): original param name `include_fields`
            next_page_token (str, optional): original param name `next_page_token`
            license (str, optional): original param name `license`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users"

        params: Dict[str, Any] = {}
        if status is not None:
            params['status'] = status
        if page_size is not None:
            params['page_size'] = page_size
        if role_id is not None:
            params['role_id'] = role_id
        if page_number is not None:
            params['page_number'] = page_number
        if include_fields is not None:
            params['include_fields'] = include_fields
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if license is not None:
            params['license'] = license

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_create(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create users

        API: POST /users

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_email(self, email: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Check a user email

        API: GET /users/email

        Args:
            email (str, required): original param name `email`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/email"

        params: Dict[str, Any] = {}
        if email is not None:
            params['email'] = email

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def bulk_update_feature(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Bulk update features for users

        API: POST /users/features

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/features"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_zak(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get the user's ZAK

        API: GET /users/me/zak

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/me/zak"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_summary(self, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get user summary

        API: GET /users/summary

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/summary"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_vanity_name(self, vanity_name: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Check a user's PM room

        API: GET /users/vanity_name

        Args:
            vanity_name (str, required): original param name `vanity_name`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/vanity_name"

        params: Dict[str, Any] = {}
        if vanity_name is not None:
            params['vanity_name'] = vanity_name

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user(
        userId: str,
        login_type: Optional[int] = None,
        encrypted_email: Optional[bool] = None,
        search_by_unique_id: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get a user

        API: GET /users/{userId}

        Args:
            userId (str, required): original param name `userId`
            login_type (int, optional): original param name `login_type`
            encrypted_email (bool, optional): original param name `encrypted_email`
            search_by_unique_id (bool, optional): original param name `search_by_unique_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}"

        params: Dict[str, Any] = {}
        if login_type is not None:
            params['login_type'] = login_type
        if encrypted_email is not None:
            params['encrypted_email'] = encrypted_email
        if search_by_unique_id is not None:
            params['search_by_unique_id'] = search_by_unique_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_delete(
        userId: str,
        encrypted_email: Optional[bool] = None,
        action: Optional[str] = None,
        transfer_email: Optional[str] = None,
        transfer_meeting: Optional[bool] = None,
        transfer_webinar: Optional[bool] = None,
        transfer_recording: Optional[bool] = None,
        transfer_whiteboard: Optional[bool] = None,
        transfer_clipfiles: Optional[bool] = None,
        transfer_notes: Optional[bool] = None,
        transfer_visitors: Optional[bool] = None,
        transfer_docs: Optional[bool] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Delete a user

        API: DELETE /users/{userId}

        Args:
            userId (str, required): original param name `userId`
            encrypted_email (bool, optional): original param name `encrypted_email`
            action (str, optional): original param name `action`
            transfer_email (str, optional): original param name `transfer_email`
            transfer_meeting (bool, optional): original param name `transfer_meeting`
            transfer_webinar (bool, optional): original param name `transfer_webinar`
            transfer_recording (bool, optional): original param name `transfer_recording`
            transfer_whiteboard (bool, optional): original param name `transfer_whiteboard`
            transfer_clipfiles (bool, optional): original param name `transfer_clipfiles`
            transfer_notes (bool, optional): original param name `transfer_notes`
            transfer_visitors (bool, optional): original param name `transfer_visitors`
            transfer_docs (bool, optional): original param name `transfer_docs`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}"

        params: Dict[str, Any] = {}
        if encrypted_email is not None:
            params['encrypted_email'] = encrypted_email
        if action is not None:
            params['action'] = action
        if transfer_email is not None:
            params['transfer_email'] = transfer_email
        if transfer_meeting is not None:
            params['transfer_meeting'] = transfer_meeting
        if transfer_webinar is not None:
            params['transfer_webinar'] = transfer_webinar
        if transfer_recording is not None:
            params['transfer_recording'] = transfer_recording
        if transfer_whiteboard is not None:
            params['transfer_whiteboard'] = transfer_whiteboard
        if transfer_clipfiles is not None:
            params['transfer_clipfiles'] = transfer_clipfiles
        if transfer_notes is not None:
            params['transfer_notes'] = transfer_notes
        if transfer_visitors is not None:
            params['transfer_visitors'] = transfer_visitors
        if transfer_docs is not None:
            params['transfer_docs'] = transfer_docs

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_update(
        userId: str,
        login_type: Optional[int] = None,
        remove_tsp_credentials: Optional[bool] = None,
        body: Optional[Dict[str, Any]] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Update a user

        API: PATCH /users/{userId}

        Args:
            userId (str, required): original param name `userId`
            login_type (int, optional): original param name `login_type`
            remove_tsp_credentials (bool, optional): original param name `remove_tsp_credentials`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}"

        params: Dict[str, Any] = {}
        if login_type is not None:
            params['login_type'] = login_type
        if remove_tsp_credentials is not None:
            params['remove_tsp_credentials'] = remove_tsp_credentials

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_assistants(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List user assistants

        API: GET /users/{userId}/assistants

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/assistants"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_assistant_create(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Add assistants

        API: POST /users/{userId}/assistants

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/assistants"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_assistants_delete(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete user assistants

        API: DELETE /users/{userId}/assistants

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/assistants"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_assistant_delete(self, userId: str, assistantId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a user assistant

        API: DELETE /users/{userId}/assistants/{assistantId}

        Args:
            userId (str, required): original param name `userId`
            assistantId (str, required): original param name `assistantId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/assistants/{assistantId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_collaboration_devices(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List a user's collaboration devices

        API: GET /users/{userId}/collaboration_devices

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/collaboration_devices"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_collaboration_device(self, userId: str, collaborationDeviceId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get collaboration device detail

        API: GET /users/{userId}/collaboration_devices/{collaborationDeviceId}

        Args:
            userId (str, required): original param name `userId`
            collaborationDeviceId (str, required): original param name `collaborationDeviceId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/collaboration_devices/{collaborationDeviceId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_email_update(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a user's email

        API: PUT /users/{userId}/email

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/email"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getmeetingsummarytemplates(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get meeting summary templates

        API: GET /users/{userId}/meeting_summary_templates

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/meeting_summary_templates"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_user_meeting_templates(self, userId: str, meetingTemplateId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get meeting template detail

        API: GET /users/{userId}/meeting_templates/{meetingTemplateId}

        Args:
            userId (str, required): original param name `userId`
            meetingTemplateId (str, required): original param name `meetingTemplateId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/meeting_templates/{meetingTemplateId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_password(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a user's password

        API: PUT /users/{userId}/password

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/password"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_permission(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get user permissions

        API: GET /users/{userId}/permissions

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/permissions"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_picture(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Upload a user's profile picture

        API: POST /users/{userId}/picture

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/picture"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_picture_delete(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a user's profile picture

        API: DELETE /users/{userId}/picture

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/picture"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_user_presence_status(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a user presence status

        API: GET /users/{userId}/presence_status

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/presence_status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_presence_status(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update a user's presence status

        API: PUT /users/{userId}/presence_status

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/presence_status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_schedulers(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List user schedulers

        API: GET /users/{userId}/schedulers

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/schedulers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_schedulers_delete(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete user schedulers

        API: DELETE /users/{userId}/schedulers

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/schedulers"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_scheduler_delete(self, userId: str, schedulerId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a scheduler

        API: DELETE /users/{userId}/schedulers/{schedulerId}

        Args:
            userId (str, required): original param name `userId`
            schedulerId (str, required): original param name `schedulerId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/schedulers/{schedulerId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_settings(
        userId: str,
        login_type: Optional[int] = None,
        option: Optional[str] = None,
        custom_query_fields: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get user settings

        API: GET /users/{userId}/settings

        Args:
            userId (str, required): original param name `userId`
            login_type (int, optional): original param name `login_type`
            option (str, optional): original param name `option`
            custom_query_fields (str, optional): original param name `custom_query_fields`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/settings"

        params: Dict[str, Any] = {}
        if login_type is not None:
            params['login_type'] = login_type
        if option is not None:
            params['option'] = option
        if custom_query_fields is not None:
            params['custom_query_fields'] = custom_query_fields

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_settings_update(self, userId: str, option: Optional[str] = None, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update user settings

        API: PATCH /users/{userId}/settings

        Args:
            userId (str, required): original param name `userId`
            option (str, optional): original param name `option`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/settings"

        params: Dict[str, Any] = {}
        if option is not None:
            params['option'] = option

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def upload_v_buser(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Upload Virtual Background files

        API: POST /users/{userId}/settings/virtual_backgrounds

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/settings/virtual_backgrounds"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def del_user_vb(self, userId: str, file_ids: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete Virtual Background files

        API: DELETE /users/{userId}/settings/virtual_backgrounds

        Args:
            userId (str, required): original param name `userId`
            file_ids (str, optional): original param name `file_ids`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/settings/virtual_backgrounds"

        params: Dict[str, Any] = {}
        if file_ids is not None:
            params['file_ids'] = file_ids

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_status(self, userId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update user status

        API: PUT /users/{userId}/status

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_token(
        userId: str,
        type_param: Optional[str] = None,
        ttl: Optional[int] = None,
        meeting_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Get a user's token

        API: GET /users/{userId}/token

        Args:
            userId (str, required): original param name `userId`
            type_param (str, optional): original param name `type`
            ttl (int, optional): original param name `ttl`
            meeting_id (str, optional): original param name `meeting_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/token"

        params: Dict[str, Any] = {}
        if type_param is not None:
            params['type'] = type_param
        if ttl is not None:
            params['ttl'] = ttl
        if meeting_id is not None:
            params['meeting_id'] = meeting_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def user_sso_token_delete(self, userId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Revoke a user's SSO token

        API: DELETE /users/{userId}/token

        Args:
            userId (str, required): original param name `userId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/users/{userId}/token"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== Whiteboard =====
    async def createwhiteboardsarchivefiles(
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List whiteboards sessions

        API: GET /whiteboards/sessions

        Args:
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/sessions"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def downloadwhiteboardsactivityfile(self, path: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Download Whiteboards activity file

        API: GET /whiteboards/sessions/activity/download/{path}

        Args:
            path (str, required): original param name `path`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/sessions/activity/download/{path}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def listwhiteboardsessionsarchivedfiles(self, seesionId: str, page_size: Optional[int] = None, next_page_token: Optional[str] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List whiteboard sessions activities

        API: GET /whiteboards/sessions/{seesionId}

        Args:
            seesionId (str, required): original param name `seesionId`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/sessions/{seesionId}"

        params: Dict[str, Any] = {}
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_a_whiteboard_collaborator(self, whiteboardId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get collaborators of a whiteboard

        API: GET /whiteboards/{whiteboardId}/collaborator

        Args:
            whiteboardId (str, required): original param name `whiteboardId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/{whiteboardId}/collaborator"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def add_a_whiteboard_collaborator(self, whiteboardId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Share a whiteboard to new users or team chat channels.

        API: POST /whiteboards/{whiteboardId}/collaborator

        Args:
            whiteboardId (str, required): original param name `whiteboardId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/{whiteboardId}/collaborator"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_a_whiteboard_collaborator(self, whiteboardId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update whiteboard collaborators

        API: PATCH /whiteboards/{whiteboardId}/collaborator

        Args:
            whiteboardId (str, required): original param name `whiteboardId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/{whiteboardId}/collaborator"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_a_whiteboard_collaborator(self, whiteboardId: str, collaboratorId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove the collaborator from a whiteboard

        API: DELETE /whiteboards/{whiteboardId}/collaborator/{collaboratorId}

        Args:
            whiteboardId (str, required): original param name `whiteboardId`
            collaboratorId (str, required): original param name `collaboratorId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/{whiteboardId}/collaborator/{collaboratorId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_whiteboards(
        search_key: Optional[str] = None,
        user_id: Optional[str] = None,
        date_filter_type: Optional[str] = None,
        from_param: Optional[str] = None,
        to: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        project_id: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List all whiteboards

        API: GET /whiteboards

        Args:
            search_key (str, optional): original param name `search_key`
            user_id (str, optional): original param name `user_id`
            date_filter_type (str, optional): original param name `date_filter_type`
            from_param (str, optional): original param name `from`
            to (str, optional): original param name `to`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`
            project_id (str, optional): original param name `project_id`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards"

        params: Dict[str, Any] = {}
        if search_key is not None:
            params['search_key'] = search_key
        if user_id is not None:
            params['user_id'] = user_id
        if date_filter_type is not None:
            params['date_filter_type'] = date_filter_type
        if from_param is not None:
            params['from'] = from_param
        if to is not None:
            params['to'] = to
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if project_id is not None:
            params['project_id'] = project_id

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def new_whiteboard_create(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a new whiteboard

        API: POST /whiteboards

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_a_whiteboard(self, whiteboardId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a whiteboard

        API: GET /whiteboards/{whiteboardId}

        Args:
            whiteboardId (str, required): original param name `whiteboardId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/{whiteboardId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_a_whiteboard_metadata(self, whiteboardId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update whiteboard basic information

        API: PUT /whiteboards/{whiteboardId}

        Args:
            whiteboardId (str, required): original param name `whiteboardId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/{whiteboardId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PUT",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_a_whiteboard(self, whiteboardId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a whiteboard

        API: DELETE /whiteboards/{whiteboardId}

        Args:
            whiteboardId (str, required): original param name `whiteboardId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/{whiteboardId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def createwhiteboardsexport(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create whiteboard export

        API: POST /whiteboards/export

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/export"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def downloadwhiteboardexport(self, taskId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Download whiteboard export

        API: GET /whiteboards/export/task/{taskId}

        Args:
            taskId (str, required): original param name `taskId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/export/task/{taskId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getwhiteboardexportdatagenerationstatus(self, taskId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get whiteboard export generation status

        API: GET /whiteboards/export/task/{taskId}/status

        Args:
            taskId (str, required): original param name `taskId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/export/task/{taskId}/status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def uploadfileforwhiteboardimport(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Upload file for whiteboard import

        API: POST /whiteboards/files

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/files"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def downloadembeddedwhiteboardfile(self, whiteboardId: str, fileId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Download Imported Whiteboard File

        API: GET /whiteboards/{whiteboardId}/files/{fileId}

        Args:
            whiteboardId (str, required): original param name `whiteboardId`
            fileId (str, required): original param name `fileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/{whiteboardId}/files/{fileId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def create_whiteboard_import(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a new whiteboard by import

        API: POST /whiteboards/import

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/import"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def get_whiteboardimportstatus(self, taskId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get whiteboard import status

        API: GET /whiteboards/import/{taskId}/status

        Args:
            taskId (str, required): original param name `taskId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/import/{taskId}/status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def listallprojects(
        search_key: Optional[str] = None,
        user_id: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List all projects

        API: GET /whiteboards/projects

        Args:
            search_key (str, optional): original param name `search_key`
            user_id (str, optional): original param name `user_id`
            page_size (int, optional): original param name `page_size`
            next_page_token (str, optional): original param name `next_page_token`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/projects"

        params: Dict[str, Any] = {}
        if search_key is not None:
            params['search_key'] = search_key
        if user_id is not None:
            params['user_id'] = user_id
        if page_size is not None:
            params['page_size'] = page_size
        if next_page_token is not None:
            params['next_page_token'] = next_page_token

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def createproject(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a new project

        API: POST /whiteboards/projects

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/projects"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getaproject(self, projectId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get a project

        API: GET /whiteboards/projects/{projectId}

        Args:
            projectId (str, required): original param name `projectId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/projects/{projectId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def deleteproject(self, projectId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a project

        API: DELETE /whiteboards/projects/{projectId}

        Args:
            projectId (str, required): original param name `projectId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/projects/{projectId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def updateproject(self, projectId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update project basic information

        API: PATCH /whiteboards/projects/{projectId}

        Args:
            projectId (str, required): original param name `projectId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/projects/{projectId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getcollaboratorsofaproject(self, projectId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get collaborators of a project

        API: GET /whiteboards/projects/{projectId}/collaborators

        Args:
            projectId (str, required): original param name `projectId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/projects/{projectId}/collaborators"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def shareaprojecttonewusers(self, projectId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Share a project to new users

        API: POST /whiteboards/projects/{projectId}/collaborators

        Args:
            projectId (str, required): original param name `projectId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/projects/{projectId}/collaborators"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def updateprojectcollaborators(self, projectId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update project collaborators

        API: PATCH /whiteboards/projects/{projectId}/collaborators

        Args:
            projectId (str, required): original param name `projectId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/projects/{projectId}/collaborators"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def removethecollaboratorfromaproject(self, projectId: str, collaboratorId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove the collaborator from a project

        API: DELETE /whiteboards/projects/{projectId}/collaborators/{collaboratorId}

        Args:
            projectId (str, required): original param name `projectId`
            collaboratorId (str, required): original param name `collaboratorId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/projects/{projectId}/collaborators/{collaboratorId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def movewhiteboardstoproject(self, projectId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Move whiteboards to a project

        API: POST /whiteboards/projects/{projectId}/whiteboards

        Args:
            projectId (str, required): original param name `projectId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/projects/{projectId}/whiteboards"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def removewhiteboardsfromaproject(self, projectId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Remove whiteboards from a project

        API: DELETE /whiteboards/projects/{projectId}/whiteboards

        Args:
            projectId (str, required): original param name `projectId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/projects/{projectId}/whiteboards"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def update_a_whiteboard_share_setting(self, whiteboardId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Update whiteboard share setting

        API: PATCH /whiteboards/{whiteboardId}/share_setting

        Args:
            whiteboardId (str, required): original param name `whiteboardId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/whiteboards/{whiteboardId}/share_setting"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    # ===== Zoom Docs =====
    async def create_doc(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a new file

        API: POST /docs/files

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/docs/files"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def query_file_metadata(self, fileId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get metadata of a file

        API: GET /docs/files/{fileId}

        Args:
            fileId (str, required): original param name `fileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/docs/files/{fileId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def delete_file(self, fileId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Delete a file

        API: DELETE /docs/files/{fileId}

        Args:
            fileId (str, required): original param name `fileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/docs/files/{fileId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "DELETE",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def modify_metadata(self, fileId: str, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Modify metadata of a file

        API: PATCH /docs/files/{fileId}

        Args:
            fileId (str, required): original param name `fileId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/docs/files/{fileId}"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "PATCH",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def list_all_children(self, fileId: str, next_page_token: Optional[str] = None, page_size: Optional[int] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        List all children of a file

        API: GET /docs/files/{fileId}/children

        Args:
            fileId (str, required): original param name `fileId`
            next_page_token (str, optional): original param name `next_page_token`
            page_size (int, optional): original param name `page_size`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/docs/files/{fileId}/children"

        params: Dict[str, Any] = {}
        if next_page_token is not None:
            params['next_page_token'] = next_page_token
        if page_size is not None:
            params['page_size'] = page_size

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def uploadfilefordocsimportorattachments(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create file upload for docs import or attachments

        API: POST /docs/file_uploads

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/docs/file_uploads"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def createanewfilebyimport(self, body: Optional[Dict[str, Any]] = None, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Create a new file by import

        API: POST /docs/imports

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/docs/imports"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = body

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "POST",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

    async def getdocsfileimportstatus(self, importId: str, timeout: Optional[int] = None) -> Dict[str, Any]:
        """
        Get file import status

        API: GET /docs/imports/{importId}/status

        Args:
            importId (str, required): original param name `importId`

        Returns:
            Dict[str, Any]: API response
        """
        endpoint = f"{self._base_url}/docs/imports/{importId}/status"

        params: Dict[str, Any] = {}

        req_body: Optional[Dict[str, Any]] = None

        # execute request using provided client (IClient.request async)
        resp = await self._rest_client.request(
            "GET",
            endpoint,
            params=params,
            body=req_body,
            timeout=timeout
        )

        # status-code handling
        status = getattr(resp, 'status_code', None) or getattr(resp, 'status', None)
        if status == 204:
            return {'status': 'no_content'}

        # try to return JSON, fallback to text
        try:
            if callable(getattr(resp, 'json', None)):
                maybe = resp.json()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            if isinstance(resp, dict):
                return resp
            if callable(getattr(resp, 'text', None)):
                maybe = resp.text()
                if hasattr(maybe, '__await__'):
                    return await maybe
                return maybe
            return str(resp)
        except Exception:
            try:
                return resp.json() if hasattr(resp, 'json') else {'raw': str(resp)}
            except Exception:
                return {'raw': str(resp)}

