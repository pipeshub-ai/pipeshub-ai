# Auto-generated Workday API Wrapper
# Generated by WorkdayCodeGenerator (Dynamic Fetch)

from typing import Any, Dict, List, Optional

from app.sources.client.http.http_request import HTTPRequest
from app.sources.client.workday import WorkdayClient, WorkdayResponse

# HTTP status code threshold for determining success/failure
HTTP_ERROR_THRESHOLD = 400

class WorkdayDataSource:
    """Workday API Data Source

    Complete API wrapper covering 800+ endpoints.
    Generated dynamically from Workday Community OpenAPI specs.
    """

    def __init__(self, workday_client: WorkdayClient) -> None:
        self.http_client = workday_client.get_client()
        self._workday_client = workday_client
        self.base_url = workday_client.get_base_url().rstrip('/')

    def get_client(self) -> WorkdayClient:
        return self._workday_client

    async def create_budgets_v1_run_budget_check(
        self,
        checkBudgetHeader: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a budget check for transactions.

        Args:
            checkBudgetHeader:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/budgets/v1/runBudgetCheck"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if checkBudgetHeader is not None:
            if isinstance(checkBudgetHeader, dict):
                body.update(checkBudgetHeader)
            else:
                body["checkBudgetHeader"] = checkBudgetHeader

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_budgets_v1_run_budget_check {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_benefit_partner_v1_programs(
        self,
        benefitProgramsView: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a single benefit program instance.

        Args:
            benefitProgramsView:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/benefitPartner/v1/programs"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if benefitProgramsView is not None:
            if isinstance(benefitProgramsView, dict):
                body.update(benefitProgramsView)
            else:
                body["benefitProgramsView"] = benefitProgramsView

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_benefit_partner_v1_programs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_attachments_v1_graphql(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves an attachment using a downloadID from a Graph API query response.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/attachments/v1/graphql/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_attachments_v1_graphql {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_connect_v2_message_templates(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a message template with the specific ID.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/connect/v2/messageTemplates/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_connect_v2_message_templates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_connect_v2_message_templates(
        self,
        ID: str,
        messageTemplateDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates an existing message template instance.

        Args:
            ID: The Workday ID of the resource. (required)
            messageTemplateDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/connect/v2/messageTemplates/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if messageTemplateDetail is not None:
            if isinstance(messageTemplateDetail, dict):
                body.update(messageTemplateDetail)
            else:
                body["messageTemplateDetail"] = messageTemplateDetail

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_connect_v2_message_templates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_connect_v2_message_templates_1(
        self,
        ID: str,
        messageTemplateDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates an existing message template instance.

        Args:
            ID: The Workday ID of the resource. (required)
            messageTemplateDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/connect/v2/messageTemplates/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if messageTemplateDetail is not None:
            if isinstance(messageTemplateDetail, dict):
                body.update(messageTemplateDetail)
            else:
                body["messageTemplateDetail"] = messageTemplateDetail

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_connect_v2_message_templates_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_connect_v2_notification_types(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of notification types.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/connect/v2/notificationTypes"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_connect_v2_notification_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_connect_v2_values_audience_prompt_group_audience_type(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/connect/v2/values/AudiencePromptGroup/audienceType/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_connect_v2_values_audience_prompt_group_audience_type {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_connect_v2_send_message(
        self,
        messageDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            messageDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/connect/v2/sendMessage"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if messageDetail is not None:
            if isinstance(messageDetail, dict):
                body.update(messageDetail)
            else:
                body["messageDetail"] = messageDetail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_connect_v2_send_message {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_connect_v2_notification_types(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a notification type.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/connect/v2/notificationTypes/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_connect_v2_notification_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_connect_v2_message_templates(
        self,
        inactive: Optional[bool] = None,
        limit: Optional[int] = None,
        name: Optional[str] = None,
        notificationType: Optional[str] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of message templates.

        Args:
            inactive:  (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            name:  (optional)
            notificationType:  (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/connect/v2/messageTemplates"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if inactive is not None:
            params["inactive"] = inactive
        if limit is not None:
            params["limit"] = limit
        if name is not None:
            params["name"] = name
        if notificationType is not None:
            params["notificationType"] = notificationType
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_connect_v2_message_templates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_connect_v2_message_templates(
        self,
        messageTemplateDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            messageTemplateDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/connect/v2/messageTemplates"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if messageTemplateDetail is not None:
            if isinstance(messageTemplateDetail, dict):
                body.update(messageTemplateDetail)
            else:
                body["messageTemplateDetail"] = messageTemplateDetail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_connect_v2_message_templates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_connect_v2_values_audience_prompt_group_selection(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/connect/v2/values/AudiencePromptGroup/selection/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_connect_v2_values_audience_prompt_group_selection {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_compensation_v2_scorecard_results(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Provides the ability to set up and retrieve Scores on Scorecard Results.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/compensation/v2/scorecardResults"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_compensation_v2_scorecard_results {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_compensation_v2_scorecard_results(
        self,
        createScorecardResults: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a new Scorecard Result.

        Args:
            createScorecardResults:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/compensation/v2/scorecardResults"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if createScorecardResults is not None:
            if isinstance(createScorecardResults, dict):
                body.update(createScorecardResults)
            else:
                body["createScorecardResults"] = createScorecardResults

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_compensation_v2_scorecard_results {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_compensation_v2_workers(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a worker instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/compensation/v2/workers/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_compensation_v2_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_compensation_v2_scorecards(
        self,
        effectiveDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves Compensation Scorecard information.

        Args:
            effectiveDate: Effective date the scorecard task takes effect. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/compensation/v2/scorecards"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if effectiveDate is not None:
            params["effectiveDate"] = effectiveDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_compensation_v2_scorecards {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_compensation_v2_scorecards(
        self,
        createScorecard: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a Compensation Scorecard

        Args:
            createScorecard:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/compensation/v2/scorecards"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if createScorecard is not None:
            if isinstance(createScorecard, dict):
                body.update(createScorecard)
            else:
                body["createScorecard"] = createScorecard

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_compensation_v2_scorecards {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_compensation_v2_scorecard_results(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Provides the ability to set up and retrieve Scores on Scorecard Results.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/compensation/v2/scorecardResults/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_compensation_v2_scorecard_results {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_compensation_v2_scorecard_results(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Deletes the Scorecard Results with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/compensation/v2/scorecardResults/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_compensation_v2_scorecard_results {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_compensation_v2_workers(
        self,
        includeTerminatedWorkers: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        search: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of workers.

        Args:
            includeTerminatedWorkers: Include terminated workers in the output (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            search:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/compensation/v2/workers"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if includeTerminatedWorkers is not None:
            params["includeTerminatedWorkers"] = includeTerminatedWorkers
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if search is not None:
            params["search"] = search

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_compensation_v2_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_compensation_v2_workers_request_one_time_payment(
        self,
        ID: str,
        oneTimePaymentPlanEventInput: Dict[str, Any]
    ) -> WorkdayResponse:
        """Request a one-time payment for a worker with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)
            oneTimePaymentPlanEventInput:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/compensation/v2/workers/{ID}/requestOneTimePayment".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if oneTimePaymentPlanEventInput is not None:
            if isinstance(oneTimePaymentPlanEventInput, dict):
                body.update(oneTimePaymentPlanEventInput)
            else:
                body["oneTimePaymentPlanEventInput"] = oneTimePaymentPlanEventInput

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_compensation_v2_workers_request_one_time_payment {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_compensation_v2_scorecard_results_scores(
        self,
        ID: str,
        subresourceID: str,
        scoreInput: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates the Score for the specified Scorecard Result.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            scoreInput:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/compensation/v2/scorecardResults/{ID}/scores/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if scoreInput is not None:
            if isinstance(scoreInput, dict):
                body.update(scoreInput)
            else:
                body["scoreInput"] = scoreInput

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_compensation_v2_scorecard_results_scores {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_compensation_v2_scorecards(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves Compensation Scorecard information.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/compensation/v2/scorecards/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_compensation_v2_scorecards {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_compensation_v2_scorecards(
        self,
        ID: str,
        editScorecards: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates a Compensation Scorecard

        Args:
            ID: The Workday ID of the resource. (required)
            editScorecards:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/compensation/v2/scorecards/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if editScorecards is not None:
            if isinstance(editScorecards, dict):
                body.update(editScorecards)
            else:
                body["editScorecards"] = editScorecards

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_compensation_v2_scorecards {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_compensation_v2_scorecards(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Deletes a Compensation Scorecard with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/compensation/v2/scorecards/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_compensation_v2_scorecards {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_business_process_v1_event_steps_to_do(
        self,
        ID: str,
        businessProcessEventStepTodo: Dict[str, Any]
    ) -> WorkdayResponse:
        """Post an action for a To Do step in a business process.

        Args:
            ID: The Workday ID of the resource. (required)
            businessProcessEventStepTodo:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/eventSteps/{ID}/toDo".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if businessProcessEventStepTodo is not None:
            if isinstance(businessProcessEventStepTodo, dict):
                body.update(businessProcessEventStepTodo)
            else:
                body["businessProcessEventStepTodo"] = businessProcessEventStepTodo

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_business_process_v1_event_steps_to_do {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_business_process_v1_event_steps(
        self,
        businessProcess: Optional[List[str]] = None,
        createdOnOrAfter: Optional[str] = None,
        createdOnOrBefore: Optional[str] = None,
        dueDateOnOrAfter: Optional[str] = None,
        dueDateOnOrBefore: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        stepType: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """Retrieves business process event steps.

        Args:
            businessProcess:  (optional)
            createdOnOrAfter:  (optional)
            createdOnOrBefore:  (optional)
            dueDateOnOrAfter:  (optional)
            dueDateOnOrBefore:  (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            stepType:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/eventSteps"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if businessProcess is not None:
            params["businessProcess"] = businessProcess
        if createdOnOrAfter is not None:
            params["createdOnOrAfter"] = createdOnOrAfter
        if createdOnOrBefore is not None:
            params["createdOnOrBefore"] = createdOnOrBefore
        if dueDateOnOrAfter is not None:
            params["dueDateOnOrAfter"] = dueDateOnOrAfter
        if dueDateOnOrBefore is not None:
            params["dueDateOnOrBefore"] = dueDateOnOrBefore
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if stepType is not None:
            params["stepType"] = stepType

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_business_process_v1_event_steps {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_business_process_v1_events(
        self,
        businessProcess: Optional[List[str]] = None,
        completedOnOrAfter: Optional[str] = None,
        completedOnOrBefore: Optional[str] = None,
        initiatedOnOrAfter: Optional[str] = None,
        initiatedOnOrBefore: Optional[str] = None,
        initiator: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        status: Optional[List[str]] = None,
        worker: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves business process events.

        Args:
            businessProcess:  (optional)
            completedOnOrAfter:  (optional)
            completedOnOrBefore:  (optional)
            initiatedOnOrAfter:  (optional)
            initiatedOnOrBefore:  (optional)
            initiator:  (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            status:  (optional)
            worker:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/events"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if businessProcess is not None:
            params["businessProcess"] = businessProcess
        if completedOnOrAfter is not None:
            params["completedOnOrAfter"] = completedOnOrAfter
        if completedOnOrBefore is not None:
            params["completedOnOrBefore"] = completedOnOrBefore
        if initiatedOnOrAfter is not None:
            params["initiatedOnOrAfter"] = initiatedOnOrAfter
        if initiatedOnOrBefore is not None:
            params["initiatedOnOrBefore"] = initiatedOnOrBefore
        if initiator is not None:
            params["initiator"] = initiator
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if status is not None:
            params["status"] = status
        if worker is not None:
            params["worker"] = worker

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_business_process_v1_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_business_process_v1_events_completed_steps(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves completed steps for a business process event.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/events/{ID}/completedSteps".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_business_process_v1_events_completed_steps {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_business_process_v1_types(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves all business process types.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/types"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_business_process_v1_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_business_process_v1_events_attachments(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves attachments for a business process event.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/events/{ID}/attachments".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_business_process_v1_events_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_business_process_v1_events_rescind(
        self,
        ID: str,
        businessProcessEventAction: Dict[str, Any]
    ) -> WorkdayResponse:
        """Rescinds a business process event.

        Args:
            ID: The Workday ID of the resource. (required)
            businessProcessEventAction:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/events/{ID}/rescind".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if businessProcessEventAction is not None:
            if isinstance(businessProcessEventAction, dict):
                body.update(businessProcessEventAction)
            else:
                body["businessProcessEventAction"] = businessProcessEventAction

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_business_process_v1_events_rescind {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_business_process_v1_types(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a business process type.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/types/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_business_process_v1_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_business_process_v1_event_steps(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a business process event step.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/eventSteps/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_business_process_v1_event_steps {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_business_process_v1_events_comments(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves comments for a business process event.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/events/{ID}/comments".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_business_process_v1_events_comments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_business_process_v1_events_in_progress_steps(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves in progress steps for a business process event.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/events/{ID}/inProgressSteps".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_business_process_v1_events_in_progress_steps {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_business_process_v1_event_steps_deny(
        self,
        ID: str,
        businessProcessStepsDeny: Dict[str, Any]
    ) -> WorkdayResponse:
        """Denies a business process event step.

        Args:
            ID: The Workday ID of the resource. (required)
            businessProcessStepsDeny:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/eventSteps/{ID}/deny".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if businessProcessStepsDeny is not None:
            if isinstance(businessProcessStepsDeny, dict):
                body.update(businessProcessStepsDeny)
            else:
                body["businessProcessStepsDeny"] = businessProcessStepsDeny

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_business_process_v1_event_steps_deny {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_business_process_v1_values_send_back_to(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/values/sendBack/to/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_business_process_v1_values_send_back_to {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_business_process_v1_event_steps_questionnaire(
        self,
        ID: str,
        completeQuestionnaireEventStep: Dict[str, Any]
    ) -> WorkdayResponse:
        """Post an action for a Complete Questionnaire step in a business process.

        Args:
            ID: The Workday ID of the resource. (required)
            completeQuestionnaireEventStep:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/eventSteps/{ID}/questionnaire".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if completeQuestionnaireEventStep is not None:
            if isinstance(completeQuestionnaireEventStep, dict):
                body.update(completeQuestionnaireEventStep)
            else:
                body["completeQuestionnaireEventStep"] = completeQuestionnaireEventStep

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_business_process_v1_event_steps_questionnaire {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_business_process_v1_events_remaining_steps(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves remaining steps for a business process event.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/events/{ID}/remainingSteps".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_business_process_v1_events_remaining_steps {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_business_process_v1_events_cancel(
        self,
        ID: str,
        businessProcessEventAction: Dict[str, Any]
    ) -> WorkdayResponse:
        """Cancels a business process event.

        Args:
            ID: The Workday ID of the resource. (required)
            businessProcessEventAction:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/events/{ID}/cancel".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if businessProcessEventAction is not None:
            if isinstance(businessProcessEventAction, dict):
                body.update(businessProcessEventAction)
            else:
                body["businessProcessEventAction"] = businessProcessEventAction

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_business_process_v1_events_cancel {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_business_process_v1_types_attachment_categories(
        self,
        ID: str,
        eventTarget: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves attachment categories for a business process type.

        Args:
            ID: The Workday ID of the resource. (required)
            eventTarget: The Workday ID of the event target that this business process is about. You can use a returned id from an API that returns instances of the event target type. For example, if your event target is a worker, use GET /workers in the Staffing service. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/types/{ID}/attachmentCategories".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if eventTarget is not None:
            params["eventTarget"] = eventTarget
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_business_process_v1_types_attachment_categories {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_business_process_v1_events(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a business process event.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/events/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_business_process_v1_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_business_process_v1_event_steps_approve(
        self,
        ID: str,
        businessProcessStepsApprove: Dict[str, Any]
    ) -> WorkdayResponse:
        """Approves a business process event step.

        Args:
            ID: The Workday ID of the resource. (required)
            businessProcessStepsApprove:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/eventSteps/{ID}/approve".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if businessProcessStepsApprove is not None:
            if isinstance(businessProcessStepsApprove, dict):
                body.update(businessProcessStepsApprove)
            else:
                body["businessProcessStepsApprove"] = businessProcessStepsApprove

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_business_process_v1_event_steps_approve {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_business_process_v1_event_steps_send_back(
        self,
        ID: str,
        businessProcessStepSendBack: Dict[str, Any]
    ) -> WorkdayResponse:
        """Sends back a business process event step.

        Args:
            ID: The Workday ID of the resource. (required)
            businessProcessStepSendBack:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/businessProcess/v1/eventSteps/{ID}/sendBack".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if businessProcessStepSendBack is not None:
            if isinstance(businessProcessStepSendBack, dict):
                body.update(businessProcessStepSendBack)
            else:
                body["businessProcessStepSendBack"] = businessProcessStepSendBack

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_business_process_v1_event_steps_send_back {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_contract_compliance_v1_values_contract_compliance_group_companies_or_hierarchies(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/contractCompliance/v1/values/contractComplianceGroup/companiesOrHierarchies/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_contract_compliance_v1_values_contract_compliance_group_companies_or_hierarchies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_contract_compliance_v1_values_contract_compliance_group_contract_types(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/contractCompliance/v1/values/contractComplianceGroup/contractTypes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_contract_compliance_v1_values_contract_compliance_group_contract_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_contract_compliance_v1_supplier_contracts(
        self,
        companyOrHierarchy: Optional[List[str]] = None,
        contractSpecialist: Optional[str] = None,
        contractType: Optional[List[str]] = None,
        endDateOnOrAfter: Optional[str] = None,
        endDateOnOrBefore: Optional[str] = None,
        externalReferenceID: Optional[str] = None,
        externalSystemReference: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        onHold: Optional[bool] = None,
        startDateOnOrAfter: Optional[str] = None,
        startDateOnOrBefore: Optional[str] = None,
        status: Optional[List[str]] = None,
        supplier: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """Retrieves all supplier contracts.

        Args:
            companyOrHierarchy: Filters the contracts by company or company hierarchy. Specify the Workday ID of the company or company hierarchy. (optional)
            contractSpecialist: Filters the contracts by the supplier contract specialist. Specify the Workday ID or reference ID of the specialist on the contract. (optional)
            contractType: Filters the contracts by type. Specify the Workday ID of the contract type. (optional)
            endDateOnOrAfter: Filters the contracts with an end date on or after the specified date. Use the yyyy-mm-dd format. (optional)
            endDateOnOrBefore: Filters the contracts with an end date on or before the specified date. Use the yyyy-mm-dd format. (optional)
            externalReferenceID: Filters the contracts by the External Reference ID (optional)
            externalSystemReference: Filters the contracts with the external system reference ID. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            onHold: Filters the contracts that are on hold. (optional)
            startDateOnOrAfter: Filters the contracts with a start date on or after the specified date. Use the yyyy-mm-dd format. (optional)
            startDateOnOrBefore: Filters the contracts with a start date on or before the specified date. Use the yyyy-mm-dd format. (optional)
            status: Filters the contracts by status. Specify the Workday ID of the status. (optional)
            supplier: Filters the contracts by the supplier. Specify the Workday ID of the supplier. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/contractCompliance/v1/supplierContracts"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if companyOrHierarchy is not None:
            params["companyOrHierarchy"] = companyOrHierarchy
        if contractSpecialist is not None:
            params["contractSpecialist"] = contractSpecialist
        if contractType is not None:
            params["contractType"] = contractType
        if endDateOnOrAfter is not None:
            params["endDateOnOrAfter"] = endDateOnOrAfter
        if endDateOnOrBefore is not None:
            params["endDateOnOrBefore"] = endDateOnOrBefore
        if externalReferenceID is not None:
            params["externalReferenceID"] = externalReferenceID
        if externalSystemReference is not None:
            params["externalSystemReference"] = externalSystemReference
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if onHold is not None:
            params["onHold"] = onHold
        if startDateOnOrAfter is not None:
            params["startDateOnOrAfter"] = startDateOnOrAfter
        if startDateOnOrBefore is not None:
            params["startDateOnOrBefore"] = startDateOnOrBefore
        if status is not None:
            params["status"] = status
        if supplier is not None:
            params["supplier"] = supplier

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_contract_compliance_v1_supplier_contracts {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_contract_compliance_v1_supplier_contracts(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a supplier contract.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/contractCompliance/v1/supplierContracts/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_contract_compliance_v1_supplier_contracts {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_absence_management_v3_workers_leaves_of_absence(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the leave of absence for the specified worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/absenceManagement/v3/workers/{ID}/leavesOfAbsence/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_absence_management_v3_workers_leaves_of_absence {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_absence_management_v3_values_leave_status(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/absenceManagement/v3/values/leave/status/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_absence_management_v3_values_leave_status {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_absence_management_v3_balances(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves the specified balance of all absence plan and leave of absence types.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/absenceManagement/v3/balances/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_absence_management_v3_balances {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_absence_management_v3_values_time_off_status(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/absenceManagement/v3/values/timeOff/status/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_absence_management_v3_values_time_off_status {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_absence_management_v3_workers_eligible_absence_types(
        self,
        ID: str,
        category: Optional[str] = None,
        effective: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of eligible absence types for the specified worker.

        Args:
            ID: The Workday ID of the resource. (required)
            category: The Workday ID of the absence type category. Valid values:
* Leave of Absence Type: 17bd6531c90c100016d74f8dfae007d0

* Absence Table: 17bd6531c90c100016da3f5b554007d2

* Time Off: 17bd6531c90c100016d4b06f2b8a07ce (optional)
            effective: The effective date for which eligible absence types need to be returned for the worker. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/absenceManagement/v3/workers/{ID}/eligibleAbsenceTypes".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if category is not None:
            params["category"] = category
        if effective is not None:
            params["effective"] = effective
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_absence_management_v3_workers_eligible_absence_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_absence_management_v3_workers_leaves_of_absence(
        self,
        ID: str,
        fromDate: Optional[str] = None,
        leaveType: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        status: Optional[List[str]] = None,
        toDate: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves the Leaves Of Absence for a specified worker ID.

        Args:
            ID: The Workday ID of the resource. (required)
            fromDate: The start of a date range filter using the yyyy-mm-dd format. (optional)
            leaveType: The Workday ID of the type of leave of absence. You can specify multiple leaveType query parameters. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            status: The Workday ID of the status of the leave of absence. The valid statuses are Successfully Completed, In Progress, Canceled, Rescinded, and Process Terminated. To get valid values, call the GET /values/leave/status endpoint. You can specify multiple status query parameters. (optional)
            toDate: The end of a date range filter using the yyyy-mm-dd format. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/absenceManagement/v3/workers/{ID}/leavesOfAbsence".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if fromDate is not None:
            params["fromDate"] = fromDate
        if leaveType is not None:
            params["leaveType"] = leaveType
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if status is not None:
            params["status"] = status
        if toDate is not None:
            params["toDate"] = toDate

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_absence_management_v3_workers_leaves_of_absence {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_absence_management_v3_balances(
        self,
        category: Optional[str] = None,
        effective: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        worker: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves the balance of all absence plan and leave of absence type for the specified worker ID.

        Args:
            category: The Workday ID of the time off, leave type, or absence table. (optional)
            effective: The absence balances as of the specified date using the yyyy-mm-dd format. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            worker: The Workday ID of the worker for which balances are returned. This is a required query parameter. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/absenceManagement/v3/balances"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if category is not None:
            params["category"] = category
        if effective is not None:
            params["effective"] = effective
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if worker is not None:
            params["worker"] = worker

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_absence_management_v3_balances {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_absence_management_v3_workers_request_time_off(
        self,
        ID: str,
        timeOffRequestEventView: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a time off request for the specified worker ID and initiates the business process.

        Args:
            ID: The Workday ID of the resource. (required)
            timeOffRequestEventView:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/absenceManagement/v3/workers/{ID}/requestTimeOff".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if timeOffRequestEventView is not None:
            if isinstance(timeOffRequestEventView, dict):
                body.update(timeOffRequestEventView)
            else:
                body["timeOffRequestEventView"] = timeOffRequestEventView

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_absence_management_v3_workers_request_time_off {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_absence_management_v3_workers(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a collection of workers and current staffing information.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/absenceManagement/v3/workers/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_absence_management_v3_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_absence_management_v3_workers_time_off_details(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves details of a specified time off entry for a specified worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/absenceManagement/v3/workers/{ID}/timeOffDetails/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_absence_management_v3_workers_time_off_details {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_absence_management_v3_workers_time_off_details(
        self,
        ID: str,
        fromDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        status: Optional[List[str]] = None,
        timeOffType: Optional[List[str]] = None,
        toDate: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of time off details for a specified worker.

        Args:
            ID: The Workday ID of the resource. (required)
            fromDate: The start of a date range filter using the yyyy-mm-dd format. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            status: The Workday ID of the time off status. You can specify multiple status query parameters. This method returns the most recent instance of a time off entry based on this query parameter.

The valid statuses are Approved, Submitted, Not Submitted, and Sent Back. This method does not return Canceled and Denied Time Off Entries. To get the Workday ID of a status, call the GET /values/timeOff/status endpoint. You can specify multiple status query parameters.

Example:
An approved Time Off Entry for Vacation 8 hours was corrected to Vacation 4 hours and is not in submitted status. If the query parameter is status = approved, the Time Off Entry of Vacation, 8 hours, Approved is returned. If query parameter status = submitted, the Time Off Entry of Vacation, 4 hours, Submitted is returned. If no query parameter is passed, the Time Off Entry of Vacation, 4 hours, Submitted is returned. (optional)
            timeOffType: The Workday ID of the Time Off Type. You can specify multiple timeOffType query parameters. (optional)
            toDate: The end of a date range filter using the yyyy-mm-dd format. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/absenceManagement/v3/workers/{ID}/timeOffDetails".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if fromDate is not None:
            params["fromDate"] = fromDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if status is not None:
            params["status"] = status
        if timeOffType is not None:
            params["timeOffType"] = timeOffType
        if toDate is not None:
            params["toDate"] = toDate

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_absence_management_v3_workers_time_off_details {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_absence_management_v3_workers_valid_time_off_dates(
        self,
        ID: str,
        date: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        position: Optional[str] = None,
        timeOff: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves the valid time off dates for the specified worker ID for the given dates.

        Args:
            ID: The Workday ID of the resource. (required)
            date: The dates being requested for which to validate. It should be in the yyyy-mm-dd format. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            position: The Workday ID of the position. (optional)
            timeOff: The Workday ID of the time off. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/absenceManagement/v3/workers/{ID}/validTimeOffDates".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if date is not None:
            params["date"] = date
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if position is not None:
            params["position"] = position
        if timeOff is not None:
            params["timeOff"] = timeOff

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_absence_management_v3_workers_valid_time_off_dates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_absence_management_v3_workers(
        self,
        includeTerminatedWorkers: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        search: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of workers and current staffing information.

        Args:
            includeTerminatedWorkers: Include terminated workers in the output (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            search: Searches workers by name or worker ID. The search is case-insensitive. You can include space-delimited search strings for an OR search. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/absenceManagement/v3/workers"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if includeTerminatedWorkers is not None:
            params["includeTerminatedWorkers"] = includeTerminatedWorkers
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if search is not None:
            params["search"] = search

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_absence_management_v3_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_absence_management_v3_workers_eligible_absence_types(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the eligible absence type for the specified worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/absenceManagement/v3/workers/{ID}/eligibleAbsenceTypes/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_absence_management_v3_workers_eligible_absence_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_accounts_payable_v1_supplier_invoice_requests_submit(
        self,
        ID: str,
        submitSupplierInvoiceRequest: Dict[str, Any]
    ) -> WorkdayResponse:
        """Submits a single supplier invoice instance.

        Args:
            ID: The Workday ID of the resource. (required)
            submitSupplierInvoiceRequest:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/accountsPayable/v1/supplierInvoiceRequests/{ID}/submit".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if submitSupplierInvoiceRequest is not None:
            if isinstance(submitSupplierInvoiceRequest, dict):
                body.update(submitSupplierInvoiceRequest)
            else:
                body["submitSupplierInvoiceRequest"] = submitSupplierInvoiceRequest

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_accounts_payable_v1_supplier_invoice_requests_submit {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_accounts_payable_v1_supplier_invoice_requests_attachments(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/accountsPayable/v1/supplierInvoiceRequests/{ID}/attachments/{subresourceID}?type=viewContent".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_accounts_payable_v1_supplier_invoice_requests_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_accounts_payable_v1_supplier_invoice_requests(
        self,
        company: Optional[List[str]] = None,
        fromDueDate: Optional[str] = None,
        fromInvoiceDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        requester: Optional[List[str]] = None,
        status: Optional[List[str]] = None,
        supplier: Optional[List[str]] = None,
        toDueDate: Optional[str] = None,
        toInvoiceDate: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of supplier invoices.

        Args:
            company: The company for the Common Financial Dimensions. This is for internal use only on a REST API. (optional)
            fromDueDate: The  beginning date of the payment due period for this supplier invoice request. Use the MM/DD/YYYY format. Example: When the payment term is Net 30, the due date value is the day from this invoice date. (optional)
            fromInvoiceDate: The date on or after which the supplier invoice is created using the MM/DD/YYYY format. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            requester: The ID of the worker generating the supplier invoice request. (optional)
            status: The status of the supplier invoice request. This is for internal use only on a REST API. (optional)
            supplier: The supplier on the business documents. (optional)
            toDueDate: The end date of the payment due period for this supplier invoice request. Use the MM/DD/YYYY format. Example: When the payment term is Net 30, the due date value is 30 days from the invoice date. (optional)
            toInvoiceDate: The date on or before which the supplier invoice is created using the MM/DD/YYYY format. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/accountsPayable/v1/supplierInvoiceRequests"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if company is not None:
            params["company"] = company
        if fromDueDate is not None:
            params["fromDueDate"] = fromDueDate
        if fromInvoiceDate is not None:
            params["fromInvoiceDate"] = fromInvoiceDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if requester is not None:
            params["requester"] = requester
        if status is not None:
            params["status"] = status
        if supplier is not None:
            params["supplier"] = supplier
        if toDueDate is not None:
            params["toDueDate"] = toDueDate
        if toInvoiceDate is not None:
            params["toInvoiceDate"] = toInvoiceDate

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_accounts_payable_v1_supplier_invoice_requests {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_accounts_payable_v1_supplier_invoice_requests(
        self,
        createInvoiceRequestSummary: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates the supplier invoice as specified in the request.

        Args:
            createInvoiceRequestSummary:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/accountsPayable/v1/supplierInvoiceRequests"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if createInvoiceRequestSummary is not None:
            if isinstance(createInvoiceRequestSummary, dict):
                body.update(createInvoiceRequestSummary)
            else:
                body["createInvoiceRequestSummary"] = createInvoiceRequestSummary

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_accounts_payable_v1_supplier_invoice_requests {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_accounts_payable_v1_supplier_invoice_requests_attachments_1(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single attachment instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/accountsPayable/v1/supplierInvoiceRequests/{ID}/attachments/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_accounts_payable_v1_supplier_invoice_requests_attachments_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_accounts_payable_v1_supplier_invoice_requests_attachments(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/accountsPayable/v1/supplierInvoiceRequests/{ID}/attachments?type=viewContent".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_accounts_payable_v1_supplier_invoice_requests_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_accounts_payable_v1_send_supplier_invoice_attachments_for_scanning(
        self,
        ocrSupplierInvoicesContainerRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Sends supplier invoice attachments for scanning.

        Args:
            ocrSupplierInvoicesContainerRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/accountsPayable/v1/sendSupplierInvoiceAttachmentsForScanning"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if ocrSupplierInvoicesContainerRepresentation is not None:
            if isinstance(ocrSupplierInvoicesContainerRepresentation, dict):
                body.update(ocrSupplierInvoicesContainerRepresentation)
            else:
                body["ocrSupplierInvoicesContainerRepresentation"] = ocrSupplierInvoicesContainerRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_accounts_payable_v1_send_supplier_invoice_attachments_for_scanning {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_accounts_payable_v1_supplier_invoice_requests_lines(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of supplier invoice lines.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/accountsPayable/v1/supplierInvoiceRequests/{ID}/lines".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_accounts_payable_v1_supplier_invoice_requests_lines {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_accounts_payable_v1_supplier_invoice_requests(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single supplier invoice instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/accountsPayable/v1/supplierInvoiceRequests/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_accounts_payable_v1_supplier_invoice_requests {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_accounts_payable_v1_supplier_invoice_requests_attachments_1(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of attachments for the specified supplier invoice.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/accountsPayable/v1/supplierInvoiceRequests/{ID}/attachments".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_accounts_payable_v1_supplier_invoice_requests_attachments_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_accounts_payable_v1_supplier_invoice_requests_attachments(
        self,
        ID: str,
        createAttachmentSummary: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a new attachment for the supplier invoice.

        Args:
            ID: The Workday ID of the resource. (required)
            createAttachmentSummary:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/accountsPayable/v1/supplierInvoiceRequests/{ID}/attachments".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if createAttachmentSummary is not None:
            if isinstance(createAttachmentSummary, dict):
                body.update(createAttachmentSummary)
            else:
                body["createAttachmentSummary"] = createAttachmentSummary

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_accounts_payable_v1_supplier_invoice_requests_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_accounts_payable_v1_supplier_invoice_requests_lines(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single supplier invoice line instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/accountsPayable/v1/supplierInvoiceRequests/{ID}/lines/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_accounts_payable_v1_supplier_invoice_requests_lines {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_job_change_reasons(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of job change reasons.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/jobChangeReasons"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_job_change_reasons {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_organizations(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        organizationType: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of organizations.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            organizationType: Reference to an Organization Type. Example: Organization Type WID. Requests must provide an Organization Type. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/organizations"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if organizationType is not None:
            params["organizationType"] = organizationType

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_organizations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_workers_time_off_plans(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a particular time off plan for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/timeOffPlans/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_workers_time_off_plans {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_business_title_changes(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a business title change instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/businessTitleChanges/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_business_title_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_workers_business_title_changes(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a business title change instance for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/businessTitleChanges/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_workers_business_title_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_api_common_v1_workers_business_title_changes(
        self,
        ID: str,
        businessTitleChangeInput: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            businessTitleChangeInput:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/businessTitleChanges?type=me".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if businessTitleChangeInput is not None:
            if isinstance(businessTitleChangeInput, dict):
                body.update(businessTitleChangeInput)
            else:
                body["businessTitleChangeInput"] = businessTitleChangeInput

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_api_common_v1_workers_business_title_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_currencies(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a currency instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/currencies/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_currencies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_workers_inbox_tasks(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of inbox tasks for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/inboxTasks".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_workers_inbox_tasks {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_customers(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a customer instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/customers/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_customers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_currencies(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of currencies.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/currencies"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_currencies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_organization_types(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of organization types.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/organizationTypes"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_organization_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_workers_organizations(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves an organization instance for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/organizations/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_workers_organizations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_workers_history(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of history items for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/history".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_workers_history {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_workers(
        self,
        includeTerminatedWorkers: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        search: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of workers.

        Args:
            includeTerminatedWorkers: Include terminated workers in the output (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            search:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if includeTerminatedWorkers is not None:
            params["includeTerminatedWorkers"] = includeTerminatedWorkers
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if search is not None:
            params["search"] = search

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_workers_history(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a history instance for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/history/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_workers_history {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_workers_organizations(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of organizations for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/organizations".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_workers_organizations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_workers_supervisory_organizations_managed(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of supervisory organizations managed by a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/supervisoryOrganizationsManaged".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_workers_supervisory_organizations_managed {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_workers_time_off_entries(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a time off entry for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/timeOffEntries/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_workers_time_off_entries {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_api_common_v1_workers_job_changes(
        self,
        ID: str,
        changeJobInput: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a job change instance with the specified data.

        Args:
            ID: The Workday ID of the resource. (required)
            changeJobInput:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/jobChanges".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if changeJobInput is not None:
            if isinstance(changeJobInput, dict):
                body.update(changeJobInput)
            else:
                body["changeJobInput"] = changeJobInput

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_api_common_v1_workers_job_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_workers_pay_slips(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of pay slips for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/paySlips".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_workers_pay_slips {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_api_common_v1_validate_worktags(
        self,
        validateWorktagInput: Dict[str, Any]
    ) -> WorkdayResponse:
        """(End of Life Date: 2025-08-03 ) Validates allowed and required worktag types and worktag combinations so that you can correct errors before you submit transactions.

        Args:
            validateWorktagInput:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/validateWorktags"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if validateWorktagInput is not None:
            if isinstance(validateWorktagInput, dict):
                body.update(validateWorktagInput)
            else:
                body["validateWorktagInput"] = validateWorktagInput

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_api_common_v1_validate_worktags {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_workers_direct_reports(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of direct reports for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/directReports".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_workers_direct_reports {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_job_change_reasons(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a job change reason instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/jobChangeReasons/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_job_change_reasons {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_supervisory_organizations(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of supervisory organizations.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/supervisoryOrganizations"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_supervisory_organizations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_workers_pay_slips(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a pay slip instance for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/paySlips/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_workers_pay_slips {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_supervisory_organizations(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a supervisory organization instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/supervisoryOrganizations/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_supervisory_organizations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_customers_activities(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves an activity instance for a specific customer.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/customers/{ID}/activities/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_customers_activities {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_workers_inbox_tasks(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves an inbox task instance for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/inboxTasks/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_workers_inbox_tasks {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_supervisory_organizations_workers(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a worker instance for a specific supervisory organization.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/supervisoryOrganizations/{ID}/workers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_supervisory_organizations_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_workers_direct_reports(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a direct report instance for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/directReports/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_workers_direct_reports {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_workers_time_off_plans(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of time off plans for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/timeOffPlans".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_workers_time_off_plans {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_supervisory_organizations_workers(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of workers for a specific supervisory organization.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/supervisoryOrganizations/{ID}/workers".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_supervisory_organizations_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_workers_business_title_changes(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of business title changes for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/businessTitleChanges".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_workers_business_title_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_api_common_v1_workers_business_title_changes_1(
        self,
        ID: str,
        businessTitleChangeInput: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a business title change instance with the specified data.

        Args:
            ID: The Workday ID of the resource. (required)
            businessTitleChangeInput:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/businessTitleChanges".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if businessTitleChangeInput is not None:
            if isinstance(businessTitleChangeInput, dict):
                body.update(businessTitleChangeInput)
            else:
                body["businessTitleChangeInput"] = businessTitleChangeInput

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_api_common_v1_workers_business_title_changes_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_organizations(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves an organization instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/organizations/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_organizations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_workers(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a worker instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_customers_activities(
        self,
        ID: str,
        fromDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        toDate: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of activities for a specific customer.

        Args:
            ID: The Workday ID of the resource. (required)
            fromDate:  (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            toDate:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/customers/{ID}/activities".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if fromDate is not None:
            params["fromDate"] = fromDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if toDate is not None:
            params["toDate"] = toDate

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_customers_activities {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_workers_supervisory_organizations_managed(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a supervisory organization managed by a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/supervisoryOrganizationsManaged/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_workers_supervisory_organizations_managed {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_api_common_v1_workers_time_off_entries(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of time off entries for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/workers/{ID}/timeOffEntries".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_api_common_v1_workers_time_off_entries {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_api_common_v1_organization_types(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves an organization type instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/api/common/v1/organizationTypes/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_api_common_v1_organization_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_custom_object_v2_custom_objects(
        self,
        businessObjectResource: str,
        businessObjectId: str,
        customObjectAlias: str
    ) -> WorkdayResponse:
        """Retrieves a collection of multi-instance custom objects.

        Args:
            businessObjectResource: Path parameter businessObjectResource (required)
            businessObjectId: Path parameter businessObjectId (required)
            customObjectAlias: Path parameter customObjectAlias (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObject/v2/{businessObjectResource}/{businessObjectId}/customObjects/{customObjectAlias}".replace("{businessObjectResource}", str(businessObjectResource)).replace("{businessObjectId}", str(businessObjectId)).replace("{customObjectAlias}", str(customObjectAlias))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_custom_object_v2_custom_objects {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_custom_object_v2_custom_objects(
        self,
        customObjectRequestBody: Dict[str, Any],
        customObjectAlias: str,
        updateIfExists: Optional[bool] = None,
        bulk: Optional[bool] = None
    ) -> WorkdayResponse:
        """Creates instances of multi-instance custom objects.

        Args:
            customObjectRequestBody: The custom object instance to be persisted. If bulk=true, specify an array containing the custom object instances, with a maximum of 100. If bulk=false (default), specify a JSON object. (required)
            customObjectAlias: Path parameter customObjectAlias (required)
            updateIfExists: If true, updates the custom object instance if it exists. If false, returns an error if the object exists. The default is false. If the object does not exist, a new object is created regardless of this setting. (optional)
            bulk: If true, creates or updates the specified array of custom object instances in the request body. If false, specify a single object (without an array). The default is false.  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObject/v2/customObjects/{customObjectAlias}".replace("{customObjectAlias}", str(customObjectAlias))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if customObjectRequestBody is not None:
            if isinstance(customObjectRequestBody, dict):
                body.update(customObjectRequestBody)
            else:
                body["customObjectRequestBody"] = customObjectRequestBody
        if updateIfExists is not None:
            params["updateIfExists"] = updateIfExists
        if bulk is not None:
            params["bulk"] = bulk

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_custom_object_v2_custom_objects {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_custom_object_v2_custom_objects_1(
        self,
        customObjectAlias: str,
        customObjectID: str
    ) -> WorkdayResponse:
        """Get a specific instance of a multi-instance custom object

        Args:
            customObjectAlias: Path parameter customObjectAlias (required)
            customObjectID: Path parameter customObjectID (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObject/v2/customObjects/{customObjectAlias}/{customObjectID}".replace("{customObjectAlias}", str(customObjectAlias)).replace("{customObjectID}", str(customObjectID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_custom_object_v2_custom_objects_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_custom_object_v2_custom_objects(
        self,
        customObjectRequestBody: Dict[str, Any],
        customObjectAlias: str,
        customObjectID: str
    ) -> WorkdayResponse:
        """Updates an instance of a multi-instance custom object.

        Args:
            customObjectRequestBody: The custom object fields to be updated. (required)
            customObjectAlias: Path parameter customObjectAlias (required)
            customObjectID: Path parameter customObjectID (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObject/v2/customObjects/{customObjectAlias}/{customObjectID}".replace("{customObjectAlias}", str(customObjectAlias)).replace("{customObjectID}", str(customObjectID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if customObjectRequestBody is not None:
            if isinstance(customObjectRequestBody, dict):
                body.update(customObjectRequestBody)
            else:
                body["customObjectRequestBody"] = customObjectRequestBody

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_custom_object_v2_custom_objects {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_custom_object_v2_custom_objects(
        self,
        customObjectAlias: str,
        customObjectID: str
    ) -> WorkdayResponse:
        """Deletes an instance of a custom object.

        Args:
            customObjectAlias: Path parameter customObjectAlias (required)
            customObjectID: Path parameter customObjectID (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObject/v2/customObjects/{customObjectAlias}/{customObjectID}".replace("{customObjectAlias}", str(customObjectAlias)).replace("{customObjectID}", str(customObjectID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_custom_object_v2_custom_objects {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_core_accounting_v1_currencies(
        self
    ) -> WorkdayResponse:
        """Retrieves the details on all currencies in your tenant.

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/coreAccounting/v1/currencies"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_core_accounting_v1_currencies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_core_accounting_v1_currencies(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves the details of a specified currency.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/coreAccounting/v1/currencies/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_core_accounting_v1_currencies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_core_accounting_v1_evaluate_account_posting_rules(
        self,
        accountPostingRuleSet: Optional[str] = None,
        accountPostingRuleType: Optional[str] = None,
        dimensionValue: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """Retrieves the ledger account and resulting worktags of a specified account posting rule.

        Args:
            accountPostingRuleSet: (Required) The Workday ID or reference ID for the account posting rule set. The reference ID uses the accountPostingRuleSet=sampleRefIdType=value format. Example: accountPostingRuleSet=Account_Posting_Rule_Set_ID=ACCOUNT_POSTING_RULE_SET-1 (optional)
            accountPostingRuleType: (Required) The Workday ID or reference ID for the account posting rule type. The reference ID uses the accountPostingRuleType=sampleRefIdType=value format. Example: accountPostingRuleType=Account_Posting_Rule_Type_ID=CASH (optional)
            dimensionValue: The Workday IDs or reference IDs for the dimension value of the account posting rule condition. The reference ID uses the dimensionValue=sampleRefIdType=value format format. Example: dimensionValue=Fund_ID=F03.1.3. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/coreAccounting/v1/evaluateAccountPostingRules"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if accountPostingRuleSet is not None:
            params["accountPostingRuleSet"] = accountPostingRuleSet
        if accountPostingRuleType is not None:
            params["accountPostingRuleType"] = accountPostingRuleType
        if dimensionValue is not None:
            params["dimensionValue"] = dimensionValue

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_core_accounting_v1_evaluate_account_posting_rules {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_custom_object_v2_custom_objects_1(
        self,
        customObjectRequestBody: Dict[str, Any],
        customObjectAlias: str,
        updateIfExists: Optional[bool] = None,
        bulk: Optional[bool] = None
    ) -> WorkdayResponse:
        """Create a new, or update an existing instance of a custom object.

        Args:
            customObjectRequestBody: The custom object instance to be persisted. If bulk=true, specify a JSON array containing the custom object instances, with a maximum of 100. If bulk=false (default), specify a JSON object. (required)
            customObjectAlias: Path parameter customObjectAlias (required)
            updateIfExists: If true, updates the custom object instance if it exists. If false, returns an error if the object exists. The default is false. If the object does not exist, a new object is created regardless of this setting. (optional)
            bulk: If true, creates or updates the specified array of custom object instances in the request body. If false, creates the specified custom object instance (without an array). The default is false.  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObject/v2/customObjects/{customObjectAlias}".replace("{customObjectAlias}", str(customObjectAlias))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if customObjectRequestBody is not None:
            if isinstance(customObjectRequestBody, dict):
                body.update(customObjectRequestBody)
            else:
                body["customObjectRequestBody"] = customObjectRequestBody
        if updateIfExists is not None:
            params["updateIfExists"] = updateIfExists
        if bulk is not None:
            params["bulk"] = bulk

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_custom_object_v2_custom_objects_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_custom_object_v2_custom_objects_2(
        self,
        customObjectAlias: str,
        customObjectID: str
    ) -> WorkdayResponse:
        """Retrieves a custom object instance.

        Args:
            customObjectAlias: Path parameter customObjectAlias (required)
            customObjectID: Path parameter customObjectID (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObject/v2/customObjects/{customObjectAlias}/{customObjectID}".replace("{customObjectAlias}", str(customObjectAlias)).replace("{customObjectID}", str(customObjectID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_custom_object_v2_custom_objects_2 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_custom_object_v2_custom_objects_1(
        self,
        customObjectRequestBody: Dict[str, Any],
        customObjectAlias: str,
        customObjectID: str
    ) -> WorkdayResponse:
        """Updates  a custom object instance.

        Args:
            customObjectRequestBody: The custom object fields to be updated. (required)
            customObjectAlias: Path parameter customObjectAlias (required)
            customObjectID: Path parameter customObjectID (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObject/v2/customObjects/{customObjectAlias}/{customObjectID}".replace("{customObjectAlias}", str(customObjectAlias)).replace("{customObjectID}", str(customObjectID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if customObjectRequestBody is not None:
            if isinstance(customObjectRequestBody, dict):
                body.update(customObjectRequestBody)
            else:
                body["customObjectRequestBody"] = customObjectRequestBody

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_custom_object_v2_custom_objects_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_custom_object_v2_custom_objects_1(
        self,
        customObjectAlias: str,
        customObjectID: str
    ) -> WorkdayResponse:
        """Deletes a custom object instance.

        Args:
            customObjectAlias: Path parameter customObjectAlias (required)
            customObjectID: Path parameter customObjectID (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObject/v2/customObjects/{customObjectAlias}/{customObjectID}".replace("{customObjectAlias}", str(customObjectAlias)).replace("{customObjectID}", str(customObjectID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_custom_object_v2_custom_objects_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_fin_tax_public_v1_electronic_reporting_runs(
        self,
        electronicReportingRuns: Dict[str, Any]
    ) -> WorkdayResponse:
        """The Electronic Reporting service enables applications to create information on electronic reporting of customer and supplier invoice documents.

        Args:
            electronicReportingRuns:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/finTaxPublic/v1/electronicReportingRuns"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if electronicReportingRuns is not None:
            if isinstance(electronicReportingRuns, dict):
                body.update(electronicReportingRuns)
            else:
                body["electronicReportingRuns"] = electronicReportingRuns

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_fin_tax_public_v1_electronic_reporting_runs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_customer_accounts_v1_payments_remittance_details(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single customer invoice payment remittance line instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customerAccounts/v1/payments/{ID}/remittanceDetails/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_customer_accounts_v1_payments_remittance_details {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_customer_accounts_v1_customers(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single customer instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customerAccounts/v1/customers/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_customer_accounts_v1_customers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_customer_accounts_v1_payments(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single customer invoice payment instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customerAccounts/v1/payments/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_customer_accounts_v1_payments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_customer_accounts_v1_invoices(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single customer invoice or adjustment instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customerAccounts/v1/invoices/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_customer_accounts_v1_invoices {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_customer_accounts_v1_invoice_pd_fs(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single customer invoice PDF instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customerAccounts/v1/invoicePDFs/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_customer_accounts_v1_invoice_pd_fs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_customer_accounts_v1_payments(
        self,
        createCustomerPayment: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates customer invoice payments.

        Args:
            createCustomerPayment:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customerAccounts/v1/payments"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if createCustomerPayment is not None:
            if isinstance(createCustomerPayment, dict):
                body.update(createCustomerPayment)
            else:
                body["createCustomerPayment"] = createCustomerPayment

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_customer_accounts_v1_payments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_customer_accounts_v1_invoices(
        self,
        billToCustomer: Optional[List[str]] = None,
        company: Optional[List[str]] = None,
        fromDueDate: Optional[str] = None,
        fromInvoiceDate: Optional[str] = None,
        invoiceStatus: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        paymentStatus: Optional[List[str]] = None,
        toDueDate: Optional[str] = None,
        toInvoiceDate: Optional[str] = None,
        transactionType: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of customer invoices and adjustments.

        Args:
            billToCustomer: The customer on the invoice. (optional)
            company:  (optional)
            fromDueDate: The due date of the customer invoice or invoice adjustment as of the defined reporting date, formatted as YYYY-MM-DD. (optional)
            fromInvoiceDate: The date of the customer invoice, formatted as YYYY-MM-DD. (optional)
            invoiceStatus: The current status of an invoice document.

Include invoices with these invoice statuses:
Approved (91b0d382d50848e898733757caa9f84a),
Canceled (dc76c9b6446c11de98360015c5e6daf6),
Denied (dc76c7cc446c11de98360015c5e6daf6),
Draft (dc76c4fc446c11de98360015c5e6daf6),
Incomplete(e264bc68581342baa70ab61bf71032fe),
In Progress (dc76c8bc446c11de98360015c5e6daf6). (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            paymentStatus: The payment status of an invoice document.

Include invoices with these payments statuses:
Paid (d9e4362a446c11de98360015c5e6daf6),
Unpaid (d9e43940446c11de98360015c5e6daf6),
Partially Paid (d9e43706446c11de98360015c5e6daf6). (optional)
            toDueDate: The due date of the customer invoice or invoice adjustment as of the defined reporting date, formatted as YYYY-MM-DD. (optional)
            toInvoiceDate: The date of the customer invoice, formatted as YYYY-MM-DD. (optional)
            transactionType: The transaction type of this customer transaction. Use the string \"invoice\" or \"adjustment\" to filter to retrieve either only invoices or adjustments. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customerAccounts/v1/invoices"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if billToCustomer is not None:
            params["billToCustomer"] = billToCustomer
        if company is not None:
            params["company"] = company
        if fromDueDate is not None:
            params["fromDueDate"] = fromDueDate
        if fromInvoiceDate is not None:
            params["fromInvoiceDate"] = fromInvoiceDate
        if invoiceStatus is not None:
            params["invoiceStatus"] = invoiceStatus
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if paymentStatus is not None:
            params["paymentStatus"] = paymentStatus
        if toDueDate is not None:
            params["toDueDate"] = toDueDate
        if toInvoiceDate is not None:
            params["toInvoiceDate"] = toInvoiceDate
        if transactionType is not None:
            params["transactionType"] = transactionType

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_customer_accounts_v1_invoices {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_customer_accounts_v1_invoices_print_runs(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single customer invoice print run.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customerAccounts/v1/invoices/{ID}/printRuns/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_customer_accounts_v1_invoices_print_runs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_customer_accounts_v1_invoices_print_runs(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of customer invoice print runs for the specified customer invoice or adjustment.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customerAccounts/v1/invoices/{ID}/printRuns".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_customer_accounts_v1_invoices_print_runs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_customer_accounts_v1_customers(
        self,
        limit: Optional[int] = None,
        name: Optional[str] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of customers.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            name:  (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customerAccounts/v1/customers"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if name is not None:
            params["name"] = name
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_customer_accounts_v1_customers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_customer_accounts_v1_payments_remittance_details(
        self,
        ID: str,
        createRemittanceDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates customer invoice payment remittance lines.

        Args:
            ID: The Workday ID of the resource. (required)
            createRemittanceDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customerAccounts/v1/payments/{ID}/remittanceDetails".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if createRemittanceDetails is not None:
            if isinstance(createRemittanceDetails, dict):
                body.update(createRemittanceDetails)
            else:
                body["createRemittanceDetails"] = createRemittanceDetails

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_customer_accounts_v1_payments_remittance_details {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_graph_v1_versions(
        self,
        includeTest: Optional[bool] = None
    ) -> WorkdayResponse:
        """Retrieves all supported Graph API versions.

        Args:
            includeTest: For Internal Use Only (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/graph/v1/versions"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if includeTest is not None:
            params["includeTest"] = includeTest

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_graph_v1_versions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_graph_v1_versions(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves all supported Graph API versions.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/graph/v1/versions/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_graph_v1_versions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_expense_v1_values_bespoke_prompt_expense_group(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/values/bespokePrompt/expenseGroup/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_expense_v1_values_bespoke_prompt_expense_group {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_expense_v1_expense_items(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single instance of an expense item.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/expenseItems/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_expense_v1_expense_items {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_expense_v1_reports(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single instance of an Expense Report.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/reports/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_expense_v1_reports {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_expense_v1_entries(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single instance of a Quick Expense.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/entries/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_expense_v1_entries {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_expense_v1_entries(
        self,
        ID: str,
        entryServicePUTRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates an existing Quick Expense instance.

        Args:
            ID: The Workday ID of the resource. (required)
            entryServicePUTRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/entries/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if entryServicePUTRepresentation is not None:
            if isinstance(entryServicePUTRepresentation, dict):
                body.update(entryServicePUTRepresentation)
            else:
                body["entryServicePUTRepresentation"] = entryServicePUTRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_expense_v1_entries {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_expense_v1_entries(
        self,
        ID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/entries/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_expense_v1_entries {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_expense_v1_entries_1(
        self,
        ID: str,
        entryServicePUTRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            entryServicePUTRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/entries/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if entryServicePUTRepresentation is not None:
            if isinstance(entryServicePUTRepresentation, dict):
                body.update(entryServicePUTRepresentation)
            else:
                body["entryServicePUTRepresentation"] = entryServicePUTRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_expense_v1_entries_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_expense_v1_values_bespoke_prompt_expense_item(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/values/bespokePrompt/expenseItem/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_expense_v1_values_bespoke_prompt_expense_item {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_expense_v1_reports(
        self,
        expenseReportMemo: Optional[str] = None,
        expenseReportStatus: Optional[List[str]] = None,
        fromDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        toDate: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of expense reports.

        Args:
            expenseReportMemo:  (optional)
            expenseReportStatus:  (optional)
            fromDate:  (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            toDate:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/reports"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if expenseReportMemo is not None:
            params["expenseReportMemo"] = expenseReportMemo
        if expenseReportStatus is not None:
            params["expenseReportStatus"] = expenseReportStatus
        if fromDate is not None:
            params["fromDate"] = fromDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if toDate is not None:
            params["toDate"] = toDate

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_expense_v1_reports {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_expense_v1_reports(
        self,
        reportPostServiceRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            reportPostServiceRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/reports"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if reportPostServiceRepresentation is not None:
            if isinstance(reportPostServiceRepresentation, dict):
                body.update(reportPostServiceRepresentation)
            else:
                body["reportPostServiceRepresentation"] = reportPostServiceRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_expense_v1_reports {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_expense_v1_reports_lines(
        self,
        ID: str,
        postExpenseReportLineRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a collection of expense report lines.

        Args:
            ID: The Workday ID of the resource. (required)
            postExpenseReportLineRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/reports/{ID}/lines".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if postExpenseReportLineRepresentation is not None:
            if isinstance(postExpenseReportLineRepresentation, dict):
                body.update(postExpenseReportLineRepresentation)
            else:
                body["postExpenseReportLineRepresentation"] = postExpenseReportLineRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_expense_v1_reports_lines {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_expense_v1_reports_submit(
        self,
        ID: str,
        submitExpenseReportRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            submitExpenseReportRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/reports/{ID}/submit".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if submitExpenseReportRepresentation is not None:
            if isinstance(submitExpenseReportRepresentation, dict):
                body.update(submitExpenseReportRepresentation)
            else:
                body["submitExpenseReportRepresentation"] = submitExpenseReportRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_expense_v1_reports_submit {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_expense_v1_entries(
        self,
        entryType: Optional[str] = None,
        expenseEntryStatus: Optional[str] = None,
        fromDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        toDate: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of Quick Expenses.

        Args:
            entryType:  (optional)
            expenseEntryStatus:  (optional)
            fromDate:  (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            toDate:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/entries"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if entryType is not None:
            params["entryType"] = entryType
        if expenseEntryStatus is not None:
            params["expenseEntryStatus"] = expenseEntryStatus
        if fromDate is not None:
            params["fromDate"] = fromDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if toDate is not None:
            params["toDate"] = toDate

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_expense_v1_entries {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_expense_v1_entries(
        self,
        entryServiceRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            entryServiceRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/entries"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if entryServiceRepresentation is not None:
            if isinstance(entryServiceRepresentation, dict):
                body.update(entryServiceRepresentation)
            else:
                body["entryServiceRepresentation"] = entryServiceRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_expense_v1_entries {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_expense_v1_entries_attachments(
        self,
        ID: str,
        expenseEntryImage: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates new attachments for the existing expense entry.

        Args:
            ID: The Workday ID of the resource. (required)
            expenseEntryImage:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/entries/{ID}/attachments".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if expenseEntryImage is not None:
            if isinstance(expenseEntryImage, dict):
                body.update(expenseEntryImage)
            else:
                body["expenseEntryImage"] = expenseEntryImage

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_expense_v1_entries_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_expense_v1_expense_items(
        self,
        disallowFixedItems: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        searchString: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of expense items.

        Args:
            disallowFixedItems:  (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            searchString:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/expense/v1/expenseItems"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if disallowFixedItems is not None:
            params["disallowFixedItems"] = disallowFixedItems
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if searchString is not None:
            params["searchString"] = searchString

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_expense_v1_expense_items {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_help_article_v1_article_versions(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieve an article version and the plain text content for the article version.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpArticle/v1/articleVersions/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_help_article_v1_article_versions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_article_v1_article_versions(
        self,
        audience: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        status: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """Retrieves a list of article versions and the plain text content within each article version.

        Args:
            audience: The audience of the article version. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            status: The status of the article version. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpArticle/v1/articleVersions"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if audience is not None:
            params["audience"] = audience
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if status is not None:
            params["status"] = status

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_article_v1_article_versions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_article_v1_values_common_audiences(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpArticle/v1/values/common/audiences/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_article_v1_values_common_audiences {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_article_v1_article_statuses(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a list of article version statuses for all articles.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpArticle/v1/articleStatuses"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_article_v1_article_statuses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_help_article_v1_article_statuses(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieve an article version status for an article.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpArticle/v1/articleStatuses/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_help_article_v1_article_statuses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_custom_object_definition_v1_definitions_validations(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of validations in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/validations".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_custom_object_definition_v1_definitions_validations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_custom_object_definition_v1_definitions_validations(
        self,
        ID: str,
        customObjectValidation: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            customObjectValidation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/validations".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if customObjectValidation is not None:
            if isinstance(customObjectValidation, dict):
                body.update(customObjectValidation)
            else:
                body["customObjectValidation"] = customObjectValidation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_custom_object_definition_v1_definitions_validations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_custom_object_definition_v1_field_types(
        self,
        fieldType: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of custom field types.

        Args:
            fieldType:  (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/fieldTypes"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if fieldType is not None:
            params["fieldType"] = fieldType
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_custom_object_definition_v1_field_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_custom_object_definition_v1_field_types(
        self,
        customFieldTypeDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            customFieldTypeDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/fieldTypes"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if customFieldTypeDetail is not None:
            if isinstance(customFieldTypeDetail, dict):
                body.update(customFieldTypeDetail)
            else:
                body["customFieldTypeDetail"] = customFieldTypeDetail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_custom_object_definition_v1_field_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_custom_object_definition_v1_definitions_validations(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a validation in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/validations/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_custom_object_definition_v1_definitions_validations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_custom_object_definition_v1_definitions_validations(
        self,
        ID: str,
        subresourceID: str,
        customObjectValidation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates an existing validation in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            customObjectValidation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/validations/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if customObjectValidation is not None:
            if isinstance(customObjectValidation, dict):
                body.update(customObjectValidation)
            else:
                body["customObjectValidation"] = customObjectValidation

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_custom_object_definition_v1_definitions_validations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_custom_object_definition_v1_definitions_validations(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Deletes a validation in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/validations/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_custom_object_definition_v1_definitions_validations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_custom_object_definition_v1_definitions_activate(
        self,
        ID: str,
        customObjectDefinitionActivate: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            customObjectDefinitionActivate:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/activate".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if customObjectDefinitionActivate is not None:
            if isinstance(customObjectDefinitionActivate, dict):
                body.update(customObjectDefinitionActivate)
            else:
                body["customObjectDefinitionActivate"] = customObjectDefinitionActivate

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_custom_object_definition_v1_definitions_activate {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_custom_object_definition_v1_definitions(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_custom_object_definition_v1_definitions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_custom_object_definition_v1_definitions(
        self,
        ID: str,
        detail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates an existing custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            detail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if detail is not None:
            if isinstance(detail, dict):
                body.update(detail)
            else:
                body["detail"] = detail

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_custom_object_definition_v1_definitions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_custom_object_definition_v1_definitions(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Deletes a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_custom_object_definition_v1_definitions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_custom_object_definition_v1_definitions(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of custom object definitions.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_custom_object_definition_v1_definitions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_custom_object_definition_v1_definitions(
        self,
        detail: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            detail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if detail is not None:
            if isinstance(detail, dict):
                body.update(detail)
            else:
                body["detail"] = detail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_custom_object_definition_v1_definitions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_custom_object_definition_v1_field_types_list_values(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a list value for a custom lists in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/fieldTypes/{ID}/listValues/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_custom_object_definition_v1_field_types_list_values {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_custom_object_definition_v1_field_types_list_values(
        self,
        ID: str,
        subresourceID: str,
        customListValueDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates an existing list value in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            customListValueDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/fieldTypes/{ID}/listValues/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if customListValueDetail is not None:
            if isinstance(customListValueDetail, dict):
                body.update(customListValueDetail)
            else:
                body["customListValueDetail"] = customListValueDetail

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_custom_object_definition_v1_field_types_list_values {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_custom_object_definition_v1_definitions_condition_rules(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of condition rules in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/conditionRules".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_custom_object_definition_v1_definitions_condition_rules {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_custom_object_definition_v1_definitions_condition_rules(
        self,
        ID: str,
        conditionRuleDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            conditionRuleDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/conditionRules".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if conditionRuleDetail is not None:
            if isinstance(conditionRuleDetail, dict):
                body.update(conditionRuleDetail)
            else:
                body["conditionRuleDetail"] = conditionRuleDetail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_custom_object_definition_v1_definitions_condition_rules {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_custom_object_definition_v1_definitions_condition_rules(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a condition rule in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/conditionRules/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_custom_object_definition_v1_definitions_condition_rules {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_custom_object_definition_v1_definitions_condition_rules(
        self,
        ID: str,
        subresourceID: str,
        conditionRuleDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates an existing condition rule in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            conditionRuleDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/conditionRules/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if conditionRuleDetail is not None:
            if isinstance(conditionRuleDetail, dict):
                body.update(conditionRuleDetail)
            else:
                body["conditionRuleDetail"] = conditionRuleDetail

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_custom_object_definition_v1_definitions_condition_rules {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_custom_object_definition_v1_definitions_condition_rules(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Deletes a condition rule in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/conditionRules/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_custom_object_definition_v1_definitions_condition_rules {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_custom_object_definition_v1_field_types(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a custom field type.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/fieldTypes/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_custom_object_definition_v1_field_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_custom_object_definition_v1_field_types(
        self,
        ID: str,
        customFieldTypeDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates an existing custom field type.

        Args:
            ID: The Workday ID of the resource. (required)
            customFieldTypeDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/fieldTypes/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if customFieldTypeDetail is not None:
            if isinstance(customFieldTypeDetail, dict):
                body.update(customFieldTypeDetail)
            else:
                body["customFieldTypeDetail"] = customFieldTypeDetail

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_custom_object_definition_v1_field_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_custom_object_definition_v1_field_types_list_values(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of list values for a custom list in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/fieldTypes/{ID}/listValues".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_custom_object_definition_v1_field_types_list_values {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_custom_object_definition_v1_field_types_list_values(
        self,
        ID: str,
        customListValueDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            customListValueDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/fieldTypes/{ID}/listValues".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if customListValueDetail is not None:
            if isinstance(customListValueDetail, dict):
                body.update(customListValueDetail)
            else:
                body["customListValueDetail"] = customListValueDetail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_custom_object_definition_v1_field_types_list_values {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_custom_object_definition_v1_definitions_fields(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a field in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/fields/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_custom_object_definition_v1_definitions_fields {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_custom_object_definition_v1_definitions_fields(
        self,
        ID: str,
        subresourceID: str,
        customField: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates an existing field in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            customField:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/fields/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if customField is not None:
            if isinstance(customField, dict):
                body.update(customField)
            else:
                body["customField"] = customField

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_custom_object_definition_v1_definitions_fields {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_custom_object_definition_v1_definitions_fields(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Deletes a field in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/fields/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_custom_object_definition_v1_definitions_fields {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_custom_object_definition_v1_definitions_fields(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of fields in a custom object definition.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/fields".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_custom_object_definition_v1_definitions_fields {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_custom_object_definition_v1_definitions_fields(
        self,
        ID: str,
        customField: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            customField:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/customObjectDefinition/v1/definitions/{ID}/fields".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if customField is not None:
            if isinstance(customField, dict):
                body.update(customField)
            else:
                body["customField"] = customField

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_custom_object_definition_v1_definitions_fields {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_global_payroll_v1_pay_groups(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a Payroll Interface pay group.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/globalPayroll/v1/payGroups/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_global_payroll_v1_pay_groups {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_global_payroll_v1_authorizations(
        self,
        globalPayrollAuthorization: Dict[str, Any]
    ) -> WorkdayResponse:
        """Check subjectId permissions against featureId for each target Id

        Args:
            globalPayrollAuthorization:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/globalPayroll/v1/authorizations"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if globalPayrollAuthorization is not None:
            if isinstance(globalPayrollAuthorization, dict):
                body.update(globalPayrollAuthorization)
            else:
                body["globalPayrollAuthorization"] = globalPayrollAuthorization

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_global_payroll_v1_authorizations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_global_payroll_v1_event_driven_integration_vendor_response(
        self,
        eventDrivenIntegrationVendorResponse: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates a specific vendor response instance of Event-Driven Integration with the specified data after the third-party payroll system completes processing of the worker changes.

        Args:
            eventDrivenIntegrationVendorResponse:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/globalPayroll/v1/eventDrivenIntegrationVendorResponse"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if eventDrivenIntegrationVendorResponse is not None:
            if isinstance(eventDrivenIntegrationVendorResponse, dict):
                body.update(eventDrivenIntegrationVendorResponse)
            else:
                body["eventDrivenIntegrationVendorResponse"] = eventDrivenIntegrationVendorResponse

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_global_payroll_v1_event_driven_integration_vendor_response {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_global_payroll_v1_pay_groups_periods(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        periodEndDate: Optional[str] = None,
        showMostRecentOnly: Optional[bool] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of payroll periods for the specified Payroll Interface pay group ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            periodEndDate: The end date of a payroll period using the yyyy-mm-dd format. This should not be used with the showMostRecentOnly query parameter. If both periodEndDate and showMostRecentOnly query parameters are provided, the API will only consider the periodEndDate query parameter. (optional)
            showMostRecentOnly: If true, the operation returns the 5 most recent pay periods. This should not be used with periodEndDate query parameter. If both showMostRecentOnly and periodEndDate query parameters are provided, the API will ignore showMostRecentOnly query parameter. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/globalPayroll/v1/payGroups/{ID}/periods".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if periodEndDate is not None:
            params["periodEndDate"] = periodEndDate
        if showMostRecentOnly is not None:
            params["showMostRecentOnly"] = showMostRecentOnly

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_global_payroll_v1_pay_groups_periods {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_global_payroll_v1_event_driven_integration_vendor_response(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single Event-Driven Integration vendor response.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/globalPayroll/v1/eventDrivenIntegrationVendorResponse/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_global_payroll_v1_event_driven_integration_vendor_response {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_global_payroll_v1_notifications(
        self,
        notification: Dict[str, Any]
    ) -> WorkdayResponse:
        """POST Inbound Notifications request.

        Args:
            notification:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/globalPayroll/v1/notifications"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if notification is not None:
            if isinstance(notification, dict):
                body.update(notification)
            else:
                body["notification"] = notification

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_global_payroll_v1_notifications {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_global_payroll_v1_pay_groups_periods(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a payroll period for the specified Payroll Interface pay group ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/globalPayroll/v1/payGroups/{ID}/periods/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_global_payroll_v1_pay_groups_periods {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_global_payroll_v1_pay_groups_periods(
        self,
        ID: str,
        subresourceID: str,
        periodSummary: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates an existing pay period by the specified pay group ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            periodSummary:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/globalPayroll/v1/payGroups/{ID}/periods/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if periodSummary is not None:
            if isinstance(periodSummary, dict):
                body.update(periodSummary)
            else:
                body["periodSummary"] = periodSummary

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_global_payroll_v1_pay_groups_periods {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_global_payroll_v1_effective_changes(
        self,
        dataChangesOnDemand: Dict[str, Any]
    ) -> WorkdayResponse:
        """Generates effective change data for organizations or workers based on request parameters.

        Args:
            dataChangesOnDemand:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/globalPayroll/v1/effectiveChanges"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if dataChangesOnDemand is not None:
            if isinstance(dataChangesOnDemand, dict):
                body.update(dataChangesOnDemand)
            else:
                body["dataChangesOnDemand"] = dataChangesOnDemand

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_global_payroll_v1_effective_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_global_payroll_v1_pay_groups(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of Payroll Interface pay groups.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/globalPayroll/v1/payGroups"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_global_payroll_v1_pay_groups {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_global_payroll_v1_effective_changes(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a specific Data Changes on Demand event.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/globalPayroll/v1/effectiveChanges/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_global_payroll_v1_effective_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_holiday_v1_holiday_events(
        self,
        fromDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        toDate: Optional[str] = None,
        worker: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """No summary

        Args:
            fromDate:  (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            toDate:  (optional)
            worker:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/holiday/v1/holidayEvents"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if fromDate is not None:
            params["fromDate"] = fromDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if toDate is not None:
            params["toDate"] = toDate
        if worker is not None:
            params["worker"] = worker

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_holiday_v1_holiday_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_journeys_v1_distribution_requests(
        self,
        journeyDistributionEventCreateRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates journey distribution.

        Args:
            journeyDistributionEventCreateRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/journeys/v1/distributionRequests"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if journeyDistributionEventCreateRepresentation is not None:
            if isinstance(journeyDistributionEventCreateRepresentation, dict):
                body.update(journeyDistributionEventCreateRepresentation)
            else:
                body["journeyDistributionEventCreateRepresentation"] = journeyDistributionEventCreateRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_journeys_v1_distribution_requests {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_o_auth_client_v1_client_details(
        self,
        client_name: Optional[str] = None
    ) -> WorkdayResponse:
        """Returns a valid OAuth Client Details for OCFR Clients

        Args:
            client_name: Client Name (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/oAuthClient/v1/clientDetails"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if client_name is not None:
            params["client_name"] = client_name

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_o_auth_client_v1_client_details {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_o_auth_client_v1_client_details(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Returns a valid OAuth Client Details for OCFR Clients

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/oAuthClient/v1/clientDetails/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_o_auth_client_v1_client_details {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_learning_v1_content(
        self,
        contentType: Optional[List[str]] = None,
        lastUpdated: Optional[str] = None,
        lifecycleStatus: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        skills: Optional[List[str]] = None,
        topics: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of learning content.

        Args:
            contentType: The type of learning content. The learning catalog comprises programs, blended and digital courses, course offerings for blended courses, and stand-alone lessons. (optional)
            lastUpdated: When specified, only Learning Content updated since the specified datetime will be returned in the response. (optional)
            lifecycleStatus: The current status of the learning content. Possible value is Active or Inactive. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            skills: The skills associated with this learning content. (optional)
            topics: The group of learning elements that this learning content belongs. Example: Compliance. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/learning/v1/content"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if contentType is not None:
            params["contentType"] = contentType
        if lastUpdated is not None:
            params["lastUpdated"] = lastUpdated
        if lifecycleStatus is not None:
            params["lifecycleStatus"] = lifecycleStatus
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if skills is not None:
            params["skills"] = skills
        if topics is not None:
            params["topics"] = topics

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_learning_v1_content {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_learning_v1_content_lessons(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of lessons for a learning content.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/learning/v1/content/{ID}/lessons".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_learning_v1_content_lessons {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_learning_v1_manage_digital_courses(
        self,
        manageDigitalCourse: Dict[str, Any]
    ) -> WorkdayResponse:
        """Provides the ability to create and update digital courses. These REST APIs are secured to the initiating actions of the BP.

        Args:
            manageDigitalCourse:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/learning/v1/manageDigitalCourses"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if manageDigitalCourse is not None:
            if isinstance(manageDigitalCourse, dict):
                body.update(manageDigitalCourse)
            else:
                body["manageDigitalCourse"] = manageDigitalCourse

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_learning_v1_manage_digital_courses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_learning_v1_content(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single learning content instance

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/learning/v1/content/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_learning_v1_content {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_learning_v1_content_lessons(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single lesson for a learning content instance

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/learning/v1/content/{ID}/lessons/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_learning_v1_content_lessons {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_payroll_v2_jobs_pay_group(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single pay group instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/jobs/{ID}/payGroup/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_payroll_v2_jobs_pay_group {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_jobs_pay_group(
        self,
        ID: str,
        effective: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves the pay group for a specified job ID. This method always returns 1 pay group.

        Args:
            ID: The Workday ID of the resource. (required)
            effective: The effective date of the pay group, using the date format yyyy-mm-dd. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/jobs/{ID}/payGroup".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if effective is not None:
            params["effective"] = effective
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_jobs_pay_group {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_payroll_v2_pay_groups(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single pay group instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/payGroups/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_payroll_v2_pay_groups {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_values_tax_rates_group_company_instances(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/values/taxRatesGroup/companyInstances/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_values_tax_rates_group_company_instances {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_values_payroll_inputs_group_worktags(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/values/payrollInputsGroup/worktags/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_values_payroll_inputs_group_worktags {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_payroll_v2_pay_group_details(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single pay group detail instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/payGroupDetails/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_payroll_v2_pay_group_details {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_jobs(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of jobs.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/jobs"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_jobs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_minimum_wage_rates(
        self,
        asOfDate: Optional[str] = None,
        country: Optional[str] = None,
        includeLocalTaxAuthorities: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        taxAuthority: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of minimum wage rates.

        Args:
            asOfDate: The minimum wage rates that are effective on the date specified using the yyyy-mm-dd format. (optional)
            country: The Workday ID of the country for the minimum wages rates. You can use a returned id from GET /values/minimumWageRatesGroup/countries. You can specify 1 country query parameter. Example: country=country. (optional)
            includeLocalTaxAuthorities: If true, returns minimum wage rates for local tax authorities, such as cities and counties, in addition to federal and state rates. If false (default), only returns federal and state minimum wage rates. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            taxAuthority: The Workday ID of the payroll tax authority for the minimum wages rates. You can use a returned id from GET /values/minimumWageRatesGroup/taxAuthorities. You can specify 1 or more tax authority query parameters. Example: taxAuthority=taxAuthority1&taxAuthority=taxAuthority2. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/minimumWageRates"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if asOfDate is not None:
            params["asOfDate"] = asOfDate
        if country is not None:
            params["country"] = country
        if includeLocalTaxAuthorities is not None:
            params["includeLocalTaxAuthorities"] = includeLocalTaxAuthorities
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if taxAuthority is not None:
            params["taxAuthority"] = taxAuthority

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_minimum_wage_rates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_values_payroll_inputs_group_run_categories(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/values/payrollInputsGroup/runCategories/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_values_payroll_inputs_group_run_categories {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_payroll_v2_jobs(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single job instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/jobs/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_payroll_v2_jobs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_pay_group_details(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        runCategories: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of pay group details.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            runCategories: One or more Workday IDs of run categories for the pay group. You can use returned ids from GET /values/payrollInputsGroup/runCategories.You can specify 1 or more runCategories query parameters, example: runCategories=category1&runCategories=category2 (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/payGroupDetails"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if runCategories is not None:
            params["runCategories"] = runCategories

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_pay_group_details {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_values_payroll_inputs_group_positions(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/values/payrollInputsGroup/positions/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_values_payroll_inputs_group_positions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_payroll_v2_minimum_wage_rates(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a collection of minimum wage rates.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/minimumWageRates/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_payroll_v2_minimum_wage_rates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_payroll_v2_payroll_inputs(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single payroll input instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/payrollInputs/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_payroll_v2_payroll_inputs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_payroll_v2_payroll_inputs(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Deletes an existing payroll input instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/payrollInputs/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_payroll_v2_payroll_inputs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_payroll_v2_payroll_inputs(
        self,
        ID: str,
        payrollInputView: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates an existing payroll input instance.

        Args:
            ID: The Workday ID of the resource. (required)
            payrollInputView:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/payrollInputs/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if payrollInputView is not None:
            if isinstance(payrollInputView, dict):
                body.update(payrollInputView)
            else:
                body["payrollInputView"] = payrollInputView

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_payroll_v2_payroll_inputs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_values_minimum_wage_rates_group_tax_authorities(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/values/minimumWageRatesGroup/taxAuthorities/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_values_minimum_wage_rates_group_tax_authorities {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_payroll_inputs(
        self,
        endDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        payComponent: Optional[List[str]] = None,
        startDate: Optional[str] = None,
        worker: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of payroll inputs. At least 1 query parameter is required to get data.

        Args:
            endDate: The end date filter which returns payroll inputs that are active on or before the end date, using the date format yyyy-mm-dd. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            payComponent: The Workday ID of the pay component for the payroll input. You can use a returned id from GET /values/payrollInputsGroup/payComponents. (optional)
            startDate: The start date filter which returns payroll inputs that are active on or after the start date, using the date format yyyy-mm-dd. (optional)
            worker: The Workday ID of worker for the payroll input. You can use a returned id from GET /workers in the Staffing service. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/payrollInputs"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if endDate is not None:
            params["endDate"] = endDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if payComponent is not None:
            params["payComponent"] = payComponent
        if startDate is not None:
            params["startDate"] = startDate
        if worker is not None:
            params["worker"] = worker

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_payroll_inputs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_payroll_v2_payroll_inputs(
        self,
        payrollInputView: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates payroll inputs.

        Args:
            payrollInputView:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/payrollInputs"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if payrollInputView is not None:
            if isinstance(payrollInputView, dict):
                body.update(payrollInputView)
            else:
                body["payrollInputView"] = payrollInputView

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_payroll_v2_payroll_inputs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_values_tax_rates_group_state_instances(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/values/taxRatesGroup/stateInstances/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_values_tax_rates_group_state_instances {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_values_minimum_wage_rates_group_countries(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/values/minimumWageRatesGroup/countries/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_values_minimum_wage_rates_group_countries {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_tax_rates(
        self,
        company: Optional[str] = None,
        effective: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        payrollStateAuthorityTaxCode: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a single or a collection of company SUI rates.

        Args:
            company: The company reference ID or WID that represents 1 or more companies. Example: company=comp1&company=comp2&company=cb550da820584750aae8f807882fa79a (optional)
            effective: The effective date for the SUI rate, using the yyyy-mm-dd format. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            payrollStateAuthorityTaxCode: The FIPS code or WID that represents 1 or more states. Example: payrollStateAuthorityTaxCode=06&payrollStateAuthorityTaxCode=3b3d378d5f4a48b8b3ac46fee0703226&payrollStateAuthorityTaxCode=48 (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/taxRates"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if company is not None:
            params["company"] = company
        if effective is not None:
            params["effective"] = effective
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if payrollStateAuthorityTaxCode is not None:
            params["payrollStateAuthorityTaxCode"] = payrollStateAuthorityTaxCode

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_tax_rates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_payroll_v2_tax_rates(
        self,
        companySuiRateDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a single or a collection of Company SUI Rates.

        Args:
            companySuiRateDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/taxRates"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if companySuiRateDetails is not None:
            if isinstance(companySuiRateDetails, dict):
                body.update(companySuiRateDetails)
            else:
                body["companySuiRateDetails"] = companySuiRateDetails

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_payroll_v2_tax_rates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_values_payroll_inputs_group_pay_components(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/values/payrollInputsGroup/payComponents/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_values_payroll_inputs_group_pay_components {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_payroll_v2_pay_groups(
        self,
        country: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of pay groups.

        Args:
            country: The Workday ID of the country or territory of the pay group. You can use a returned country id from any of the payGroups endpoints in this Payroll API. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/payroll/v2/payGroups"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if country is not None:
            params["country"] = country
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_payroll_v2_pay_groups {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_performance_enablement_v5_feedback_badges(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of active Feedback Badges.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/feedbackBadges"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_performance_enablement_v5_feedback_badges {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_performance_enablement_v5_workers_requested_feedback_on_self_events(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single self-requested feedback event instance for the specified worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}/requestedFeedbackOnSelfEvents/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_performance_enablement_v5_workers_requested_feedback_on_self_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_performance_enablement_v5_give_requested_feedback_events(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of feedback given events about the user that responded to the feedback request.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/giveRequestedFeedbackEvents"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_performance_enablement_v5_give_requested_feedback_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_performance_enablement_v5_workers_development_items(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        r"""Retrieves a single \~development item\~ for the specified \~worker\~.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}/developmentItems/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_performance_enablement_v5_workers_development_items {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_performance_enablement_v5_workers_development_items(
        self,
        ID: str,
        subresourceID: str,
        removeDevelopmentItem: Dict[str, Any]
    ) -> WorkdayResponse:
        r"""Deletes an existing \~development item\~.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            removeDevelopmentItem:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}/developmentItems/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if removeDevelopmentItem is not None:
            if isinstance(removeDevelopmentItem, dict):
                body.update(removeDevelopmentItem)
            else:
                body["removeDevelopmentItem"] = removeDevelopmentItem

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_performance_enablement_v5_workers_development_items {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_performance_enablement_v5_feedback_badges(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a Feedback Badge with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/feedbackBadges/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_performance_enablement_v5_feedback_badges {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_performance_enablement_v5_workers_goals(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of goals for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}/goals".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_performance_enablement_v5_workers_goals {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_performance_enablement_v5_workers_requested_feedback_on_self_events(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of self-requested feedback events for the specified worker.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}/requestedFeedbackOnSelfEvents".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_performance_enablement_v5_workers_requested_feedback_on_self_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_performance_enablement_v5_workers_requested_feedback_on_self_events(
        self,
        ID: str,
        requestedFeedbackOnSelfEventDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a single self-requested feedback event instance for the specified worker.

        Args:
            ID: The Workday ID of the resource. (required)
            requestedFeedbackOnSelfEventDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}/requestedFeedbackOnSelfEvents".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if requestedFeedbackOnSelfEventDetail is not None:
            if isinstance(requestedFeedbackOnSelfEventDetail, dict):
                body.update(requestedFeedbackOnSelfEventDetail)
            else:
                body["requestedFeedbackOnSelfEventDetail"] = requestedFeedbackOnSelfEventDetail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_performance_enablement_v5_workers_requested_feedback_on_self_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_performance_enablement_v5_workers_requested_feedback_on_worker_events(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single requested feedback event instance for the specified worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}/requestedFeedbackOnWorkerEvents/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_performance_enablement_v5_workers_requested_feedback_on_worker_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_performance_enablement_v5_workers_goals(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single goal instance for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}/goals/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_performance_enablement_v5_workers_goals {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_performance_enablement_v5_values_workers_to_notify_workers_to_notify(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/values/workersToNotify/workersToNotify/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_performance_enablement_v5_values_workers_to_notify_workers_to_notify {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_performance_enablement_v5_workers_anytime_feedback_events(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a feedback given event instance with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}/anytimeFeedbackEvents/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_performance_enablement_v5_workers_anytime_feedback_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_performance_enablement_v5_values_feedback_template_feedback_template(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/values/feedbackTemplate/feedbackTemplate/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_performance_enablement_v5_values_feedback_template_feedback_template {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_performance_enablement_v5_workers_development_items(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        r"""Retrieves a collection of \~development items\~ for the specified \~worker\~.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}/developmentItems".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_performance_enablement_v5_workers_development_items {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_performance_enablement_v5_workers(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a collection of workers and current staffing information.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_performance_enablement_v5_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_performance_enablement_v5_workers_requested_feedback_on_worker_events(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of requested feedback events for the specified worker.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}/requestedFeedbackOnWorkerEvents".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_performance_enablement_v5_workers_requested_feedback_on_worker_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_performance_enablement_v5_workers_requested_feedback_on_worker_events(
        self,
        ID: str,
        requestedFeedbackOnWorkerEventDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a single requested feedback event instance for the specified worker.

        Args:
            ID: The Workday ID of the resource. (required)
            requestedFeedbackOnWorkerEventDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}/requestedFeedbackOnWorkerEvents".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if requestedFeedbackOnWorkerEventDetail is not None:
            if isinstance(requestedFeedbackOnWorkerEventDetail, dict):
                body.update(requestedFeedbackOnWorkerEventDetail)
            else:
                body["requestedFeedbackOnWorkerEventDetail"] = requestedFeedbackOnWorkerEventDetail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_performance_enablement_v5_workers_requested_feedback_on_worker_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_performance_enablement_v5_values_feedback_on_worker_feedback_on_worker(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/values/feedbackOnWorker/feedbackOnWorker/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_performance_enablement_v5_values_feedback_on_worker_feedback_on_worker {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_performance_enablement_v5_values_feedback_responder_feedback_responder(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/values/feedbackResponder/feedbackResponder/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_performance_enablement_v5_values_feedback_responder_feedback_responder {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_performance_enablement_v5_workers(
        self,
        includeTerminatedWorkers: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        search: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of workers and current staffing information.

        Args:
            includeTerminatedWorkers: Include terminated workers in the output (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            search: Searches workers by name or worker ID. The search is case-insensitive. You can include space-delimited search strings for an OR search. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if includeTerminatedWorkers is not None:
            params["includeTerminatedWorkers"] = includeTerminatedWorkers
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if search is not None:
            params["search"] = search

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_performance_enablement_v5_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_performance_enablement_v5_workers_anytime_feedback_events(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of feedback given events about the specified worker.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}/anytimeFeedbackEvents".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_performance_enablement_v5_workers_anytime_feedback_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_performance_enablement_v5_workers_anytime_feedback_events(
        self,
        ID: str,
        feedbackEventDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a single feedback given event instance about the specified worker.

        Args:
            ID: The Workday ID of the resource. (required)
            feedbackEventDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/workers/{ID}/anytimeFeedbackEvents".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if feedbackEventDetail is not None:
            if isinstance(feedbackEventDetail, dict):
                body.update(feedbackEventDetail)
            else:
                body["feedbackEventDetail"] = feedbackEventDetail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_performance_enablement_v5_workers_anytime_feedback_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_performance_enablement_v5_give_requested_feedback_events(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single requested feedback given event instance with the specified ID of the user that responded to the feedback request.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/giveRequestedFeedbackEvents/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_performance_enablement_v5_give_requested_feedback_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_performance_enablement_v5_give_requested_feedback_events(
        self,
        ID: str,
        giveRequestedFeedbackDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates the Give Requested Feedback Event that matches the WID in the url, and the current authenticated user is a responder for the event.

        Args:
            ID: The Workday ID of the resource. (required)
            giveRequestedFeedbackDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/giveRequestedFeedbackEvents/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if giveRequestedFeedbackDetails is not None:
            if isinstance(giveRequestedFeedbackDetails, dict):
                body.update(giveRequestedFeedbackDetails)
            else:
                body["giveRequestedFeedbackDetails"] = giveRequestedFeedbackDetails

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_performance_enablement_v5_give_requested_feedback_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_performance_enablement_v5_values_relates_to_relates_to(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/performanceEnablement/v5/values/relatesTo/relatesTo/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_performance_enablement_v5_values_relates_to_relates_to {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_tables(
        self,
        limit: Optional[int] = None,
        name: Optional[str] = None,
        offset: Optional[int] = None,
        type_param: Optional[str] = None
    ) -> WorkdayResponse:
        """Get tables that the current user has permission on

        Args:
            limit: The maximum number of object data entries included in the response.
- default: 20
- max: 100
 (optional)
            name: The API name of the table to retrieve a single table.
 (optional)
            offset: The offset to the first object in a collection to include in the response.
default: 0
 (optional)
            type_param: How much information to be returned in response JSON.
The value for type dictates the response fields that are excluded.
- default: summary
- full : Returns tableResponse, excluding user permissions
- permissions : Returns tableResponse with user permissions. Schema fields are excluded
- summary : Returns summarized tableResponse, excluding schema fields and user permissions
Note: The HTTP 200 response below is for type \"full\"
 (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/tables"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if name is not None:
            params["name"] = name
        if offset is not None:
            params["offset"] = offset
        if type_param is not None:
            params["type"] = type_param

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_tables {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_tables(
        self
    ) -> WorkdayResponse:
        """Create a new table with the specified name

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/tables"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_tables {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_tables(
        self,
        id: str,
        type_param: Optional[str] = None
    ) -> WorkdayResponse:
        """Get the description of a table by ID

        Args:
            id: A reference to a Prism Analytics table. Example: The ID of the table.
 (required)
            type_param: How much information to be returned in response JSON.
The value for type dictates the response fields that are excluded.
- default: full
- full : Returns tableResponse, excluding user permissions
- permissions : Returns tableResponse with user permissions. Schema fields are excluded
- summary : Returns summarized tableResponse, excluding schema fields and user permissions
Note: The HTTP 200 response below is for \"type\" full
 (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/tables/{id}".replace("{id}", str(id))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if type_param is not None:
            params["type"] = type_param

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_tables {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_tables(
        self,
        id: str
    ) -> WorkdayResponse:
        """Edit an existing table with the specified name

        Args:
            id: A reference to a Prism Analytics table. Example: The ID of the table.
 (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/tables/{id}".replace("{id}", str(id))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_tables {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_tables_1(
        self,
        id: str
    ) -> WorkdayResponse:
        """Edit the specified attributes of an existing table with the specified id. If an attribute is not provided in the request, it will not be changed.

        Args:
            id: A reference to a Prism Analytics table. Example: The ID of the table.
 (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/tables/{id}".replace("{id}", str(id))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_tables_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_buckets(
        self,
        limit: Optional[float] = None,
        name: Optional[str] = None,
        offset: Optional[float] = None,
        type_param: Optional[str] = None
    ) -> WorkdayResponse:
        """Get the buckets permitted by the security profile of the current user

        Args:
            limit: The maximum number of object data entries to be included in the response.
- default: 20
- max: 100
 (optional)
            name: The name of bucket.
 (optional)
            offset: The offset to the first object in a collection to include in the response.
- default: 0
 (optional)
            type_param: How much information to be returned.
 (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/buckets"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if name is not None:
            params["name"] = name
        if offset is not None:
            params["offset"] = offset
        if type_param is not None:
            params["type"] = type_param

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_buckets {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_buckets(
        self
    ) -> WorkdayResponse:
        """Create a new bucket for a table or dataset

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/buckets"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_buckets {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_buckets(
        self,
        id: str,
        type_param: Optional[str] = None
    ) -> WorkdayResponse:
        """Get bucket by ID

        Args:
            id: A reference to a Prism Analytics table. Example: The ID of the bucket.
 (required)
            type_param: How much information to be returned.
- default: full
 (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/buckets/{id}".replace("{id}", str(id))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if type_param is not None:
            params["type"] = type_param

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_buckets {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_buckets(
        self,
        id: str
    ) -> WorkdayResponse:
        """Edit an existing bucket with the specified name

        Args:
            id: A reference to a Prism Analytics table. Example: The ID of the table.
 (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/buckets/{id}".replace("{id}", str(id))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_buckets {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_buckets_files(
        self,
        id: str
    ) -> WorkdayResponse:
        """Upload a single file to a bucket for a table or dataset

        Args:
            id: A reference to a Prism Analytics table. Example: The ID of the table.
 (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/buckets/{id}/files".replace("{id}", str(id))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_buckets_files {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_buckets_complete(
        self,
        id: str
    ) -> WorkdayResponse:
        """Commit data contained in a bucket into the associated table or dataset

        Args:
            id: A reference to a Prism Analytics table. Example: The ID of the table.
 (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/buckets/{id}/complete".replace("{id}", str(id))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_buckets_complete {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_buckets_error_file(
        self,
        id: str
    ) -> WorkdayResponse:
        """Get bucket error file by ID

        Args:
            id: A reference to a Prism Analytics bucket. Example: The ID of the bucket.
 (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/buckets/{id}/errorFile".replace("{id}", str(id))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_buckets_error_file {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_data_changes(
        self,
        type_param: str,
        limit: Optional[int] = None,
        name: Optional[str] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Get data changes accessible by a user

        Args:
            type_param: How much data change information to be returned. Note: The model response for HTTP 200 below is for type \"summary\"

Note: Either \"type\" or \"name\" query parameter needs to be set in order to receive the HTTP 200 response below.
- default: -- (empty)
- full: Every element in type \"summary\", plus description, application, categories, tags, mappings
- summary: Returns summarized data change details specified in the model \"dataChangeSummary\"
 (required)
            limit: The maximum number of object data entries to be included in the response.
- default: 20
- max: 500
 (optional)
            name: The name of a data change.

Note: Either \"type\" or \"name\" query parameter must be set in order to receive the response as object \"dataChangeResponseList\" below.
- default: -- (empty)
 (optional)
            offset: The offset to the first object in a collection to include in the response.
default: 0
 (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/dataChanges"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if type_param is not None:
            params["type"] = type_param
        if limit is not None:
            params["limit"] = limit
        if name is not None:
            params["name"] = name
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_data_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_data_changes(
        self,
        dataChangeID: str,
        type_param: Optional[str] = None
    ) -> WorkdayResponse:
        """Gets data change associated with ID

        Args:
            dataChangeID: A reference to a Prism Analytics table. Example: The ID of the table.
 (required)
            type_param: How much information to be returned.
- default: -- (empty)
 (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/dataChanges/{dataChangeID}".replace("{dataChangeID}", str(dataChangeID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if type_param is not None:
            params["type"] = type_param

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_data_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_data_changes_activities(
        self,
        dataChangeID: str
    ) -> WorkdayResponse:
        """Execute data change by ID

        Args:
            dataChangeID: A reference to a Prism Analytics data change.
 (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/dataChanges/{dataChangeID}/activities".replace("{dataChangeID}", str(dataChangeID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_data_changes_activities {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_data_changes_activities(
        self,
        activityID: str,
        dataChangeID: str
    ) -> WorkdayResponse:
        """Get details of the activity specified by activityID

        Args:
            activityID: A reference to a Prism Analytics data change activity.
 (required)
            dataChangeID: A reference to a Prism Analytics data change.
 (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/dataChanges/{dataChangeID}/activities/{activityID}".replace("{activityID}", str(activityID)).replace("{dataChangeID}", str(dataChangeID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_data_changes_activities {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_data_changes_validate(
        self,
        dataChangeID: str
    ) -> WorkdayResponse:
        """Validate data change specified by dataChangeID

        Args:
            dataChangeID: A reference to a Prism Analytics data change.
 (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/dataChanges/{dataChangeID}/validate".replace("{dataChangeID}", str(dataChangeID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_data_changes_validate {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_data_changes_cancel(
        self,
        activityID: str,
        dataChangeID: str
    ) -> WorkdayResponse:
        """Cancel data change specified by dataChangeID and activityID

        Args:
            activityID: A reference to a Prism Analytics data change activity.
 (required)
            dataChangeID: A reference to a Prism Analytics data change.
 (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/dataChanges/{dataChangeID}/cancel/{activityID}".replace("{activityID}", str(activityID)).replace("{dataChangeID}", str(dataChangeID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_data_changes_cancel {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_file_containers(
        self
    ) -> WorkdayResponse:
        """Create new fileContainer

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/fileContainers"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_file_containers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_file_containers_files(
        self,
        fileContainerID: str
    ) -> WorkdayResponse:
        """Get all files for a file container

        Args:
            fileContainerID: A reference to a Prism Analytics File Container.
 (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/fileContainers/{fileContainerID}/files".replace("{fileContainerID}", str(fileContainerID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_file_containers_files {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_file_containers_files(
        self,
        fileContainerID: str
    ) -> WorkdayResponse:
        """Load file into file container

        Args:
            fileContainerID: A reference to a Prism Analytics File Container.
 (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/fileContainers/{fileContainerID}/files".replace("{fileContainerID}", str(fileContainerID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_file_containers_files {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_privacy_v1_activity_logging(
        self,
        from_param: Optional[str] = None,
        instancesReturned: Optional[int] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        returnUserActivityEntryCount: Optional[bool] = None,
        systemAccount: Optional[str] = None,
        taskId: Optional[str] = None,
        to: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of user activity log entries in a specified time frame.

        Args:
            from_param: (Required) The date and time of the earliest log entry. The default timezone is UTC/GMT. The time format is \"{yyyy}-{mm}-{dd}T{hh}:{mm}:{ss}Z\".  Example:  \"2021-05-18T13:45:14Z\" indicates May 18, 2021, 1:45PM UTC. (optional)
            instancesReturned: This number multiplied by 10,000 determines the total number of requested user activity instances. Example: A value of 5 requests a maximum of 50,000 instances. The default and maximum values are 25. By default, the method requests the maximum 250,000 instances. To fine-tune the performance, set this parameter to a lower number. While the instancesReturned parameter controls the total number of requested instances, the limit parameter controls the number of returned instances in a paginated response. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            returnUserActivityEntryCount: If true, returns only the total count of user activity instances for the specified parameters. (optional)
            systemAccount:  (optional)
            taskId:  (optional)
            to: (Required) The date and time of the latest log entry. The default timezone is UTC/GMT. The time format is \"{yyyy}-{mm}-{dd}T{hh}:{mm}:{ss}Z\".  Example:  \"2021-05-18T13:45:14Z\" indicates May 18, 2021, 1:45PM UTC. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/privacy/v1/activityLogging"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if from_param is not None:
            params["from"] = from_param
        if instancesReturned is not None:
            params["instancesReturned"] = instancesReturned
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if returnUserActivityEntryCount is not None:
            params["returnUserActivityEntryCount"] = returnUserActivityEntryCount
        if systemAccount is not None:
            params["systemAccount"] = systemAccount
        if taskId is not None:
            params["taskId"] = taskId
        if to is not None:
            params["to"] = to

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_privacy_v1_activity_logging {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_help_case_v4_external_records(
        self,
        ID: str,
        delinkExternalRecords: Dict[str, Any]
    ) -> WorkdayResponse:
        """Deletes an existing link instance between an external record and case.

        Args:
            ID: The Workday ID of the resource. (required)
            delinkExternalRecords:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/externalRecords/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if delinkExternalRecords is not None:
            if isinstance(delinkExternalRecords, dict):
                body.update(delinkExternalRecords)
            else:
                body["delinkExternalRecords"] = delinkExternalRecords

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_help_case_v4_external_records {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_help_case_v4_service_categories(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a service category with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/serviceCategories/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_help_case_v4_service_categories {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_help_case_v4_cases_reopen(
        self,
        ID: str,
        reopenReasonRequest: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates an existing resolved case instance

        Args:
            ID: The Workday ID of the resource. (required)
            reopenReasonRequest:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases/{ID}/reopen".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if reopenReasonRequest is not None:
            if isinstance(reopenReasonRequest, dict):
                body.update(reopenReasonRequest)
            else:
                body["reopenReasonRequest"] = reopenReasonRequest

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_help_case_v4_cases_reopen {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_case_v4_cases_timeline(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a list of comment timeline items for a case.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases/{ID}/timeline".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_case_v4_cases_timeline {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_help_case_v4_cases_comment(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        r"""Retrieves a comment timeline item for a \~case\~ with the specified comment timeline ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases/{ID}/comment/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_help_case_v4_cases_comment {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_case_v4_configuration(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves tenant setup configurations related to Help Case Management.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/configuration"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_case_v4_configuration {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_case_v4_case_suggestions(
        self,
        caseType: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a list of suggestions based on case type.

        Args:
            caseType: The Workday ID of the case type to retrieve suggestions for. You can use GET /helpCase/caseTypes/view to retrieve a list of case types and their IDs. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/caseSuggestions"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if caseType is not None:
            params["caseType"] = caseType
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_case_v4_case_suggestions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_help_case_v4_attachments(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Will return attachments

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/attachments/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_help_case_v4_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_help_case_v4_case_suggestions(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a list of suggestions based on case type.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/caseSuggestions/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_help_case_v4_case_suggestions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_case_v4_external_creators(
        self,
        email: Optional[str] = None,
        hideBlockedCreators: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        r"""Retrieves a collection of external contact details.

        Args:
            email: The email address that identifies the external \~case\~ contact. (optional)
            hideBlockedCreators: If true, blocked contacts are excluded from the response. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/externalCreators"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if email is not None:
            params["email"] = email
        if hideBlockedCreators is not None:
            params["hideBlockedCreators"] = hideBlockedCreators
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_case_v4_external_creators {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_help_case_v4_external_creators(
        self,
        externalCaseContact: Dict[str, Any]
    ) -> WorkdayResponse:
        r"""Creates external \~case\~ contacts.

        Args:
            externalCaseContact:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/externalCreators"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if externalCaseContact is not None:
            if isinstance(externalCaseContact, dict):
                body.update(externalCaseContact)
            else:
                body["externalCaseContact"] = externalCaseContact

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_help_case_v4_external_creators {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_case_v4_values_external_records_source(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/values/externalRecords/source/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_case_v4_values_external_records_source {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_case_v4_values_case_statuses_group_case_statuses(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/values/caseStatusesGroup/caseStatuses/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_case_v4_values_case_statuses_group_case_statuses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_case_v4_values_service_teams_group_service_teams(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/values/serviceTeamsGroup/serviceTeams/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_case_v4_values_service_teams_group_service_teams {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_help_case_v4_cases_timeline(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a comment timeline item for a case with the specified timeline ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases/{ID}/timeline/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_help_case_v4_cases_timeline {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_case_v4_cases(
        self,
        desc: Optional[bool] = None,
        flag: Optional[List[str]] = None,
        label: Optional[List[str]] = None,
        limit: Optional[int] = None,
        myCases: Optional[bool] = None,
        offset: Optional[int] = None,
        openCases: Optional[bool] = None,
        sort: Optional[str] = None,
        status: Optional[List[str]] = None,
        substatus: Optional[List[str]] = None,
        team: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """Retrieves a list of cases that the user is secured to view.

        Args:
            desc: If true, sorts results in descending order. (optional)
            flag: Retrieves cases with the assigned flag(s). (optional)
            label: Retrieves cases with the assigned label(s). (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            myCases: Retrieves cases owned by the processing user. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            openCases: Retrieves open cases and cases that were resolved or canceled less than 7 days ago. (optional)
            sort: The field to sort results by. The default is creationDate. Note: Currently supports creationDate only. (optional)
            status: Retrieves cases with the specified status(es). (optional)
            substatus: Retrieves cases with the specified substatus(es). (optional)
            team: Retrieves cases with the specified service team(s). (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if desc is not None:
            params["desc"] = desc
        if flag is not None:
            params["flag"] = flag
        if label is not None:
            params["label"] = label
        if limit is not None:
            params["limit"] = limit
        if myCases is not None:
            params["myCases"] = myCases
        if offset is not None:
            params["offset"] = offset
        if openCases is not None:
            params["openCases"] = openCases
        if sort is not None:
            params["sort"] = sort
        if status is not None:
            params["status"] = status
        if substatus is not None:
            params["substatus"] = substatus
        if team is not None:
            params["team"] = team

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_case_v4_cases {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_help_case_v4_cases(
        self,
        case: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a case.

        Args:
            case:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if case is not None:
            if isinstance(case, dict):
                body.update(case)
            else:
                body["case"] = case

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_help_case_v4_cases {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_help_case_v4_cases_internal_note_timeline(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        r"""Retrieves an internal note timeline item for a \~case\~ with the specified internal note timeline ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases/{ID}/internalNoteTimeline/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_help_case_v4_cases_internal_note_timeline {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_help_case_v4_cases_internal_note_timeline(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Deletes an internal note.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases/{ID}/internalNoteTimeline/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_help_case_v4_cases_internal_note_timeline {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_help_case_v4_cases_internal_note_timeline(
        self,
        ID: str,
        subresourceID: str,
        editInternalNoteRequest: Dict[str, Any]
    ) -> WorkdayResponse:
        """Edits an internal note.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            editInternalNoteRequest:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases/{ID}/internalNoteTimeline/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if editInternalNoteRequest is not None:
            if isinstance(editInternalNoteRequest, dict):
                body.update(editInternalNoteRequest)
            else:
                body["editInternalNoteRequest"] = editInternalNoteRequest

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_help_case_v4_cases_internal_note_timeline {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_case_v4_cases_comment(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        r"""Retrieves a list of comment timeline items for a \~case\~.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases/{ID}/comment".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_case_v4_cases_comment {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_help_case_v4_cases_comment(
        self,
        ID: str,
        caseCommentRequest: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            caseCommentRequest:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases/{ID}/comment".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if caseCommentRequest is not None:
            if isinstance(caseCommentRequest, dict):
                body.update(caseCommentRequest)
            else:
                body["caseCommentRequest"] = caseCommentRequest

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_help_case_v4_cases_comment {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_case_v4_cases_internal_note_timeline(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        r"""Retrieves a list of internal note timeline items for a \~case\~.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases/{ID}/internalNoteTimeline".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_case_v4_cases_internal_note_timeline {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_help_case_v4_cases_internal_note_timeline(
        self,
        ID: str,
        timelineNoteRequest: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            timelineNoteRequest:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases/{ID}/internalNoteTimeline".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if timelineNoteRequest is not None:
            if isinstance(timelineNoteRequest, dict):
                body.update(timelineNoteRequest)
            else:
                body["timelineNoteRequest"] = timelineNoteRequest

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_help_case_v4_cases_internal_note_timeline {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_case_v4_values_case_label_categories_group_case_label_categories(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/values/caseLabelCategoriesGroup/caseLabelCategories/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_case_v4_values_case_label_categories_group_case_label_categories {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_help_case_v4_external_creators(
        self,
        ID: str
    ) -> WorkdayResponse:
        r"""Retrieves contact details for a single external \~case\~ contact instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/externalCreators/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_help_case_v4_external_creators {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_help_case_v4_case_types(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a list of case types that a worker has access to.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/caseTypes/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_help_case_v4_case_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_help_case_v4_attachments(
        self,
        caseAttachment: Dict[str, Any]
    ) -> WorkdayResponse:
        """Uploads an attachment when creating a case.

        Args:
            caseAttachment:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/attachments"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if caseAttachment is not None:
            if isinstance(caseAttachment, dict):
                body.update(caseAttachment)
            else:
                body["caseAttachment"] = caseAttachment

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_help_case_v4_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_help_case_v4_cases(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a case with the specified ID that the user is secured to view.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_help_case_v4_cases {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_help_case_v4_cases(
        self,
        ID: str,
        editCase: Dict[str, Any]
    ) -> WorkdayResponse:
        """Edits a case.

        Args:
            ID: The Workday ID of the resource. (required)
            editCase:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/cases/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if editCase is not None:
            if isinstance(editCase, dict):
                body.update(editCase)
            else:
                body["editCase"] = editCase

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_help_case_v4_cases {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_case_v4_values_case_flags_group_case_flags(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/values/caseFlagsGroup/caseFlags/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_case_v4_values_case_flags_group_case_flags {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_case_v4_case_types(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        worker: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a list of case types that a worker has access to.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            worker: The worker to use to determine access to case types. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/caseTypes"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if worker is not None:
            params["worker"] = worker

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_case_v4_case_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_help_case_v4_service_categories(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        q: Optional[str] = None,
        worker: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves all parent service categories.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            q: The name to search for. Use this parameter to return only: service categories with a name that matches or is similar to this string; service categories that have child categories with names that match or are similar to this string; and case types with names or descriptions that are similar to this string. The default value is empty. (optional)
            worker: The ID of an alternate worker to use instead of the processing worker when determining access to case types. The default value is empty. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/serviceCategories"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if q is not None:
            params["q"] = q
        if worker is not None:
            params["worker"] = worker

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_help_case_v4_service_categories {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_help_case_v4_configuration(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves tenant setup configurations related to Help Case Management.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/configuration/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_help_case_v4_configuration {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_help_case_v4_external_records(
        self,
        externalRecords: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates and links external records to a Help case.

        Args:
            externalRecords:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/helpCase/v4/externalRecords"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if externalRecords is not None:
            if isinstance(externalRecords, dict):
                body.update(externalRecords)
            else:
                body["externalRecords"] = externalRecords

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_help_case_v4_external_records {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_personal_information(
        self,
        ID: str,
        country: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of personal information.

        Args:
            ID: The Workday ID of the resource. (required)
            country: Specifies the set of personal information by country that will be returned. If empty, the most recently updated set of personal information will be returned. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/personalInformation".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if country is not None:
            params["country"] = country
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_personal_information {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_person_v4_phone_validation(
        self,
        phoneNumberValidation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Validates phone number data to ensure it is valid for Workday.

        Args:
            phoneNumberValidation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/phoneValidation"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if phoneNumberValidation is not None:
            if isinstance(phoneNumberValidation, dict):
                body.update(phoneNumberValidation)
            else:
                body["phoneNumberValidation"] = phoneNumberValidation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_person_v4_phone_validation {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_countries(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves information about a country.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/countries/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_countries {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_home_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a home address.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/homeAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_home_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_home_contact_information_changes_web_addresses(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usageType: Optional[str] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieve all existing web addresses staged for update by the parent business process

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary web addresses. (optional)
            publicOnly: If true, returns only the IDs of the person's public web addresses. (optional)
            usageType: Specifies usage type, such as home or work. Only used if the service provides access to multiple usage types from the same endpoint. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/webAddresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usageType is not None:
            params["usageType"] = usageType
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_home_contact_information_changes_web_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_person_v4_home_contact_information_changes_web_addresses(
        self,
        ID: str,
        webAddressReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            webAddressReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/webAddresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if webAddressReference is not None:
            if isinstance(webAddressReference, dict):
                body.update(webAddressReference)
            else:
                body["webAddressReference"] = webAddressReference

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_person_v4_home_contact_information_changes_web_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_work_contact_information_changes_phone_numbers(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """A phone number as it exists staged for update by the parent business process.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/phoneNumbers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_work_contact_information_changes_phone_numbers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_person_v4_work_contact_information_changes_phone_numbers(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/phoneNumbers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_person_v4_work_contact_information_changes_phone_numbers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_person_v4_work_contact_information_changes_phone_numbers(
        self,
        ID: str,
        subresourceID: str,
        phoneReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            phoneReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/phoneNumbers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if phoneReference is not None:
            if isinstance(phoneReference, dict):
                body.update(phoneReference)
            else:
                body["phoneReference"] = phoneReference

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_person_v4_work_contact_information_changes_phone_numbers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_additional_names(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves an additional name.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/additionalNames/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_additional_names {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_name_components_hereditary(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/nameComponents/hereditary/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_name_components_hereditary {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_audio_name_pronunciation(
        self,
        ID: str,
        currentAudio: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of Audio Name Pronunciations

        Args:
            ID: The Workday ID of the resource. (required)
            currentAudio: Download only the currently active audio (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/audioNamePronunciation".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if currentAudio is not None:
            params["currentAudio"] = currentAudio
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_audio_name_pronunciation {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_personal_information(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a person's personal information.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/personalInformation/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_personal_information {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_work_contact_information_changes_instant_messengers(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """An instant messenger as it exists staged for update by the parent business process.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/instantMessengers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_work_contact_information_changes_instant_messengers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_person_v4_work_contact_information_changes_instant_messengers(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/instantMessengers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_person_v4_work_contact_information_changes_instant_messengers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_person_v4_work_contact_information_changes_instant_messengers(
        self,
        ID: str,
        subresourceID: str,
        instantMessengerReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            instantMessengerReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/instantMessengers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if instantMessengerReference is not None:
            if isinstance(instantMessengerReference, dict):
                body.update(instantMessengerReference)
            else:
                body["instantMessengerReference"] = instantMessengerReference

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_person_v4_work_contact_information_changes_instant_messengers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_home_contact_information_changes(
        self,
        ID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_home_contact_information_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_home_contact_information_changes_phone_numbers(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usageType: Optional[str] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieve all existing phone numbers staged for update by the parent business process

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary phone numbers. (optional)
            publicOnly: If true, returns only the IDs of the person's public phone numbers. (optional)
            usageType: Specifies usage type, such as home or work. Only used if the service provides access to multiple usage types from the same endpoint. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/phoneNumbers".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usageType is not None:
            params["usageType"] = usageType
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_home_contact_information_changes_phone_numbers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_person_v4_home_contact_information_changes_phone_numbers(
        self,
        ID: str,
        phoneReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            phoneReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/phoneNumbers".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if phoneReference is not None:
            if isinstance(phoneReference, dict):
                body.update(phoneReference)
            else:
                body["phoneReference"] = phoneReference

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_person_v4_home_contact_information_changes_phone_numbers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_photos(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of personal photos.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/photos".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_photos {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_person_v4_work_contact_information_changes_submit(
        self,
        ID: str,
        changeContactInformationEvent: Dict[str, Any]
    ) -> WorkdayResponse:
        """Submit the specified contact change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            changeContactInformationEvent:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/submit".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if changeContactInformationEvent is not None:
            if isinstance(changeContactInformationEvent, dict):
                body.update(changeContactInformationEvent)
            else:
                body["changeContactInformationEvent"] = changeContactInformationEvent

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_person_v4_work_contact_information_changes_submit {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_name_components_religious(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/nameComponents/religious/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_name_components_religious {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_name_components_honorary(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/nameComponents/honorary/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_name_components_honorary {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_preferred_name(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves the preferred name instance.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/preferredName".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_preferred_name {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_name_components_royal(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/nameComponents/royal/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_name_components_royal {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_work_contact_information_changes(
        self,
        ID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_work_contact_information_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_person_v4_work_contact_information_changes(
        self,
        ID: str,
        workContactChangeEvent: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            workContactChangeEvent:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if workContactChangeEvent is not None:
            if isinstance(workContactChangeEvent, dict):
                body.update(workContactChangeEvent)
            else:
                body["workContactChangeEvent"] = workContactChangeEvent

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_person_v4_work_contact_information_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_countries_address_components(
        self,
        ID: str,
        addressConfigurationFormat: Optional[str] = None,
        currentAddress: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        useWesternScript: Optional[bool] = None
    ) -> WorkdayResponse:
        """Retrieves the allowed address components and their configuration for the Country and a given Address Configuration Format.
The webServiceAlias of the returned address components map to the enterable fields when submitting address data in other POST/PUT/PATCH operations.

        Args:
            ID: The Workday ID of the resource. (required)
            addressConfigurationFormat: The Address Configuration Format to return values for.
Required. Failure to provide this will result in no address components being returned.
Available values are:
- DEFAULT_AREAS
- RECRUITING_FORMAT (optional)
            currentAddress: The existing address being updated.
Required when you use Default Format and a Country using Local Script to get component data for an existing address. Failure to provide this when appropriate may result in incorrect address component data being returned. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            useWesternScript: Enables Local Script components for Countries using Local Script in Default Format.
Optional.
When applicable, setting this value to true will enable Local Script components and enforce Western Components as optional. Local Components that are requireable will be enforced as required. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/countries/{ID}/addressComponents".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if addressConfigurationFormat is not None:
            params["addressConfigurationFormat"] = addressConfigurationFormat
        if currentAddress is not None:
            params["currentAddress"] = currentAddress
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if useWesternScript is not None:
            params["useWesternScript"] = useWesternScript

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_countries_address_components {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_photos(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a personal photo.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/photos/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_photos {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_work_instant_messengers(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of work instant messenger accounts usernames.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary instant messenger account usernames. (optional)
            publicOnly: If true, returns only the IDs of the person's public instant messenger usernames. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/workInstantMessengers".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_work_instant_messengers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_legal_name(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the legal name instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/legalName/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_legal_name {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_home_contact_information_changes_email_addresses(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usageType: Optional[str] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieve all existing addresses staged for update by the parent business process

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary email addresses. (optional)
            publicOnly: If true, returns only the IDs of the person's public email addresses. (optional)
            usageType: Specifies usage type, such as home or work. Only used if the service provides access to multiple usage types from the same endpoint. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/emailAddresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usageType is not None:
            params["usageType"] = usageType
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_home_contact_information_changes_email_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_person_v4_home_contact_information_changes_email_addresses(
        self,
        ID: str,
        emailAddressReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            emailAddressReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/emailAddresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if emailAddressReference is not None:
            if isinstance(emailAddressReference, dict):
                body.update(emailAddressReference)
            else:
                body["emailAddressReference"] = emailAddressReference

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_person_v4_home_contact_information_changes_email_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_work_contact_information_changes_instant_messengers(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usageType: Optional[str] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieve all existing instant messengers staged for update by the parent business process

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary instant messenger account usernames. (optional)
            publicOnly: If true, returns only the IDs of the person's public instant messenger account usernames. (optional)
            usageType: Specifies usage type, such as home or work. Only used if the service provides access to multiple usage types from the same endpoint. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/instantMessengers".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usageType is not None:
            params["usageType"] = usageType
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_work_contact_information_changes_instant_messengers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_person_v4_work_contact_information_changes_instant_messengers(
        self,
        ID: str,
        instantMessengerReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            instantMessengerReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/instantMessengers".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if instantMessengerReference is not None:
            if isinstance(instantMessengerReference, dict):
                body.update(instantMessengerReference)
            else:
                body["instantMessengerReference"] = instantMessengerReference

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_person_v4_work_contact_information_changes_instant_messengers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_work_emails(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of work email addresses.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary email addresses. (optional)
            publicOnly: If true, returns only the IDs of the person's public email addresses. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/workEmails".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_work_emails {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_home_addresses(
        self,
        ID: str,
        effective: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of home addresses.

        Args:
            ID: The Workday ID of the resource. (required)
            effective: The effective date of the person's addresses using the yyyy-mm-dd format. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary addresses. (optional)
            publicOnly: If true, returns only the IDs of the person's public addresses. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/homeAddresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if effective is not None:
            params["effective"] = effective
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_home_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_home_phones(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a home phone number.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/homePhones/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_home_phones {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_name_components_title(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/nameComponents/title/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_name_components_title {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_countries_name_components(
        self,
        ID: str,
        currentName: Optional[str] = None,
        limit: Optional[int] = None,
        nameConfigurationFormat: Optional[str] = None,
        offset: Optional[int] = None,
        useWesternScript: Optional[bool] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of configuration information about name components.

        Args:
            ID: The Workday ID of the resource. (required)
            currentName: The Workday ID of the person's current name being updated.
Required when you use Default Format and a Country using Local Script to get component data for an existing name. Failure to provide this when appropriate may result in incorrect name component data being returned. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            nameConfigurationFormat: The Name Configuration Format for which to return values.
Required. Failure to provide this will result in no name components being returned.
Available values are:
- RECRUITING_FORMAT - The name components specific to Recruiting.
- OTHER_FUNCTIONAL_AREAS - The name components for all other functional areas in Workday.
Example: nameConfigurationFormat=Name_Configuration_Format_ID=OTHER_FUNCTIONAL_AREAS (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            useWesternScript: If true, this method returns the set of allowed and required name components that uses Western Script.
The default is false. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/countries/{ID}/nameComponents".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if currentName is not None:
            params["currentName"] = currentName
        if limit is not None:
            params["limit"] = limit
        if nameConfigurationFormat is not None:
            params["nameConfigurationFormat"] = nameConfigurationFormat
        if offset is not None:
            params["offset"] = offset
        if useWesternScript is not None:
            params["useWesternScript"] = useWesternScript

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_countries_name_components {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_work_instant_messengers(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a work instant messenger account username.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/workInstantMessengers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_work_instant_messengers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_work_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a work address.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/workAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_work_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_home_contact_information_changes_addresses(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieve all existing addresses staged for update by the parent business process

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly:  (optional)
            usedFor:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/addresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_home_contact_information_changes_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_person_v4_home_contact_information_changes_addresses(
        self,
        ID: str,
        homeAddressReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            homeAddressReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/addresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if homeAddressReference is not None:
            if isinstance(homeAddressReference, dict):
                body.update(homeAddressReference)
            else:
                body["homeAddressReference"] = homeAddressReference

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_person_v4_home_contact_information_changes_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_home_contact_information_changes_instant_messengers(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """An instant messenger as it exists staged for update by the parent business process.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/instantMessengers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_home_contact_information_changes_instant_messengers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_person_v4_home_contact_information_changes_instant_messengers(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/instantMessengers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_person_v4_home_contact_information_changes_instant_messengers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_person_v4_home_contact_information_changes_instant_messengers(
        self,
        ID: str,
        subresourceID: str,
        instantMessengerReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            instantMessengerReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/instantMessengers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if instantMessengerReference is not None:
            if isinstance(instantMessengerReference, dict):
                body.update(instantMessengerReference)
            else:
                body["instantMessengerReference"] = instantMessengerReference

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_person_v4_home_contact_information_changes_instant_messengers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_common_phone_country_phone_codes(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/commonPhone/countryPhoneCodes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_common_phone_country_phone_codes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_work_phones(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of work phone numbers.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary phone numbers. (optional)
            publicOnly: If true, returns only the IDs of the person's public phone numbers. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/workPhones".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_work_phones {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_country_components_country_city(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/countryComponents/countryCity/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_country_components_country_city {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_home_contact_information_changes_web_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """A web address as it exists staged for update by the parent business process.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/webAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_home_contact_information_changes_web_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_person_v4_home_contact_information_changes_web_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/webAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_person_v4_home_contact_information_changes_web_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_person_v4_home_contact_information_changes_web_addresses(
        self,
        ID: str,
        subresourceID: str,
        webAddressReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            webAddressReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/webAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if webAddressReference is not None:
            if isinstance(webAddressReference, dict):
                body.update(webAddressReference)
            else:
                body["webAddressReference"] = webAddressReference

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_person_v4_home_contact_information_changes_web_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_name_components_salutation(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/nameComponents/salutation/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_name_components_salutation {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_audio_name_pronunciation(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves an Audio Name Pronunciation

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/audioNamePronunciation/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_audio_name_pronunciation {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_work_web_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a work web address.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/workWebAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_work_web_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_home_contact_information_changes_phone_numbers(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """A phone number as it exists staged for update by the parent business process.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/phoneNumbers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_home_contact_information_changes_phone_numbers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_person_v4_home_contact_information_changes_phone_numbers(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/phoneNumbers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_person_v4_home_contact_information_changes_phone_numbers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_person_v4_home_contact_information_changes_phone_numbers(
        self,
        ID: str,
        subresourceID: str,
        phoneReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            phoneReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/phoneNumbers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if phoneReference is not None:
            if isinstance(phoneReference, dict):
                body.update(phoneReference)
            else:
                body["phoneReference"] = phoneReference

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_person_v4_home_contact_information_changes_phone_numbers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_public_contact_information(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a person's public contact information.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/publicContactInformation/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_public_contact_information {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_home_phones(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of home phone numbers.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary phone numbers. (optional)
            publicOnly: If true, returns only the IDs of the person's public phone numbers. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/homePhones".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_home_phones {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_person_v4_home_contact_information_changes_submit(
        self,
        ID: str,
        changeContactInformationEvent: Dict[str, Any]
    ) -> WorkdayResponse:
        """Submit the specified contact change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            changeContactInformationEvent:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/submit".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if changeContactInformationEvent is not None:
            if isinstance(changeContactInformationEvent, dict):
                body.update(changeContactInformationEvent)
            else:
                body["changeContactInformationEvent"] = changeContactInformationEvent

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_person_v4_home_contact_information_changes_submit {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a person in your Workday tenant.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_public_contact_information(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of public contact information.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/publicContactInformation".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_public_contact_information {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_personal_information_country_populated_country(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/personalInformationCountry/populatedCountry/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_personal_information_country_populated_country {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_name_components_social(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/nameComponents/social/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_name_components_social {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_legal_name(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves the legal name instance.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/legalName".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_legal_name {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_name_components_professional(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/nameComponents/professional/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_name_components_professional {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        universal_ID: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a person in your Workday tenant.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            universal_ID: The Universal ID of the person you want to retrieve. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if universal_ID is not None:
            params["universal_ID"] = universal_ID

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_home_web_addresses(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of home web addresses.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary web addresses. (optional)
            publicOnly: If true, returns only the IDs of the person's public web addresses. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/homeWebAddresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_home_web_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_preferred_name(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the preferred name instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/preferredName/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_preferred_name {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_home_contact_information_changes_instant_messengers(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usageType: Optional[str] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieve all existing instant messengers staged for update by the parent business process

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary instant messenger account usernames. (optional)
            publicOnly: If true, returns only the IDs of the person's public instant messenger account usernames. (optional)
            usageType: Specifies usage type, such as home or work. Only used if the service provides access to multiple usage types from the same endpoint. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/instantMessengers".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usageType is not None:
            params["usageType"] = usageType
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_home_contact_information_changes_instant_messengers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_person_v4_home_contact_information_changes_instant_messengers(
        self,
        ID: str,
        instantMessengerReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            instantMessengerReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/instantMessengers".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if instantMessengerReference is not None:
            if isinstance(instantMessengerReference, dict):
                body.update(instantMessengerReference)
            else:
                body["instantMessengerReference"] = instantMessengerReference

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_person_v4_home_contact_information_changes_instant_messengers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_country_components_country(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/countryComponents/country/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_country_components_country {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_name_components_academic(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/nameComponents/academic/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_name_components_academic {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_additional_names(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of additional names.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/additionalNames".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_additional_names {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_work_addresses(
        self,
        ID: str,
        effective: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of work addresses.

        Args:
            ID: The Workday ID of the resource. (required)
            effective: The effective date of the person's addresses using the yyyy-mm-dd format. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary addresses. (optional)
            publicOnly: If true, returns only the IDs of the person's public addresses. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/workAddresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if effective is not None:
            params["effective"] = effective
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_work_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_work_web_addresses(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of work web addresses.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary web addresses. (optional)
            publicOnly: If true, returns only the IDs of the person's public web addresses. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/workWebAddresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_work_web_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_work_contact_information_changes_web_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """A web address as it exists staged for update by the parent business process.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/webAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_work_contact_information_changes_web_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_person_v4_work_contact_information_changes_web_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/webAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_person_v4_work_contact_information_changes_web_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_person_v4_work_contact_information_changes_web_addresses(
        self,
        ID: str,
        subresourceID: str,
        webAddressReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            webAddressReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/webAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if webAddressReference is not None:
            if isinstance(webAddressReference, dict):
                body.update(webAddressReference)
            else:
                body["webAddressReference"] = webAddressReference

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_person_v4_work_contact_information_changes_web_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_work_phones(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a work phone number.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/workPhones/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_work_phones {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_home_emails(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a home email address.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/homeEmails/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_home_emails {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_home_instant_messengers(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a home instant messenger account username.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/homeInstantMessengers/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_home_instant_messengers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_work_emails(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a work email address.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/workEmails/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_work_emails {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_home_contact_information_changes_email_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """An email address as it exists staged for update by the parent business process.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/emailAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_home_contact_information_changes_email_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_person_v4_home_contact_information_changes_email_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/emailAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_person_v4_home_contact_information_changes_email_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_person_v4_home_contact_information_changes_email_addresses(
        self,
        ID: str,
        subresourceID: str,
        emailAddressReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            emailAddressReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/emailAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if emailAddressReference is not None:
            if isinstance(emailAddressReference, dict):
                body.update(emailAddressReference)
            else:
                body["emailAddressReference"] = emailAddressReference

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_person_v4_home_contact_information_changes_email_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_personal_information_country_allowed_country(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/personalInformationCountry/allowedCountry/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_personal_information_country_allowed_country {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_work_contact_information_changes_phone_numbers(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usageType: Optional[str] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieve all existing phone numbers staged for update by the parent business process

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary phone numbers. (optional)
            publicOnly: If true, returns only the IDs of the person's public phone numbers. (optional)
            usageType: Specifies usage type, such as home or work. Only used if the service provides access to multiple usage types from the same endpoint. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/phoneNumbers".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usageType is not None:
            params["usageType"] = usageType
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_work_contact_information_changes_phone_numbers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_person_v4_work_contact_information_changes_phone_numbers(
        self,
        ID: str,
        phoneReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            phoneReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/phoneNumbers".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if phoneReference is not None:
            if isinstance(phoneReference, dict):
                body.update(phoneReference)
            else:
                body["phoneReference"] = phoneReference

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_person_v4_work_contact_information_changes_phone_numbers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_work_contact_information_changes_email_addresses(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usageType: Optional[str] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieve all existing addresses staged for update by the parent business process

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary email addresses. (optional)
            publicOnly: If true, returns only the IDs of the person's public email addresses. (optional)
            usageType: Specifies usage type, such as home or work. Only used if the service provides access to multiple usage types from the same endpoint. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/emailAddresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usageType is not None:
            params["usageType"] = usageType
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_work_contact_information_changes_email_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_person_v4_work_contact_information_changes_email_addresses(
        self,
        ID: str,
        emailAddressReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            emailAddressReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/emailAddresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if emailAddressReference is not None:
            if isinstance(emailAddressReference, dict):
                body.update(emailAddressReference)
            else:
                body["emailAddressReference"] = emailAddressReference

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_person_v4_work_contact_information_changes_email_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_people_home_web_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a home web address.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/homeWebAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_people_home_web_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_work_contact_information_changes_email_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """An email address as it exists staged for update by the parent business process.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/emailAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_work_contact_information_changes_email_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_person_v4_work_contact_information_changes_email_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/emailAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_person_v4_work_contact_information_changes_email_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_person_v4_work_contact_information_changes_email_addresses(
        self,
        ID: str,
        subresourceID: str,
        emailAddressReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            emailAddressReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/emailAddresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if emailAddressReference is not None:
            if isinstance(emailAddressReference, dict):
                body.update(emailAddressReference)
            else:
                body["emailAddressReference"] = emailAddressReference

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_person_v4_work_contact_information_changes_email_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_home_instant_messengers(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of home instant messenger account usernames.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary instant messenger account usernames. (optional)
            publicOnly: If true, returns only the IDs of the person's public instant messenger usernames. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/homeInstantMessengers".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_home_instant_messengers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_work_contact_information_changes_web_addresses(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usageType: Optional[str] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieve all existing web addresses staged for update by the parent business process

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary web addresses. (optional)
            publicOnly: If true, returns only the IDs of the person's public web addresses. (optional)
            usageType: Specifies usage type, such as home or work. Only used if the service provides access to multiple usage types from the same endpoint. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/webAddresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usageType is not None:
            params["usageType"] = usageType
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_work_contact_information_changes_web_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_person_v4_work_contact_information_changes_web_addresses(
        self,
        ID: str,
        webAddressReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            webAddressReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/webAddresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if webAddressReference is not None:
            if isinstance(webAddressReference, dict):
                body.update(webAddressReference)
            else:
                body["webAddressReference"] = webAddressReference

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_person_v4_work_contact_information_changes_web_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_people_home_emails(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        primaryOnly: Optional[bool] = None,
        publicOnly: Optional[bool] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of home email addresses.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            primaryOnly: If true, returns only the IDs of the person's primary email addresses. (optional)
            publicOnly: If true, returns only the IDs of the person's public email addresses. (optional)
            usedFor: Specifies usage behavior, such as mailing, billing, or shipping.
Optional. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/people/{ID}/homeEmails".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if primaryOnly is not None:
            params["primaryOnly"] = primaryOnly
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_people_home_emails {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_home_contact_information_changes_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """An address as it exists staged for update by the parent business process.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/addresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_home_contact_information_changes_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_person_v4_home_contact_information_changes_addresses(
        self,
        ID: str,
        subresourceID: str,
        homeAddressReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            homeAddressReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/addresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if homeAddressReference is not None:
            if isinstance(homeAddressReference, dict):
                body.update(homeAddressReference)
            else:
                body["homeAddressReference"] = homeAddressReference

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_person_v4_home_contact_information_changes_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_person_v4_home_contact_information_changes_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/homeContactInformationChanges/{ID}/addresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_person_v4_home_contact_information_changes_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_person_v4_work_contact_information_changes_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """An address as it exists staged for update by the parent business process.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/addresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_person_v4_work_contact_information_changes_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_person_v4_work_contact_information_changes_addresses(
        self,
        ID: str,
        subresourceID: str,
        workAddressReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            workAddressReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/addresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if workAddressReference is not None:
            if isinstance(workAddressReference, dict):
                body.update(workAddressReference)
            else:
                body["workAddressReference"] = workAddressReference

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_person_v4_work_contact_information_changes_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_person_v4_work_contact_information_changes_addresses(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/addresses/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_person_v4_work_contact_information_changes_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_country_components_country_region(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/countryComponents/countryRegion/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_country_components_country_region {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_work_contact_information_changes_addresses(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        publicOnly: Optional[bool] = None,
        usedFor: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieve all existing addresses staged for update by the parent business process

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            publicOnly:  (optional)
            usedFor:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/addresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if publicOnly is not None:
            params["publicOnly"] = publicOnly
        if usedFor is not None:
            params["usedFor"] = usedFor

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_work_contact_information_changes_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_person_v4_work_contact_information_changes_addresses(
        self,
        ID: str,
        workAddressReference: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            workAddressReference:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/workContactInformationChanges/{ID}/addresses".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if workAddressReference is not None:
            if isinstance(workAddressReference, dict):
                body.update(workAddressReference)
            else:
                body["workAddressReference"] = workAddressReference

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_person_v4_work_contact_information_changes_addresses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_countries(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of information about countries.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/countries"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_countries {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_person_v4_values_common_phone_phone_device_types(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/person/v4/values/commonPhone/phoneDeviceTypes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_person_v4_values_common_phone_phone_device_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_revenue_v1_billable_transactions_billing_rate_application(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of billing rate applications for the specified billable transaction.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/revenue/v1/billableTransactions/{ID}/billingRateApplication".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_revenue_v1_billable_transactions_billing_rate_application {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_revenue_v1_billable_transactions(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single billable transaction instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/revenue/v1/billableTransactions/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_revenue_v1_billable_transactions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_revenue_v1_billable_transactions(
        self,
        ID: str,
        editBillableTransaction: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates an existing billable transaction instance.

        Args:
            ID: The Workday ID of the resource. (required)
            editBillableTransaction:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/revenue/v1/billableTransactions/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if editBillableTransaction is not None:
            if isinstance(editBillableTransaction, dict):
                body.update(editBillableTransaction)
            else:
                body["editBillableTransaction"] = editBillableTransaction

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_revenue_v1_billable_transactions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_revenue_v1_billable_transactions_billing_rate_application(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single billing rate application instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/revenue/v1/billableTransactions/{ID}/billingRateApplication/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_revenue_v1_billable_transactions_billing_rate_application {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_revenue_v1_billable_transactions(
        self,
        billingStatus: Optional[List[str]] = None,
        customer: Optional[str] = None,
        fromDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        phase: Optional[str] = None,
        project: Optional[str] = None,
        spendCategory: Optional[List[str]] = None,
        task: Optional[str] = None,
        timeCode: Optional[str] = None,
        toDate: Optional[str] = None,
        transactionSource: Optional[str] = None,
        worker: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of billable transactions.

        Args:
            billingStatus: Filters the billable transactions by status. Specify the Workday ID of the status. You can specify multiple status query parameters.

Valid values:

* 3d46fe27ed464f9aaaddcd510731c5f0 - Approval In Process

* b8f58d21282249c9b8ad2391adb3ef9d - Awaiting Review

* 62a1b884a62d448899b34628026efcae - Billed

* 275424eaf82743ed8d17d755cd8d91a7 - Billing In Progress

* 743da2a9c0fc45d0843702e7385a79ff - Do Not Bill

* 2cc0607f96b4433f860134953788caab - On Hold

* 46328a05acf110000b5601a2b76a008b - Partially Billed

* 8c4f33a55c774494a07ec40dd3b6b44f - Ready To Bill

* aeb6a01a4a8a4a2780582fc5c665ef57 - Unbillable (optional)
            customer: The Workday ID of the customer associated with the project for the billable transaction. To get a valid ID, you can call GET /customers in the Customer Accounts REST service. (optional)
            fromDate: Filters the billable transactions with transaction date on or after the specified date. Use the yyyy-mm-dd format. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            phase: The Workday ID of the project phase associated with the billable transaction for the time entry. To get a valid ID, call GET /planPhases in the Projects REST service. (optional)
            project: The Workday ID of the project associated with the billable transactions. To get a valid ID, you can call GET /projects in the Projects REST service. (optional)
            spendCategory: The Workday ID of the spend category for the billable transaction associated with the expense report line. (optional)
            task: The Workday ID of the project task associated with the billable transaction for the time entry.  To get a valid ID, call GET /planTasks in the Projects REST service. (optional)
            timeCode: The Workday ID of the time code for the billable transaction associated with the time entry. (optional)
            toDate: Filters the billable transactions with transaction date on or before the specified date. Use the yyyy-mm-dd format. (optional)
            transactionSource: Filters the billable transactions by transaction source. Specify the Workday ID of the transaction source.

Valid values:

* 3c4a245325f44745b13a4553c4810524 - Expense

* 381908377f9c100005d7078e86a2003e - Misc Expense

* 6b404c3fa9f34512b0490da5f4237573 - Supplier Invoice

* 7a55a775b63b4b9b8a5b3722fc1e4556 - Time (optional)
            worker: The Workday ID of the worker associated with the billable transaction. To get a valid ID, call GET /workers in the Staffing service. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/revenue/v1/billableTransactions"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if billingStatus is not None:
            params["billingStatus"] = billingStatus
        if customer is not None:
            params["customer"] = customer
        if fromDate is not None:
            params["fromDate"] = fromDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if phase is not None:
            params["phase"] = phase
        if project is not None:
            params["project"] = project
        if spendCategory is not None:
            params["spendCategory"] = spendCategory
        if task is not None:
            params["task"] = task
        if timeCode is not None:
            params["timeCode"] = timeCode
        if toDate is not None:
            params["toDate"] = toDate
        if transactionSource is not None:
            params["transactionSource"] = transactionSource
        if worker is not None:
            params["worker"] = worker

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_revenue_v1_billable_transactions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_requisitions_attachments(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/attachments?type=getFileContent".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_requisitions_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_procurement_v5_requisitions_attachments(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the metadata or the attachment content of the specified requisition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/attachments/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_procurement_v5_requisitions_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_procurement_v5_requisitions_attachments(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Deletes the specified requisition attachment.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/attachments/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_procurement_v5_requisitions_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_procurement_v5_requisitions_attachments(
        self,
        ID: str,
        subresourceID: str,
        businessDocumenAttachmentRepresentationEdit: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the metadata of an existing attachment instance for a requisition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            businessDocumenAttachmentRepresentationEdit:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/attachments/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if businessDocumenAttachmentRepresentationEdit is not None:
            if isinstance(businessDocumenAttachmentRepresentationEdit, dict):
                body.update(businessDocumenAttachmentRepresentationEdit)
            else:
                body["businessDocumenAttachmentRepresentationEdit"] = businessDocumenAttachmentRepresentationEdit

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_procurement_v5_requisitions_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_resolved_worktags(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/resolvedWorktags/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_resolved_worktags {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_procurement_v5_purchase_orders(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a purchase order.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/purchaseOrders/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_procurement_v5_purchase_orders {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_procurement_v5_requisitions_related_purchase_orders(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a related purchase order for the specified requisition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/relatedPurchaseOrders/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_procurement_v5_requisitions_related_purchase_orders {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_procurement_v5_requisitions_requisition_lines(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a requisition line for the specified requisition.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/requisitionLines/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_procurement_v5_requisitions_requisition_lines {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_procurement_v5_requisitions_requisition_lines(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Deletes the specified requisition line.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/requisitionLines/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_procurement_v5_requisitions_requisition_lines {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_procurement_v5_requisitions_requisition_lines(
        self,
        ID: str,
        subresourceID: str,
        addRequisitionLineRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Edits a specific requisition line for the requisition with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            addRequisitionLineRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/requisitionLines/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if addRequisitionLineRepresentation is not None:
            if isinstance(addRequisitionLineRepresentation, dict):
                body.update(addRequisitionLineRepresentation)
            else:
                body["addRequisitionLineRepresentation"] = addRequisitionLineRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_procurement_v5_requisitions_requisition_lines {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_requesters(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/requesters/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_requesters {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_companies(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/companies/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_companies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_procurement_v5_requisition_templates(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves the goods and service line details of a requisition template.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitionTemplates/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_procurement_v5_requisition_templates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_order_from_connection(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/orderFromConnection/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_order_from_connection {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_ship_to_address(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/shipToAddress/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_ship_to_address {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_resource_provider(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/resourceProvider/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_resource_provider {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_procurement_v5_requisitions_close(
        self,
        ID: str,
        closeRequisitionRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Closes a specified completed requisition.

        Args:
            ID: The Workday ID of the resource. (required)
            closeRequisitionRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/close".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if closeRequisitionRepresentation is not None:
            if isinstance(closeRequisitionRepresentation, dict):
                body.update(closeRequisitionRepresentation)
            else:
                body["closeRequisitionRepresentation"] = closeRequisitionRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_procurement_v5_requisitions_close {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_requisitions(
        self,
        externalSourceableId: Optional[str] = None,
        externalSystemId: Optional[str] = None,
        fromDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        requester: Optional[str] = None,
        requisitionType: Optional[List[str]] = None,
        submittedBy: Optional[str] = None,
        submittedByPerson: Optional[str] = None,
        submittedBySupplier: Optional[List[str]] = None,
        toDate: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of requisitions.

        Args:
            externalSourceableId:  (optional)
            externalSystemId:  (optional)
            fromDate: Filters the requisitions with document date on or after the specified date. Use the yyyy-mm-dd format. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            requester: Filters the requisitions by requester. Specify the Workday ID of the worker who requested the requisition. (optional)
            requisitionType: Filters the requisitions by type. Specify the Workday ID of the requisition type. You can specify multiple requisitionType query parameters. (optional)
            submittedBy: Filters the requisitions by the Worker who submitted the requisition. Specify the Workday ID or the reference ID of the worker. You can use a returned id from GET /workers in the Staffing REST web service. (optional)
            submittedByPerson: Filters the requisitions by the Person who submitted the requisition. Specify the Workday ID or the reference ID of the person. (optional)
            submittedBySupplier: Filters the requisitions by the supplier who submitted the requisition. Specify the Workday ID or the reference ID of the supplier. You can specify multiple submittedBySupplier query parameters. (optional)
            toDate: Filters the requisitions with document date on or before the specified date. Use the yyyy-mm-dd format. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if externalSourceableId is not None:
            params["externalSourceableId"] = externalSourceableId
        if externalSystemId is not None:
            params["externalSystemId"] = externalSystemId
        if fromDate is not None:
            params["fromDate"] = fromDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if requester is not None:
            params["requester"] = requester
        if requisitionType is not None:
            params["requisitionType"] = requisitionType
        if submittedBy is not None:
            params["submittedBy"] = submittedBy
        if submittedByPerson is not None:
            params["submittedByPerson"] = submittedByPerson
        if submittedBySupplier is not None:
            params["submittedBySupplier"] = submittedBySupplier
        if toDate is not None:
            params["toDate"] = toDate

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_requisitions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_procurement_v5_requisitions(
        self,
        createRequisitionRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a requisition.

        Args:
            createRequisitionRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if createRequisitionRepresentation is not None:
            if isinstance(createRequisitionRepresentation, dict):
                body.update(createRequisitionRepresentation)
            else:
                body["createRequisitionRepresentation"] = createRequisitionRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_procurement_v5_requisitions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_deliver_to_location(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/deliverToLocation/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_deliver_to_location {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_spend_category(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/spendCategory/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_spend_category {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_procurement_v5_requisitions_cancel(
        self,
        ID: str,
        cancelRequisitionRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Cancels an existing requisition.

        Args:
            ID: The Workday ID of the resource. (required)
            cancelRequisitionRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/cancel".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if cancelRequisitionRepresentation is not None:
            if isinstance(cancelRequisitionRepresentation, dict):
                body.update(cancelRequisitionRepresentation)
            else:
                body["cancelRequisitionRepresentation"] = cancelRequisitionRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_procurement_v5_requisitions_cancel {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_supplier_contract(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/supplierContract/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_supplier_contract {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_requisitions_related_purchase_orders(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of related purchase orders.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/relatedPurchaseOrders".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_requisitions_related_purchase_orders {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_unit_of_measure(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/unitOfMeasure/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_unit_of_measure {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_sourcing_buyer(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/sourcingBuyer/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_sourcing_buyer {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_line_company(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/lineCompany/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_line_company {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_inventory_site(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/inventorySite/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_inventory_site {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_requisition_templates(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of requisition templates.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitionTemplates"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_requisition_templates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_currencies(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/currencies/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_currencies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_procurement_v5_requisitions(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a requisition.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_procurement_v5_requisitions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_procurement_v5_requisitions(
        self,
        ID: str,
        editRequisitionRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates the header of an existing requisition.

        Args:
            ID: The Workday ID of the resource. (required)
            editRequisitionRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if editRequisitionRepresentation is not None:
            if isinstance(editRequisitionRepresentation, dict):
                body.update(editRequisitionRepresentation)
            else:
                body["editRequisitionRepresentation"] = editRequisitionRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_procurement_v5_requisitions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_procurement_v5_requisitions_attachments_1(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/attachments/{subresourceID}?type=getFileContent".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_procurement_v5_requisitions_attachments_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_requesting_entity(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/requestingEntity/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_requesting_entity {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_purchase_orders(
        self,
        buyer: Optional[List[str]] = None,
        company: Optional[List[str]] = None,
        excludeCanceled: Optional[bool] = None,
        excludeClosed: Optional[bool] = None,
        fromDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        orderFromConnection: Optional[List[str]] = None,
        status: Optional[List[str]] = None,
        submittedBy: Optional[List[str]] = None,
        supplier: Optional[List[str]] = None,
        toDate: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of purchase orders.

        Args:
            buyer: Filters the purchase orders by buyer. Specify the Workday ID of the worker assigned as buyer on the purchase order. You can specify multiple buyer query parameters. (optional)
            company: Filters the purchase orders by company. Specify the Workday ID of the company. You can specify multiple company query parameters. (optional)
            excludeCanceled: If true, this method excludes the purchase orders with Canceled status. The default is false. (optional)
            excludeClosed: If true, this method excludes the purchase orders with Closed status. The default is false. (optional)
            fromDate: Filters the purchase orders with document date on or after the specified date. Use the yyyy-mm-dd format. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            orderFromConnection: Filters the purchase orders by supplier order-from connections. Specify the Workday ID of the order-from connection. You can specify multiple order-from connection query parameters. (optional)
            status: Filters the purchase orders by status. Specify the Workday ID of the status. You can specify multiple status query parameters.

Valid values:

* 8a54a80900cb4114b62f82ed86e495f7 - Pending Issue

* dc76c312446c11de98360015c5e6daf6 - Issued

* dc76c8bc446c11de98360015c5e6daf6 - In Progress

* dc76c4fc446c11de98360015c5e6daf6 - Draft

* dc76c7cc446c11de98360015c5e6daf6 - Denied

* 24f0f71de78540cbb1445ba9e5e94d17 - Closed

* bd5a732c160c4e84b350ba4d6f7c10c5 - Change Order In Progress

* dc76c9b6446c11de98360015c5e6daf6 - Canceled

* 91b0d382d50848e898733757caa9f84a - Approved (optional)
            submittedBy: Filters the purchase orders by the worker who submitted the purchase order. Specify the Workday ID of the worker. You can specify multiple submittedBy query parameters. You can use a returned id from GET /workers in the Staffing REST web service. (optional)
            supplier: Filters the purchase orders by supplier. Specify the Workday ID of the supplier. You can specify multiple supplier query parameters. (optional)
            toDate: Filters the purchase orders with document date on or before the specified date. Use the yyyy-mm-dd format. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/purchaseOrders"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if buyer is not None:
            params["buyer"] = buyer
        if company is not None:
            params["company"] = company
        if excludeCanceled is not None:
            params["excludeCanceled"] = excludeCanceled
        if excludeClosed is not None:
            params["excludeClosed"] = excludeClosed
        if fromDate is not None:
            params["fromDate"] = fromDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if orderFromConnection is not None:
            params["orderFromConnection"] = orderFromConnection
        if status is not None:
            params["status"] = status
        if submittedBy is not None:
            params["submittedBy"] = submittedBy
        if supplier is not None:
            params["supplier"] = supplier
        if toDate is not None:
            params["toDate"] = toDate

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_purchase_orders {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_requisitions_attachments_1(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves the metadata of the attachments for the specified requisition.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/attachments".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_requisitions_attachments_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_procurement_v5_requisitions_attachments(
        self,
        ID: str,
        businessDocumentAttachmentRepresentationCreate: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a new attachment for the specified requisition.

        Args:
            ID: The Workday ID of the resource. (required)
            businessDocumentAttachmentRepresentationCreate:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/attachments".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if businessDocumentAttachmentRepresentationCreate is not None:
            if isinstance(businessDocumentAttachmentRepresentationCreate, dict):
                body.update(businessDocumentAttachmentRepresentationCreate)
            else:
                body["businessDocumentAttachmentRepresentationCreate"] = businessDocumentAttachmentRepresentationCreate

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_procurement_v5_requisitions_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_requisition_types(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/requisitionTypes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_requisition_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_par_location(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/parLocation/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_par_location {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_commodity_codes(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/commodityCodes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_commodity_codes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_procurement_v5_requisitions_requisition_events(
        self,
        ID: str,
        submitFinancialEventRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Submit Requisition to Business Process

        Args:
            ID: The Workday ID of the resource. (required)
            submitFinancialEventRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/requisitionEvents".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if submitFinancialEventRepresentation is not None:
            if isinstance(submitFinancialEventRepresentation, dict):
                body.update(submitFinancialEventRepresentation)
            else:
                body["submitFinancialEventRepresentation"] = submitFinancialEventRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_procurement_v5_requisitions_requisition_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_values_requisitions_group_worktags(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/values/requisitionsGroup/worktags/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_values_requisitions_group_worktags {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_procurement_v5_requisitions_requisition_lines(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of requisition lines.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/requisitionLines".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_procurement_v5_requisitions_requisition_lines {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_procurement_v5_requisitions_requisition_lines(
        self,
        ID: str,
        addRequisitionLineRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates requisition lines for the specified requisition.

        Args:
            ID: The Workday ID of the resource. (required)
            addRequisitionLineRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/procurement/v5/requisitions/{ID}/requisitionLines".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if addRequisitionLineRepresentation is not None:
            if isinstance(addRequisitionLineRepresentation, dict):
                body.update(addRequisitionLineRepresentation)
            else:
                body["addRequisitionLineRepresentation"] = addRequisitionLineRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_procurement_v5_requisitions_requisition_lines {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_recruiting_v4_job_postings_questionnaire(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single questionnaire for the specified job posting ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/jobPostings/{ID}/questionnaire/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_recruiting_v4_job_postings_questionnaire {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_recruiting_v4_interviews(
        self,
        ID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/interviews/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_recruiting_v4_interviews {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_recruiting_v4_values_common_countries(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/values/common/countries/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_recruiting_v4_values_common_countries {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_recruiting_v4_prospects(
        self,
        prospectSummary: Dict[str, Any]
    ) -> WorkdayResponse:
        r"""Create \~prospects\~.

        Args:
            prospectSummary:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if prospectSummary is not None:
            if isinstance(prospectSummary, dict):
                body.update(prospectSummary)
            else:
                body["prospectSummary"] = prospectSummary

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_recruiting_v4_prospects {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_recruiting_v4_prospects_languages(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        r"""Retrieves the languages of a single \~prospect\~ instance.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/languages".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_recruiting_v4_prospects_languages {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_recruiting_v4_prospects_languages(
        self,
        ID: str,
        candidateLanguageSkillDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        r"""Creates languages for a \~prospect\~.

        Args:
            ID: The Workday ID of the resource. (required)
            candidateLanguageSkillDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/languages".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if candidateLanguageSkillDetails is not None:
            if isinstance(candidateLanguageSkillDetails, dict):
                body.update(candidateLanguageSkillDetails)
            else:
                body["candidateLanguageSkillDetails"] = candidateLanguageSkillDetails

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_recruiting_v4_prospects_languages {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_recruiting_v4_interviews(
        self,
        interviewStatus: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """No summary

        Args:
            interviewStatus: \"All applicable interview statuses for an Interview event. Statuses can be:
 * AWAITING_ME - An in-progress Interview event is waiting for the logged-in user's feedback.
 * COMPLETED - An Interview event is complete.
 * FEEDBACK_COMPLETE - All interview feedback for this in-progress event was submitted, but the Interview event isnt awaiting the Make Interview Decision step.
 * NOT_SCHEDULED - An interview hasn't been scheduled for an in-progress Interview event.
 * PENDING_FEEDBACK - An in-progress Interview event is waiting for interviewer feedback.
 * SCHEDULED - An interview is scheduled for an in-progress Interview event.
 * SUBMITTED_FEEDBACK - The logged-in user submitted feedback for an in-progress Interview event.
 * MAKE_INTERVIEW_DECISION - The make an interview decision step for the candidate.\" (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/interviews"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if interviewStatus is not None:
            params["interviewStatus"] = interviewStatus
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_recruiting_v4_interviews {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_recruiting_v4_prospects_skills(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        r"""Retrieves the skills of a single \~prospect\~ instance.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/skills".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_recruiting_v4_prospects_skills {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_recruiting_v4_prospects_skills(
        self,
        ID: str,
        candidateSkillItemDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        r"""Creates skills for a \~prospect\~.

        Args:
            ID: The Workday ID of the resource. (required)
            candidateSkillItemDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/skills".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if candidateSkillItemDetails is not None:
            if isinstance(candidateSkillItemDetails, dict):
                body.update(candidateSkillItemDetails)
            else:
                body["candidateSkillItemDetails"] = candidateSkillItemDetails

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_recruiting_v4_prospects_skills {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_recruiting_v4_prospects_experiences(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        r"""Retrieves a single experience instance for a \~prospect\~.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/experiences/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_recruiting_v4_prospects_experiences {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_recruiting_v4_job_postings_candidate_availability_template(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a single instance of the candidate availability template version.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/jobPostings/{ID}/candidateAvailabilityTemplate".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_recruiting_v4_job_postings_candidate_availability_template {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_recruiting_v4_job_postings(
        self,
        category: Optional[List[str]] = None,
        jobPosting: Optional[List[str]] = None,
        jobRequisition: Optional[List[str]] = None,
        jobSite: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of job postings.

        Args:
            category:  (optional)
            jobPosting: Job Posting for Job Posting Anchor (optional)
            jobRequisition: Job Requisition for Job Posting Anchor (optional)
            jobSite:  (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/jobPostings"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if category is not None:
            params["category"] = category
        if jobPosting is not None:
            params["jobPosting"] = jobPosting
        if jobRequisition is not None:
            params["jobRequisition"] = jobRequisition
        if jobSite is not None:
            params["jobSite"] = jobSite
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_recruiting_v4_job_postings {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_recruiting_v4_prospects_languages(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        r"""Retrieves a single language instance for a \~prospect\~.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/languages/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_recruiting_v4_prospects_languages {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_recruiting_v4_prospects_educations(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        r"""Retrieves the education of a single \~prospect\~ instance.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/educations".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_recruiting_v4_prospects_educations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_recruiting_v4_prospects_educations(
        self,
        ID: str,
        candidateEducationDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        r"""Creates educations for a \~prospect\~.

        Args:
            ID: The Workday ID of the resource. (required)
            candidateEducationDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/educations".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if candidateEducationDetails is not None:
            if isinstance(candidateEducationDetails, dict):
                body.update(candidateEducationDetails)
            else:
                body["candidateEducationDetails"] = candidateEducationDetails

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_recruiting_v4_prospects_educations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_recruiting_v4_prospects_skills(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        r"""Retrieves a single skill instance for a \~prospect\~.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/skills/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_recruiting_v4_prospects_skills {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_recruiting_v4_prospects_resume_attachments(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        r"""Retrieves a single resume attachment instance for a \~prospect\~.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/resumeAttachments/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_recruiting_v4_prospects_resume_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_recruiting_v4_interviews_feedback(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/interviews/{ID}/feedback/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_recruiting_v4_interviews_feedback {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_recruiting_v4_job_postings(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a job posting.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/jobPostings/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_recruiting_v4_job_postings {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_recruiting_v4_job_postings_candidate_availability_template(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single instance of the candidate availability template version.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/jobPostings/{ID}/candidateAvailabilityTemplate/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_recruiting_v4_job_postings_candidate_availability_template {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_recruiting_v4_prospects_experiences(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        r"""Retrieves the work experience of a single \~prospect\~ instance.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/experiences".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_recruiting_v4_prospects_experiences {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_recruiting_v4_prospects_experiences(
        self,
        ID: str,
        prospectExperienceDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        r"""Creates experiences for a \~prospect\~.

        Args:
            ID: The Workday ID of the resource. (required)
            prospectExperienceDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/experiences".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if prospectExperienceDetails is not None:
            if isinstance(prospectExperienceDetails, dict):
                body.update(prospectExperienceDetails)
            else:
                body["prospectExperienceDetails"] = prospectExperienceDetails

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_recruiting_v4_prospects_experiences {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_recruiting_v4_prospects_resume_attachments_1(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/resumeAttachments/{subresourceID}?type=viewFile".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_recruiting_v4_prospects_resume_attachments_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_recruiting_v4_prospects_resume_attachments(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        r"""Retrieves attached resumes for a single \~prospect\~ instance.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/resumeAttachments".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_recruiting_v4_prospects_resume_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_recruiting_v4_prospects_resume_attachments(
        self,
        ID: str,
        resumeAttachmentDetailsCreate: Dict[str, Any]
    ) -> WorkdayResponse:
        r"""Creates resume attachments for a \~prospect\~.

        Args:
            ID: The Workday ID of the resource. (required)
            resumeAttachmentDetailsCreate:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/resumeAttachments".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if resumeAttachmentDetailsCreate is not None:
            if isinstance(resumeAttachmentDetailsCreate, dict):
                body.update(resumeAttachmentDetailsCreate)
            else:
                body["resumeAttachmentDetailsCreate"] = resumeAttachmentDetailsCreate

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_recruiting_v4_prospects_resume_attachments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_recruiting_v4_interviews_feedback(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/interviews/{ID}/feedback".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_recruiting_v4_interviews_feedback {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_recruiting_v4_interviews_feedback(
        self,
        ID: str,
        interviewDetailSummary: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            interviewDetailSummary:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/interviews/{ID}/feedback".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if interviewDetailSummary is not None:
            if isinstance(interviewDetailSummary, dict):
                body.update(interviewDetailSummary)
            else:
                body["interviewDetailSummary"] = interviewDetailSummary

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_recruiting_v4_interviews_feedback {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_recruiting_v4_job_postings_questionnaire(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        questionnaireType: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """Retrieves a single questionnaire instance.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            questionnaireType: questionnaireType (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/jobPostings/{ID}/questionnaire".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if questionnaireType is not None:
            params["questionnaireType"] = questionnaireType

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_recruiting_v4_job_postings_questionnaire {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_recruiting_v4_prospects_resume_attachments_1(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/resumeAttachments?type=viewFile".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_recruiting_v4_prospects_resume_attachments_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_recruiting_v4_prospects_educations(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        r"""Retrieves a single education instance for a \~prospect\~.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}/educations/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_recruiting_v4_prospects_educations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_recruiting_v4_prospects(
        self,
        ID: str
    ) -> WorkdayResponse:
        r"""Retrieves a single \~prospect\~ instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/recruiting/v4/prospects/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_recruiting_v4_prospects {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_request_v2_requests(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves the request with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/request/v2/requests/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_request_v2_requests {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_request_v2_types(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of request types.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/request/v2/types"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_request_v2_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_request_v2_requests_close(
        self,
        ID: str,
        requestClose: Dict[str, Any]
    ) -> WorkdayResponse:
        """Closes a request.

        Args:
            ID: The Workday ID of the resource. (required)
            requestClose:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/request/v2/requests/{ID}/close".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if requestClose is not None:
            if isinstance(requestClose, dict):
                body.update(requestClose)
            else:
                body["requestClose"] = requestClose

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_request_v2_requests_close {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_request_v2_requests(
        self,
        completedOnOrAfter: Optional[str] = None,
        completedOnOrBefore: Optional[str] = None,
        initiatedOnOrAfter: Optional[str] = None,
        initiatedOnOrBefore: Optional[str] = None,
        initiator: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        onBehalfOf: Optional[str] = None,
        requestId: Optional[str] = None,
        requestSubtype: Optional[List[str]] = None,
        requestType: Optional[List[str]] = None,
        resolution: Optional[List[str]] = None,
        resolutionDetails: Optional[List[str]] = None,
        workdayObjectValue: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of in progress requests based on the specified parameters.

        Args:
            completedOnOrAfter:  (optional)
            completedOnOrBefore:  (optional)
            initiatedOnOrAfter:  (optional)
            initiatedOnOrBefore:  (optional)
            initiator: The WID for the person who initiated the request. You can GET /workers in the /common service to retrieve a worker's WID. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            onBehalfOf: The Workday ID of the person this request is being initiated on behalf of. (optional)
            requestId: The ID of the request based on the ID generator format. (optional)
            requestSubtype: The Workday ID of the request subtype. You can specify more than 1 requestSubtype query parameter.
You can call GET /requests/query/values/requestSubtype to retrieve a valid ID. (optional)
            requestType: The Workday ID of the request type. You can specify more than 1 requestType query parameter.
You can call GET /requests/query/values/requestType to retrieve a valid ID. (optional)
            resolution: The Workday ID of the resolution of the request. You can specify more than 1 resolution query parameter.
Valid values:

* 47fa99d9ed671000111f2f4d1d6f37ea - Done

* be256002ae2010000c0b9b59ca1d014b - Duplicate

* be256002ae2010000c0b9c817aea014c - Denied

* be256002ae2010000bfd6ae5ea5b0148 - Canceled (optional)
            resolutionDetails: The Workday ID of the resolution details. You can specify more than 1 resolutionDetails query parameter.
You can call GET /requests/query/values/resolutionDetails to retrieve a valid ID. (optional)
            workdayObjectValue: The Workday ID of the business object associated with the request.
Call the corresponding GET endpoint on the business object resource in the appropriate REST service to get a valid ID. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/request/v2/requests"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if completedOnOrAfter is not None:
            params["completedOnOrAfter"] = completedOnOrAfter
        if completedOnOrBefore is not None:
            params["completedOnOrBefore"] = completedOnOrBefore
        if initiatedOnOrAfter is not None:
            params["initiatedOnOrAfter"] = initiatedOnOrAfter
        if initiatedOnOrBefore is not None:
            params["initiatedOnOrBefore"] = initiatedOnOrBefore
        if initiator is not None:
            params["initiator"] = initiator
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if onBehalfOf is not None:
            params["onBehalfOf"] = onBehalfOf
        if requestId is not None:
            params["requestId"] = requestId
        if requestSubtype is not None:
            params["requestSubtype"] = requestSubtype
        if requestType is not None:
            params["requestType"] = requestType
        if resolution is not None:
            params["resolution"] = resolution
        if resolutionDetails is not None:
            params["resolutionDetails"] = resolutionDetails
        if workdayObjectValue is not None:
            params["workdayObjectValue"] = workdayObjectValue

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_request_v2_requests {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_request_v2_requests(
        self,
        requestInitiate: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a request.

        Args:
            requestInitiate:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/request/v2/requests"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if requestInitiate is not None:
            if isinstance(requestInitiate, dict):
                body.update(requestInitiate)
            else:
                body["requestInitiate"] = requestInitiate

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_request_v2_requests {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_request_v2_types(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a request type.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/request/v2/types/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_request_v2_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_resource_forecast_lines_allocations(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a Resource Forecast Line Allocation for the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/resourceForecastLines/{ID}/allocations".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_resource_forecast_lines_allocations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_projects_v1_resource_forecast_lines_allocations(
        self,
        ID: str,
        resourceForecastLineAllocations: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates resource forecast line allocations.

        Args:
            ID: The Workday ID of the resource. (required)
            resourceForecastLineAllocations:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/resourceForecastLines/{ID}/allocations".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if resourceForecastLineAllocations is not None:
            if isinstance(resourceForecastLineAllocations, dict):
                body.update(resourceForecastLineAllocations)
            else:
                body["resourceForecastLineAllocations"] = resourceForecastLineAllocations

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_projects_v1_resource_forecast_lines_allocations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_resource_plan_worker_groups(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/resourcePlan/workerGroups/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_resource_plan_worker_groups {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_currencies(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/currencies/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_currencies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_worktag_types(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/worktagTypes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_worktag_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_projects_v1_resource_forecast_lines(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single resource forecast line instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/resourceForecastLines/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_projects_v1_resource_forecast_lines {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_projects_v1_resource_plan_lines_edit(
        self,
        ID: str,
        resourcePlanLinesPatchSummary: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a Resource Plan Line Edit event and initiates the Project Resource Plan Line business process.

        Args:
            ID: The Workday ID of the resource. (required)
            resourcePlanLinesPatchSummary:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/resourcePlanLines/{ID}/edit".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if resourcePlanLinesPatchSummary is not None:
            if isinstance(resourcePlanLinesPatchSummary, dict):
                body.update(resourcePlanLinesPatchSummary)
            else:
                body["resourcePlanLinesPatchSummary"] = resourcePlanLinesPatchSummary

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_projects_v1_resource_plan_lines_edit {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_projects_v1_resource_plan_lines(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single resource plan line instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/resourcePlanLines/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_projects_v1_resource_plan_lines {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_resource_plan_unnamed_resources(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/resourcePlan/unnamedResources/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_resource_plan_unnamed_resources {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_resource_plan_worker_to_replace_unnamed_resources(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/resourcePlan/workerToReplaceUnnamedResources/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_resource_plan_worker_to_replace_unnamed_resources {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_groups(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/groups/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_groups {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_success_ratings(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/successRatings/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_success_ratings {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_projects(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of Projects.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/projects"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_projects {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_projects_v1_projects(
        self,
        projectSummary: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates Project Create Events and initiates the associated workflow to update the project.

        Args:
            projectSummary:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/projects"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if projectSummary is not None:
            if isinstance(projectSummary, dict):
                body.update(projectSummary)
            else:
                body["projectSummary"] = projectSummary

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_projects_v1_projects {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_projects_v1_projects(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single project instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/projects/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_projects_v1_projects {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_ad_hoc_project_time_transactions(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        projectOrProjectHierarchy: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of ad hoc project time transactions.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            projectOrProjectHierarchy: The Workday ID or reference ID of a project or project hierarchy. You can use a returned project id or primaryHierarchy {id} from GET /projects. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/adHocProjectTimeTransactions"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if projectOrProjectHierarchy is not None:
            params["projectOrProjectHierarchy"] = projectOrProjectHierarchy

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_ad_hoc_project_time_transactions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_projects_v1_ad_hoc_project_time_transactions(
        self,
        createAdHocProjectTimeTransaction: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates ad hoc project time transactions.

        Args:
            createAdHocProjectTimeTransaction:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/adHocProjectTimeTransactions"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if createAdHocProjectTimeTransaction is not None:
            if isinstance(createAdHocProjectTimeTransaction, dict):
                body.update(createAdHocProjectTimeTransaction)
            else:
                body["createAdHocProjectTimeTransaction"] = createAdHocProjectTimeTransaction

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_projects_v1_ad_hoc_project_time_transactions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_projects_v1_resource_forecast_lines_allocations(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieve Resource Forecast Line Allocation.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/resourceForecastLines/{ID}/allocations/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_projects_v1_resource_forecast_lines_allocations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_projects_v1_resource_forecast_lines_allocations(
        self,
        ID: str,
        subresourceID: str,
        resourceForecastLineAllocationsForPatch: Dict[str, Any]
    ) -> WorkdayResponse:
        """Update forecasted hours for Resource Forecast Line Allocation.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            resourceForecastLineAllocationsForPatch:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/resourceForecastLines/{ID}/allocations/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if resourceForecastLineAllocationsForPatch is not None:
            if isinstance(resourceForecastLineAllocationsForPatch, dict):
                body.update(resourceForecastLineAllocationsForPatch)
            else:
                body["resourceForecastLineAllocationsForPatch"] = resourceForecastLineAllocationsForPatch

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_projects_v1_resource_forecast_lines_allocations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_project_plan_project_phases(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/projectPlan/projectPhases/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_project_plan_project_phases {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_resource_plan_requirement_categories(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/resourcePlan/requirementCategories/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_resource_plan_requirement_categories {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_resource_plan_roles(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/resourcePlan/roles/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_resource_plan_roles {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_hierarchies(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/hierarchies/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_hierarchies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_customers(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/customers/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_customers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_worktags(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/worktags/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_worktags {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_resource_plan_role_categories(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/resourcePlan/roleCategories/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_resource_plan_role_categories {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_project_plan_project_tasks(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/projectPlan/projectTasks/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_project_plan_project_tasks {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_owners(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/owners/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_owners {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_plan_tasks(
        self,
        filterBy: Optional[List[str]] = None,
        filterCondition: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        planPhase: Optional[str] = None,
        project: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of Project Plan Tasks for a specified Project or Project Plan Phase.

        Args:
            filterBy: Accepts both Project Plan Phase or Project Plan Task WID. Query helps to filter results set based on filterCondition either to include or exclude WIDs. (optional)
            filterCondition:  (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            planPhase:  (optional)
            project:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/planTasks"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if filterBy is not None:
            params["filterBy"] = filterBy
        if filterCondition is not None:
            params["filterCondition"] = filterCondition
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if planPhase is not None:
            params["planPhase"] = planPhase
        if project is not None:
            params["project"] = project

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_plan_tasks {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_projects_v1_plan_tasks(
        self,
        planTaskDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates Project Plan tasks.

        Args:
            planTaskDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/planTasks"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if planTaskDetails is not None:
            if isinstance(planTaskDetails, dict):
                body.update(planTaskDetails)
            else:
                body["planTaskDetails"] = planTaskDetails

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_projects_v1_plan_tasks {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_resource_plan_workers(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/resourcePlan/workers/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_resource_plan_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_statuses(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/statuses/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_statuses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_projects_v1_projects_edit(
        self,
        ID: str,
        projectPatchSummary: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates Project Edit Events and initiates the associated workflow to update the project.

        Args:
            ID: The Workday ID of the resource. (required)
            projectPatchSummary:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/projects/{ID}/edit".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if projectPatchSummary is not None:
            if isinstance(projectPatchSummary, dict):
                body.update(projectPatchSummary)
            else:
                body["projectPatchSummary"] = projectPatchSummary

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_projects_v1_projects_edit {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_task_resources(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        project: Optional[List[str]] = None,
        projectPlanTask: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of Task Resources.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            project: The project to retrieve the task resources from. (optional)
            projectPlanTask: The project plan task to retrieve the task resources from. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/taskResources"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if project is not None:
            params["project"] = project
        if projectPlanTask is not None:
            params["projectPlanTask"] = projectPlanTask

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_task_resources {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_projects_v1_task_resources(
        self,
        taskResourcesSummary: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates task resources.

        Args:
            taskResourcesSummary:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/taskResources"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if taskResourcesSummary is not None:
            if isinstance(taskResourcesSummary, dict):
                body.update(taskResourcesSummary)
            else:
                body["taskResourcesSummary"] = taskResourcesSummary

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_projects_v1_task_resources {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_resource_plan_lines(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        project: Optional[str] = None,
        projectResourcePlan: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of Resource Plan Lines.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            project:  (optional)
            projectResourcePlan:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/resourcePlanLines"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if project is not None:
            params["project"] = project
        if projectResourcePlan is not None:
            params["projectResourcePlan"] = projectResourcePlan

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_resource_plan_lines {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_projects_v1_resource_plan_lines(
        self,
        resourcePlanLinesSummary: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a Resource Plan Line Create event and initiates the Project Resource Plan Line business process.

        Args:
            resourcePlanLinesSummary:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/resourcePlanLines"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if resourcePlanLinesSummary is not None:
            if isinstance(resourcePlanLinesSummary, dict):
                body.update(resourcePlanLinesSummary)
            else:
                body["resourcePlanLinesSummary"] = resourcePlanLinesSummary

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_projects_v1_resource_plan_lines {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_projects_v1_task_resources(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single task resource instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/taskResources/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_projects_v1_task_resources {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_projects_v1_task_resources(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Deletes an existing task resource instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/taskResources/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_projects_v1_task_resources {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_projects_v1_task_resources(
        self,
        ID: str,
        taskResourcesSummary: Dict[str, Any]
    ) -> WorkdayResponse:
        """Update Task Resource for specified Workday ID.

        Args:
            ID: The Workday ID of the resource. (required)
            taskResourcesSummary:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/taskResources/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if taskResourcesSummary is not None:
            if isinstance(taskResourcesSummary, dict):
                body.update(taskResourcesSummary)
            else:
                body["taskResourcesSummary"] = taskResourcesSummary

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_projects_v1_task_resources {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_optional_hierarchies(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/optionalHierarchies/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_optional_hierarchies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_priorities(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/priorities/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_priorities {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_resource_plan_resource_types(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/resourcePlan/resourceTypes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_resource_plan_resource_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_projects_v1_plan_phases(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single project plan phase instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/planPhases/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_projects_v1_plan_phases {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_projects_v1_plan_phases(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Deletes an existing project plan phase instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/planPhases/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_projects_v1_plan_phases {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_projects_v1_plan_phases(
        self,
        ID: str,
        planPhaseDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates the Project Plan Phase for the specified ID. Partially updates the existing Project Plan Phase with the specified data in the request body.

        Args:
            ID: The Workday ID of the resource. (required)
            planPhaseDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/planPhases/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if planPhaseDetails is not None:
            if isinstance(planPhaseDetails, dict):
                body.update(planPhaseDetails)
            else:
                body["planPhaseDetails"] = planPhaseDetails

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_projects_v1_plan_phases {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_project_plan_project_plan_phases(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/projectPlan/projectPlanPhases/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_project_plan_project_plan_phases {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_resource_plan_requirements(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/resourcePlan/requirements/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_resource_plan_requirements {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_resource_plan_cost_rate_currencies(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/resourcePlan/costRateCurrencies/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_resource_plan_cost_rate_currencies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_projects_v1_plan_tasks(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single project plan task instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/planTasks/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_projects_v1_plan_tasks {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_projects_v1_plan_tasks(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Deletes an existing project plan task instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/planTasks/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_projects_v1_plan_tasks {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_projects_v1_plan_tasks(
        self,
        ID: str,
        planTaskDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates an existing Project Plan Task instance with the specified ID and the specified data in the request body.

        Args:
            ID: The Workday ID of the resource. (required)
            planTaskDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/planTasks/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if planTaskDetails is not None:
            if isinstance(planTaskDetails, dict):
                body.update(planTaskDetails)
            else:
                body["planTaskDetails"] = planTaskDetails

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_projects_v1_plan_tasks {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_companies(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/companies/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_companies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_risk_levels(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/riskLevels/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_risk_levels {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_resource_plan_booking_status(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/resourcePlan/bookingStatus/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_resource_plan_booking_status {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_resource_forecast_lines(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        project: Optional[str] = None,
        projectResource: Optional[str] = None,
        projectRole: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of Resource Forecast Lines.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            project:  (optional)
            projectResource:  (optional)
            projectRole:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/resourceForecastLines"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if project is not None:
            params["project"] = project
        if projectResource is not None:
            params["projectResource"] = projectResource
        if projectRole is not None:
            params["projectRole"] = projectRole

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_resource_forecast_lines {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_project_plan_project_plan_tasks(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/projectPlan/projectPlanTasks/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_project_plan_project_plan_tasks {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_projects_v1_ad_hoc_project_time_transactions(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves an ad hoc project time transaction instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/adHocProjectTimeTransactions/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_projects_v1_ad_hoc_project_time_transactions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_plan_phases(
        self,
        filterBy: Optional[List[str]] = None,
        filterCondition: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        parent: Optional[str] = None,
        project: Optional[str] = None,
        topLevelPhase: Optional[bool] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of Project Plan Phases for a specified Project.

        Args:
            filterBy: Accepts both Project Plan Phase or Project Plan Task WID. Query helps to filter results set based on filterCondition either to include or exclude WIDs. (optional)
            filterCondition: To be used along with filterBy Query field to include or exclude instances in the GET response. Valid values are \"Is\" and \"Not Equal to\" (case-insensitive). (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            parent:  (optional)
            project:  (optional)
            topLevelPhase:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/planPhases"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if filterBy is not None:
            params["filterBy"] = filterBy
        if filterCondition is not None:
            params["filterCondition"] = filterCondition
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if parent is not None:
            params["parent"] = parent
        if project is not None:
            params["project"] = project
        if topLevelPhase is not None:
            params["topLevelPhase"] = topLevelPhase

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_plan_phases {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_projects_v1_plan_phases(
        self,
        planPhaseDetailsPost: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates project plan phases.

        Args:
            planPhaseDetailsPost:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/planPhases"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if planPhaseDetailsPost is not None:
            if isinstance(planPhaseDetailsPost, dict):
                body.update(planPhaseDetailsPost)
            else:
                body["planPhaseDetailsPost"] = planPhaseDetailsPost

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_projects_v1_plan_phases {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_importance_ratings(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/importanceRatings/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_importance_ratings {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_projects(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/projects/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_projects {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_project_states(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/projectStates/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_project_states {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_projects_v1_values_common_project_dependencies(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/projects/v1/values/common/projectDependencies/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_projects_v1_values_common_project_dependencies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_engagement_v1_students_holds(
        self,
        ID: str,
        holdType: Optional[List[str]] = None,
        reason: Optional[str] = None,
        showInactive: Optional[bool] = None
    ) -> WorkdayResponse:
        """DEPRECATED. Retrieves a collection of student holds assigned to the specified student ID.

        Args:
            ID: The Workday ID of the resource. (required)
            holdType: Filter for holds matching these hold types. (optional)
            reason: Filter for holds matching this hold reason. (optional)
            showInactive: Parameter that will include inactive holds along with the active ones. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentEngagement/v1/students/{ID}/holds".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if holdType is not None:
            params["holdType"] = holdType
        if reason is not None:
            params["reason"] = reason
        if showInactive is not None:
            params["showInactive"] = showInactive

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_engagement_v1_students_holds {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_engagement_v1_students(
        self,
        academicLevel: Optional[List[str]] = None,
        academicUnit: Optional[List[str]] = None,
        activeOnly: Optional[bool] = None,
        programOfStudy: Optional[List[str]] = None,
        search: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of students.

        Args:
            academicLevel:  (optional)
            academicUnit: Derived Academic Units. (optional)
            activeOnly: Only return active students. (optional)
            programOfStudy: For students who haven't matriculated, the program of study they either applied to or have been admitted to. For matriculated students, the primary program of study from their reporting record. (optional)
            search: A fuzzy search string that matches student IDs and names. Example: search=bri%20book returns the student Brian Booker. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentEngagement/v1/students"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if academicLevel is not None:
            params["academicLevel"] = academicLevel
        if academicUnit is not None:
            params["academicUnit"] = academicUnit
        if activeOnly is not None:
            params["activeOnly"] = activeOnly
        if programOfStudy is not None:
            params["programOfStudy"] = programOfStudy
        if search is not None:
            params["search"] = search

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_engagement_v1_students {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_engagement_v1_students(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a student instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentEngagement/v1/students/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_engagement_v1_students {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_engagement_v1_students_holds(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """DEPRECATED. Retrieves a single student hold instance for the specified student.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentEngagement/v1/students/{ID}/holds/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_engagement_v1_students_holds {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_academic_foundation_v1_programs_of_study(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves the program of study with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentAcademicFoundation/v1/programsOfStudy/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_academic_foundation_v1_programs_of_study {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_academic_foundation_v1_academic_units(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves the Academic Unit with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentAcademicFoundation/v1/academicUnits/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_academic_foundation_v1_academic_units {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_academic_foundation_v1_academic_calendars_academic_years(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the academic year associated with an academic calendar with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentAcademicFoundation/v1/academicCalendars/{ID}/academicYears/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_academic_foundation_v1_academic_calendars_academic_years {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_academic_foundation_v1_educational_credentials(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of educational credentials.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentAcademicFoundation/v1/educationalCredentials"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_academic_foundation_v1_educational_credentials {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_academic_foundation_v1_academic_calendars(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of academic calendars.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentAcademicFoundation/v1/academicCalendars"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_academic_foundation_v1_academic_calendars {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_academic_foundation_v1_academic_periods(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves the academic period with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentAcademicFoundation/v1/academicPeriods/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_academic_foundation_v1_academic_periods {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_academic_foundation_v1_academic_calendars_academic_years(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of the academic years associated with an academic calendar.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentAcademicFoundation/v1/academicCalendars/{ID}/academicYears".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_academic_foundation_v1_academic_calendars_academic_years {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_academic_foundation_v1_academic_levels(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves the academic level with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentAcademicFoundation/v1/academicLevels/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_academic_foundation_v1_academic_levels {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_academic_foundation_v1_educational_credentials(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves the educational credential with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentAcademicFoundation/v1/educationalCredentials/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_academic_foundation_v1_educational_credentials {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_academic_foundation_v1_academic_calendars(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves the academic calendar with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentAcademicFoundation/v1/academicCalendars/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_academic_foundation_v1_academic_calendars {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_academic_foundation_v1_academic_units(
        self,
        effectiveDate: Optional[str] = None,
        inactive: Optional[bool] = None,
        institution: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        superior: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of academic units.

        Args:
            effectiveDate: The effective date of the Academic Unit, using the yyyy-mm-dd format. The default is the current date. (optional)
            inactive: If true, this method retrieves Academic Units that are inactive as of the effective date. The default is false. (optional)
            institution: If true, this method retrieves Academic Units that are designated as institutions as of the effective date. The default is false. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            superior: The Workday ID of the immediate superior of the Academic Units, as of the effective date. You can use a returned id from GET /academicUnits. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentAcademicFoundation/v1/academicUnits"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if effectiveDate is not None:
            params["effectiveDate"] = effectiveDate
        if inactive is not None:
            params["inactive"] = inactive
        if institution is not None:
            params["institution"] = institution
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if superior is not None:
            params["superior"] = superior

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_academic_foundation_v1_academic_units {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_academic_foundation_v1_programs_of_study(
        self,
        academicLevel: Optional[str] = None,
        academicUnit: Optional[str] = None,
        cipCode: Optional[str] = None,
        educationalCredentials: Optional[List[str]] = None,
        effectiveDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        programType: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of programs of study.

        Args:
            academicLevel: The Workday ID of the owning academic level of the program of study, as of the effective date. You can use a return id from GET /academicLevels (optional)
            academicUnit: The Workday ID of the owning academic unit of the program of study, as of the effective date. You can use a return id from GET /academicUnits (optional)
            cipCode: The Workday ID of the CIP code for the program of study, as of the effective date. (optional)
            educationalCredentials: The Workday IDs of the educational credentials of the program of study, as of the effective date. You can use the return id from GET /educationalCredentials.

You can filter programs of study by multiple educational credentials. Example: educationalCredentials=A&educationalCredentials=B&educationalCredentials=C. In this example, the method returns programs of study that have credentials A, B, AND C as of the the effectiveDate or current date. (optional)
            effectiveDate: The effective date of the Program of Study, using the yyyy-mm-dd format. The default is the current date. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            programType: The Workday ID of the program type of the program of study, as of the effective date. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentAcademicFoundation/v1/programsOfStudy"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if academicLevel is not None:
            params["academicLevel"] = academicLevel
        if academicUnit is not None:
            params["academicUnit"] = academicUnit
        if cipCode is not None:
            params["cipCode"] = cipCode
        if educationalCredentials is not None:
            params["educationalCredentials"] = educationalCredentials
        if effectiveDate is not None:
            params["effectiveDate"] = effectiveDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if programType is not None:
            params["programType"] = programType

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_academic_foundation_v1_programs_of_study {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_academic_foundation_v1_academic_levels(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of academic levels.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentAcademicFoundation/v1/academicLevels"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_academic_foundation_v1_academic_levels {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_academic_foundation_v1_academic_periods(
        self,
        academicCalendar: Optional[str] = None,
        academicYear: Optional[str] = None,
        fromDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        toDate: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of academic periods.

        Args:
            academicCalendar: The Workday ID of the academic calendar for the academic period. You can use a return id from GET /academicCalendars (optional)
            academicYear: The Workday ID of the academic year for the academic period. You can use a return id from GET /academicCalendars/{ID}/academicYears (optional)
            fromDate: Filter academic periods by their start date using yyyy-mm-dd format. If used without toDate, returns all academic periods with start date on or after fromDate. If used with toDate, returns all academic periods whose start and/or end dates are within the inclusive date range specified by fromDate and toDate. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            toDate: Filter academic periods by their end date using yyyy-mm-dd format. If used without fromDate, returns all academic periods with end date on or before toDate. If used with fromDate, returns all academic periods whose start and/or end dates are within the inclusive date range specified by fromDate and toDate. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentAcademicFoundation/v1/academicPeriods"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if academicCalendar is not None:
            params["academicCalendar"] = academicCalendar
        if academicYear is not None:
            params["academicYear"] = academicYear
        if fromDate is not None:
            params["fromDate"] = fromDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if toDate is not None:
            params["toDate"] = toDate

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_academic_foundation_v1_academic_periods {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_curriculum_v1_courses(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single course instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCurriculum/v1/courses/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_curriculum_v1_courses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_curriculum_v1_course_sections(
        self,
        academicLevel: Optional[str] = None,
        academicPeriod: Optional[str] = None,
        campusLocation: Optional[List[str]] = None,
        course: Optional[str] = None,
        courseSubject: Optional[str] = None,
        deliveryMode: Optional[str] = None,
        instructionalFormat: Optional[str] = None,
        limit: Optional[int] = None,
        offeringAcademicUnit: Optional[List[str]] = None,
        offset: Optional[int] = None,
        owningAcademicUnit: Optional[str] = None,
        owningInstitutionalAcademicUnit: Optional[str] = None,
        status: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of course sections.

        Args:
            academicLevel: The academic level used by the course section. You can specify using the Workday ID or Reference ID. You can use a returned id from GET /academicLevels from studentAcademicFoundation service. (optional)
            academicPeriod: The starting academic period of the course section. You can specify using the Workday ID or Reference ID. You can use a returned id from GET /academicPeriods from studentAcademicFoundation service. (optional)
            campusLocation:  (optional)
            course: The course for the course section. You can specify by using the Workday ID or Reference ID. You can use a returned id from GET /courses. (optional)
            courseSubject: The subject for the course section. You can specify by using the Workday ID or Reference ID. You can use a returned id from GET /courseSubjects. (optional)
            deliveryMode: The delivery mode for the course section.You can specify using the Workday ID or Reference ID. You can use the following values: Correspondence, Hybrid, In-Person, Online, Other Distance Mode. (optional)
            instructionalFormat: The instructional format for the course section. You can specify using the Workday ID or Reference ID. You can use the following values: Clinical, Combination, Discussion, Experiential, Independent Study, Internship, Laboratory, Lecture, Recitation, Research, Seminar, Service Learning, Studio, Thesis, Workshop. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offeringAcademicUnit: The academic unit that offers this course section. You can specify multiple academicUnit query parameters using the Workday ID or Reference ID. You can use a returned id from GET /academicUnits from studentAcademicFoundation service. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            owningAcademicUnit: The academic unit that owns this course section. You can specify by using the Workday ID or Reference ID. You can use a returned id from GET /academicUnits from studentAcademicFoundation service. (optional)
            owningInstitutionalAcademicUnit: The institutional academic unit that owns this course section. You can specify by using the Workday ID or Reference ID. You can use a returned id from GET /academicUnits from studentAcademicFoundation service. (optional)
            status: The section status of the course section. You can specify using the Workday ID or Reference ID. You can use the following values: Preliminary, Open, Closed, Waitlist, Hold, Canceled. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCurriculum/v1/courseSections"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if academicLevel is not None:
            params["academicLevel"] = academicLevel
        if academicPeriod is not None:
            params["academicPeriod"] = academicPeriod
        if campusLocation is not None:
            params["campusLocation"] = campusLocation
        if course is not None:
            params["course"] = course
        if courseSubject is not None:
            params["courseSubject"] = courseSubject
        if deliveryMode is not None:
            params["deliveryMode"] = deliveryMode
        if instructionalFormat is not None:
            params["instructionalFormat"] = instructionalFormat
        if limit is not None:
            params["limit"] = limit
        if offeringAcademicUnit is not None:
            params["offeringAcademicUnit"] = offeringAcademicUnit
        if offset is not None:
            params["offset"] = offset
        if owningAcademicUnit is not None:
            params["owningAcademicUnit"] = owningAcademicUnit
        if owningInstitutionalAcademicUnit is not None:
            params["owningInstitutionalAcademicUnit"] = owningInstitutionalAcademicUnit
        if status is not None:
            params["status"] = status

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_curriculum_v1_course_sections {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_curriculum_v1_course_sections(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single course section instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCurriculum/v1/courseSections/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_curriculum_v1_course_sections {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_curriculum_v1_courses(
        self,
        academicLevel: Optional[str] = None,
        academicUnit: Optional[List[str]] = None,
        courseSubject: Optional[str] = None,
        effectiveDate: Optional[str] = None,
        institutionalAcademicUnit: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        search: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of courses.

        Args:
            academicLevel: The academic level used by the courses. You can specify using the Workday ID or Reference ID. You can use a returned id from GET /academicLevels from studentAcademicFoundation service. (optional)
            academicUnit: The academic unit used by the course. You can specify multiple academicUnit query parameters using the Workday ID or Reference ID. You can use a returned id from GET /academicUnits from studentAcademicFoundation service. (optional)
            courseSubject: The subject for the course. You can specify by using the Workday ID or Reference ID. You can use a returned id from GET /courseSubjects. (optional)
            effectiveDate: The effective date of the Course's effective-dated fields: competencies, academicLevel, typicalPeriodsOffered, academicUnits, allowedLocations, owningInstitutionalAcademicUnit, tags, description, eligibilityRule, instructionalFormats, learningOutcomes, and title. Format for input is as such: YYYY-MM-DD. (optional)
            institutionalAcademicUnit: The institution academic unit used by the courses. You can specify by using the Workday ID or Reference ID. You can use a returned id from GET /academicUnits from studentAcademicFoundation service. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            search:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCurriculum/v1/courses"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if academicLevel is not None:
            params["academicLevel"] = academicLevel
        if academicUnit is not None:
            params["academicUnit"] = academicUnit
        if courseSubject is not None:
            params["courseSubject"] = courseSubject
        if effectiveDate is not None:
            params["effectiveDate"] = effectiveDate
        if institutionalAcademicUnit is not None:
            params["institutionalAcademicUnit"] = institutionalAcademicUnit
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if search is not None:
            params["search"] = search

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_curriculum_v1_courses {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_curriculum_v1_course_subjects(
        self,
        inactive: Optional[bool] = None,
        institutionalAcademicUnit: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """No summary

        Args:
            inactive: Indicates if a Course Subject is inactive. (optional)
            institutionalAcademicUnit: The Institution Academic Units. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCurriculum/v1/courseSubjects"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if inactive is not None:
            params["inactive"] = inactive
        if institutionalAcademicUnit is not None:
            params["institutionalAcademicUnit"] = institutionalAcademicUnit
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_curriculum_v1_course_subjects {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_curriculum_v1_course_subjects(
        self,
        ID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCurriculum/v1/courseSubjects/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_curriculum_v1_course_subjects {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_students_residencies(
        self,
        ID: str,
        institutionalAcademicUnit: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of residence information for the specified student ID.

        Args:
            ID: The Workday ID of the resource. (required)
            institutionalAcademicUnit: The Institutions. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/students/{ID}/residencies".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if institutionalAcademicUnit is not None:
            params["institutionalAcademicUnit"] = institutionalAcademicUnit
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_students_residencies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_values_holds_award_years(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/values/holds/awardYears/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_values_holds_award_years {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_students_apply_hold_events(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of Apply Student Hold Events.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/students/{ID}/applyHoldEvents".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_students_apply_hold_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_core_v1_students(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a student instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/students/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_core_v1_students {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_values_holds_academic_records(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/values/holds/academicRecords/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_values_holds_academic_records {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_student_core_v1_immigration_events_submit(
        self,
        ID: str,
        immigrationEventDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Submits an immigration event.

        Args:
            ID: The Workday ID of the resource. (required)
            immigrationEventDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/immigrationEvents/{ID}/submit".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if immigrationEventDetail is not None:
            if isinstance(immigrationEventDetail, dict):
                body.update(immigrationEventDetail)
            else:
                body["immigrationEventDetail"] = immigrationEventDetail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_student_core_v1_immigration_events_submit {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_core_v1_immigration_events_immigration_data(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves an immigration data instance for the specified immigration event.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/immigrationEvents/{ID}/immigrationData/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_core_v1_immigration_events_immigration_data {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_student_core_v1_immigration_events_immigration_data(
        self,
        ID: str,
        subresourceID: str,
        immigrationDataDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            immigrationDataDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/immigrationEvents/{ID}/immigrationData/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if immigrationDataDetail is not None:
            if isinstance(immigrationDataDetail, dict):
                body.update(immigrationDataDetail)
            else:
                body["immigrationDataDetail"] = immigrationDataDetail

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_student_core_v1_immigration_events_immigration_data {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_core_v1_holds(
        self,
        ID: str
    ) -> WorkdayResponse:
        """This resource returns all Student Hold Assignments or a collection of Student Hold Assignments filtered by query parameters.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/holds/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_core_v1_holds {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_student_core_v1_holds_override_hold(
        self,
        ID: str,
        overrideEvent: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            overrideEvent:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/holds/{ID}/overrideHold".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if overrideEvent is not None:
            if isinstance(overrideEvent, dict):
                body.update(overrideEvent)
            else:
                body["overrideEvent"] = overrideEvent

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_student_core_v1_holds_override_hold {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_immigration_events(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of immigration events.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/immigrationEvents"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_immigration_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_student_core_v1_students_apply_hold(
        self,
        ID: str,
        applyHoldEvent: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates an Apply Student Hold Event.

        Args:
            ID: The Workday ID of the resource. (required)
            applyHoldEvent:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/students/{ID}/applyHold".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if applyHoldEvent is not None:
            if isinstance(applyHoldEvent, dict):
                body.update(applyHoldEvent)
            else:
                body["applyHoldEvent"] = applyHoldEvent

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_student_core_v1_students_apply_hold {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_immigration_events_immigration_data(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of immigration data for the specified immigration event ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/immigrationEvents/{ID}/immigrationData".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_immigration_events_immigration_data {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_student_core_v1_immigration_events_immigration_data(
        self,
        ID: str,
        immigrationDataDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates an immigration data with the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)
            immigrationDataDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/immigrationEvents/{ID}/immigrationData".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if immigrationDataDetail is not None:
            if isinstance(immigrationDataDetail, dict):
                body.update(immigrationDataDetail)
            else:
                body["immigrationDataDetail"] = immigrationDataDetail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_student_core_v1_immigration_events_immigration_data {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_values_holds_reasons(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/values/holds/reasons/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_values_holds_reasons {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_core_v1_students_apply_hold_events(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves an Apply Student Hold Event instance for the specified student.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/students/{ID}/applyHoldEvents/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_core_v1_students_apply_hold_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_values_holds_award_items(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/values/holds/awardItems/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_values_holds_award_items {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_immigration_events_immigration_pages(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/immigrationEvents/{ID}/immigrationPages".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_immigration_events_immigration_pages {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_values_holds_institution(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/values/holds/institution/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_values_holds_institution {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_core_v1_immigration_events_immigration_pages(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/immigrationEvents/{ID}/immigrationPages/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_core_v1_immigration_events_immigration_pages {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_student_core_v1_holds_update_hold(
        self,
        ID: str,
        updateHoldEvent: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates an Update Student Hold Event.

        Args:
            ID: The Workday ID of the resource. (required)
            updateHoldEvent:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/holds/{ID}/updateHold".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if updateHoldEvent is not None:
            if isinstance(updateHoldEvent, dict):
                body.update(updateHoldEvent)
            else:
                body["updateHoldEvent"] = updateHoldEvent

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_student_core_v1_holds_update_hold {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_core_v1_immigration_events(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves an immigration event.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/immigrationEvents/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_core_v1_immigration_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_holds(
        self,
        active: Optional[bool] = None,
        holdReason: Optional[str] = None,
        holdType: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        student: Optional[str] = None
    ) -> WorkdayResponse:
        """This resource returns all Student Hold Assignments or a collection of Student Hold Assignments filtered by query parameters.

        Args:
            active: Whether the holds are active or not. (optional)
            holdReason: The hold reason to filter on. (optional)
            holdType: The hold types to filter on. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            student: The student to filter on. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/holds"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if active is not None:
            params["active"] = active
        if holdReason is not None:
            params["holdReason"] = holdReason
        if holdType is not None:
            params["holdType"] = holdType
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if student is not None:
            params["student"] = student

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_holds {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_students(
        self,
        academicLevel: Optional[List[str]] = None,
        academicUnit: Optional[List[str]] = None,
        activeOnly: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        programOfStudy: Optional[List[str]] = None,
        search: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of students.

        Args:
            academicLevel:  (optional)
            academicUnit: Derived Academic Units. (optional)
            activeOnly: Only return active students. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            programOfStudy: For students who haven't matriculated, the program of study they either applied to or have been admitted to. For matriculated students, the primary program of study from their reporting record. (optional)
            search: A fuzzy search string that matches student IDs and names. Example: search=bri%20book returns the student Brian Booker. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/students"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if academicLevel is not None:
            params["academicLevel"] = academicLevel
        if academicUnit is not None:
            params["academicUnit"] = academicUnit
        if activeOnly is not None:
            params["activeOnly"] = activeOnly
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if programOfStudy is not None:
            params["programOfStudy"] = programOfStudy
        if search is not None:
            params["search"] = search

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_students {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_core_v1_immigration_events_dependent_immigration_data(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a dependent immigration data instance for the specified student ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/immigrationEvents/{ID}/dependentImmigrationData/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_core_v1_immigration_events_dependent_immigration_data {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_student_core_v1_immigration_events_dependent_immigration_data(
        self,
        ID: str,
        subresourceID: str,
        dependentImmigrationDataDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            dependentImmigrationDataDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/immigrationEvents/{ID}/dependentImmigrationData/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if dependentImmigrationDataDetail is not None:
            if isinstance(dependentImmigrationDataDetail, dict):
                body.update(dependentImmigrationDataDetail)
            else:
                body["dependentImmigrationDataDetail"] = dependentImmigrationDataDetail

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_student_core_v1_immigration_events_dependent_immigration_data {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_student_core_v1_immigration_events_dependent_immigration_data(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Delete immigration event dependent immigration data.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/immigrationEvents/{ID}/dependentImmigrationData/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_student_core_v1_immigration_events_dependent_immigration_data {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_values_holds_school_codes(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/values/holds/schoolCodes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_values_holds_school_codes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_immigration_events_dependent_immigration_data(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of dependent immigration data for the specified student ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/immigrationEvents/{ID}/dependentImmigrationData".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_immigration_events_dependent_immigration_data {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_student_core_v1_immigration_events_dependent_immigration_data(
        self,
        ID: str,
        dependentImmigrationDataDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates dependent immigration data for the specified immigration event.

        Args:
            ID: The Workday ID of the resource. (required)
            dependentImmigrationDataDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/immigrationEvents/{ID}/dependentImmigrationData".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if dependentImmigrationDataDetail is not None:
            if isinstance(dependentImmigrationDataDetail, dict):
                body.update(dependentImmigrationDataDetail)
            else:
                body["dependentImmigrationDataDetail"] = dependentImmigrationDataDetail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_student_core_v1_immigration_events_dependent_immigration_data {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_students_immigration_events(
        self,
        ID: str,
        institution: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        status: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of immigration events.

        Args:
            ID: The Workday ID of the resource. (required)
            institution:  (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            status:  (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/students/{ID}/immigrationEvents".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if institution is not None:
            params["institution"] = institution
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if status is not None:
            params["status"] = status

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_students_immigration_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_core_v1_students_immigration_events(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves an immigration event for the specified student.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/students/{ID}/immigrationEvents/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_core_v1_students_immigration_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_core_v1_values_holds_academic_periods(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/values/holds/academicPeriods/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_core_v1_values_holds_academic_periods {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_student_core_v1_holds_remove_hold(
        self,
        ID: str,
        removeEvent: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            removeEvent:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/holds/{ID}/removeHold".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if removeEvent is not None:
            if isinstance(removeEvent, dict):
                body.update(removeEvent)
            else:
                body["removeEvent"] = removeEvent

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_student_core_v1_holds_remove_hold {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_core_v1_students_residencies(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves residence information for the specified student.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentCore/v1/students/{ID}/residencies/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_core_v1_students_residencies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_recruiting_v1_values_academic_requirement_evaluation_unit_type(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentRecruiting/v1/values/academicRequirementEvaluation/unitType/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_recruiting_v1_values_academic_requirement_evaluation_unit_type {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_recruiting_v1_values_academic_requirement_evaluation_educational_institution(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentRecruiting/v1/values/academicRequirementEvaluation/educationalInstitution/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_recruiting_v1_values_academic_requirement_evaluation_educational_institution {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_recruiting_v1_values_academic_requirement_evaluation_external_course(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentRecruiting/v1/values/academicRequirementEvaluation/externalCourse/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_recruiting_v1_values_academic_requirement_evaluation_external_course {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_recruiting_v1_values_academic_requirement_evaluation_external_grading_scheme(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentRecruiting/v1/values/academicRequirementEvaluation/externalGradingScheme/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_recruiting_v1_values_academic_requirement_evaluation_external_grading_scheme {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_student_recruiting_v1_academic_requirement_evaluation(
        self,
        academicRequirementEvaluation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Calculates evaluation results for potential transfer credit and academic progress.

        Args:
            academicRequirementEvaluation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentRecruiting/v1/academicRequirementEvaluation"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if academicRequirementEvaluation is not None:
            if isinstance(academicRequirementEvaluation, dict):
                body.update(academicRequirementEvaluation)
            else:
                body["academicRequirementEvaluation"] = academicRequirementEvaluation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_student_recruiting_v1_academic_requirement_evaluation {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_recruiting_v1_values_academic_requirement_evaluation_programs_of_study(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentRecruiting/v1/values/academicRequirementEvaluation/programsOfStudy/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_recruiting_v1_values_academic_requirement_evaluation_programs_of_study {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_system_metrics_v1_active_tasks(
        self,
        ID: str
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/systemMetrics/v1/activeTasks/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_system_metrics_v1_active_tasks {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_system_metrics_v1_active_user_sessions(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of active user sessions.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/systemMetrics/v1/activeUserSessions"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_system_metrics_v1_active_user_sessions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_system_metrics_v1_active_tasks(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """No summary

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/systemMetrics/v1/activeTasks"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_system_metrics_v1_active_tasks {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_system_metrics_v1_active_user_sessions(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves an active user session.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/systemMetrics/v1/activeUserSessions/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_system_metrics_v1_active_user_sessions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_system_metrics_v1_system_metrics_overview(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves system metrics with the specified ID, including queued tasks, running tasks, and active user sessions.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/systemMetrics/v1/systemMetricsOverview"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_system_metrics_v1_system_metrics_overview {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_system_metrics_v1_system_metrics_overview(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves system metrics.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/systemMetrics/v1/systemMetricsOverview/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_system_metrics_v1_system_metrics_overview {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_finance_v1_students(
        self,
        academicLevel: Optional[List[str]] = None,
        academicUnit: Optional[List[str]] = None,
        activeOnly: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        programOfStudy: Optional[List[str]] = None,
        search: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of students.

        Args:
            academicLevel:  (optional)
            academicUnit: Derived Academic Units. (optional)
            activeOnly: Only return active students. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            programOfStudy: For students who haven't matriculated, the program of study they either applied to or have been admitted to. For matriculated students, the primary program of study from their reporting record. (optional)
            search: A fuzzy search string that matches student IDs and names. Example: search=bri%20book returns the student Brian Booker. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentFinance/v1/students"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if academicLevel is not None:
            params["academicLevel"] = academicLevel
        if academicUnit is not None:
            params["academicUnit"] = academicUnit
        if activeOnly is not None:
            params["activeOnly"] = activeOnly
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if programOfStudy is not None:
            params["programOfStudy"] = programOfStudy
        if search is not None:
            params["search"] = search

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_finance_v1_students {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_finance_v1_students(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a student instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentFinance/v1/students/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_finance_v1_students {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_student_finance_v1_students_payments(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single student payment instance for the specified student ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentFinance/v1/students/{ID}/payments/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_student_finance_v1_students_payments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_student_finance_v1_students_payments(
        self,
        ID: str,
        subresourceID: str,
        paymentAdjustmentDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates an existing student payment for the student instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            paymentAdjustmentDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentFinance/v1/students/{ID}/payments/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if paymentAdjustmentDetails is not None:
            if isinstance(paymentAdjustmentDetails, dict):
                body.update(paymentAdjustmentDetails)
            else:
                body["paymentAdjustmentDetails"] = paymentAdjustmentDetails

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_student_finance_v1_students_payments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_student_finance_v1_students_payments(
        self,
        ID: str,
        academicPeriod: Optional[str] = None,
        fromDate: Optional[str] = None,
        institutionalAcademicUnit: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        paymentItem: Optional[str] = None,
        paymentReference: Optional[str] = None,
        paymentType: Optional[str] = None,
        toDate: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of student payments.

        Args:
            ID: The Workday ID of the resource. (required)
            academicPeriod: The academic period associated with this object. When the object is associated with both a starting and an ending academic period, such as a financial aid period record, this report field returns the starting academic period. (optional)
            fromDate: Limit student payments to payments made on or after this date, using the yyyy-mm-dd format. (optional)
            institutionalAcademicUnit: The academic unit, an organizational type for academic appointments. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            paymentItem: The student payment item that is associated with the student payment. (optional)
            paymentReference: The check number or EFT number associated with a student payment. (optional)
            paymentType: The payment type for the reporting transaction. (optional)
            toDate: Limit student payments to payments made on or before this date, using the yyyy-mm-dd format. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentFinance/v1/students/{ID}/payments".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if academicPeriod is not None:
            params["academicPeriod"] = academicPeriod
        if fromDate is not None:
            params["fromDate"] = fromDate
        if institutionalAcademicUnit is not None:
            params["institutionalAcademicUnit"] = institutionalAcademicUnit
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if paymentItem is not None:
            params["paymentItem"] = paymentItem
        if paymentReference is not None:
            params["paymentReference"] = paymentReference
        if paymentType is not None:
            params["paymentType"] = paymentType
        if toDate is not None:
            params["toDate"] = toDate

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_student_finance_v1_students_payments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_student_finance_v1_students_payments(
        self,
        ID: str,
        paymentDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a student payment.

        Args:
            ID: The Workday ID of the resource. (required)
            paymentDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/studentFinance/v1/students/{ID}/payments".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if paymentDetail is not None:
            if isinstance(paymentDetail, dict):
                body.update(paymentDetail)
            else:
                body["paymentDetail"] = paymentDetail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_student_finance_v1_students_payments {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_worktag_v1_validate_worktags(
        self,
        validateWorktagInput: Dict[str, Any]
    ) -> WorkdayResponse:
        """Validates worktags.

        Args:
            validateWorktagInput:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/worktag/v1/validateWorktags"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if validateWorktagInput is not None:
            if isinstance(validateWorktagInput, dict):
                body.update(validateWorktagInput)
            else:
                body["validateWorktagInput"] = validateWorktagInput

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_worktag_v1_validate_worktags {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_wql_v1_data_sources(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a data source and primary business object for the specified {ID} for use in a WQL query.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/wql/v1/dataSources/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_wql_v1_data_sources {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_wql_v1_data_sources_data_source_filters(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the data source filter with the specified {ID} for a specific data source.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/wql/v1/dataSources/{ID}/dataSourceFilters/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_wql_v1_data_sources_data_source_filters {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_wql_v1_data_sources_data_source_filters(
        self,
        ID: str,
        alias: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        searchString: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a data source filter of the data source.

        Args:
            ID: The Workday ID of the resource. (required)
            alias: The alias of the data source filter. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            searchString: The string to be searched in case insensitive manner within the descriptors of the data source filters. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/wql/v1/dataSources/{ID}/dataSourceFilters".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if alias is not None:
            params["alias"] = alias
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if searchString is not None:
            params["searchString"] = searchString

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_wql_v1_data_sources_data_source_filters {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_wql_v1_data(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        query: Optional[str] = None
    ) -> WorkdayResponse:
        """Returns the data from a WQL query.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            query: The WQL query that retrieves the data. Example: SELECT worker from allWorkers. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/wql/v1/data"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if query is not None:
            params["query"] = query

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_wql_v1_data {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_wql_v1_data(
        self,
        adhocQuery: Dict[str, Any]
    ) -> WorkdayResponse:
        """Returns the data from a WQL query. The read-only POST request accommodates queries greater than 2,048 characters.

        Args:
            adhocQuery:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/wql/v1/data"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if adhocQuery is not None:
            if isinstance(adhocQuery, dict):
                body.update(adhocQuery)
            else:
                body["adhocQuery"] = adhocQuery

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_wql_v1_data {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_wql_v1_data_sources(
        self,
        alias: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        searchString: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of data sources, including their primary business objects.

        Args:
            alias: The alias of the data source. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            searchString: The string to be searched in case insensitive manner within the descriptors of the data sources. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/wql/v1/dataSources"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if alias is not None:
            params["alias"] = alias
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if searchString is not None:
            params["searchString"] = searchString

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_wql_v1_data_sources {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_wql_v1_data_sources_fields(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the field with a specified {ID} for the specific data source. Also retrieves the related business object of the field. You can only view fields and data sources that you have security access to.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/wql/v1/dataSources/{ID}/fields/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_wql_v1_data_sources_fields {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_wql_v1_data_sources_fields(
        self,
        ID: str,
        alias: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        searchString: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a field of the data source instance, including the related business object of the field.

        Args:
            ID: The Workday ID of the resource. (required)
            alias: The alias of the data source field. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            searchString: The string to be searched in case insensitive manner within the descriptors of the data source fields. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/wql/v1/dataSources/{ID}/fields".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if alias is not None:
            params["alias"] = alias
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if searchString is not None:
            params["searchString"] = searchString

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_wql_v1_data_sources_fields {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_talent_management_v2_values_succession_plan_members(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/values/successionPlan/members/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_talent_management_v2_values_succession_plan_members {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_talent_management_v2_succession_plan_events_submit(
        self,
        ID: str,
        submitSuccessionPlanEvent: Dict[str, Any]
    ) -> WorkdayResponse:
        """Submits a succession plan event.

        Args:
            ID: The Workday ID of the resource. (required)
            submitSuccessionPlanEvent:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/successionPlanEvents/{ID}/submit".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if submitSuccessionPlanEvent is not None:
            if isinstance(submitSuccessionPlanEvent, dict):
                body.update(submitSuccessionPlanEvent)
            else:
                body["submitSuccessionPlanEvent"] = submitSuccessionPlanEvent

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_talent_management_v2_succession_plan_events_submit {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_talent_management_v2_succession_plans(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Get succession plans

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/successionPlans/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_talent_management_v2_succession_plans {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_talent_management_v2_succession_plan_events_candidates(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of information for succession plan candidates for a succession plan event.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/successionPlanEvents/{ID}/candidates".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_talent_management_v2_succession_plan_events_candidates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_talent_management_v2_succession_plan_events_candidates(
        self,
        ID: str,
        successionPlanCandidateDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a single succession plan candidate instance with the specified data.

        Args:
            ID: The Workday ID of the resource. (required)
            successionPlanCandidateDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/successionPlanEvents/{ID}/candidates".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if successionPlanCandidateDetails is not None:
            if isinstance(successionPlanCandidateDetails, dict):
                body.update(successionPlanCandidateDetails)
            else:
                body["successionPlanCandidateDetails"] = successionPlanCandidateDetails

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_talent_management_v2_succession_plan_events_candidates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_talent_management_v2_create_mentorship_for_worker(
        self,
        createMentorshipForWorkerInput: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a mentorship between two workers.

        Args:
            createMentorshipForWorkerInput:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/createMentorshipForWorker"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if createMentorshipForWorkerInput is not None:
            if isinstance(createMentorshipForWorkerInput, dict):
                body.update(createMentorshipForWorkerInput)
            else:
                body["createMentorshipForWorkerInput"] = createMentorshipForWorkerInput

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_talent_management_v2_create_mentorship_for_worker {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_talent_management_v2_mentorships(
        self,
        closeMentorshipReason: Optional[List[str]] = None,
        closed: Optional[bool] = None,
        inProgress: Optional[bool] = None,
        limit: Optional[int] = None,
        mentee: Optional[List[str]] = None,
        mentor: Optional[List[str]] = None,
        mentorType: Optional[List[str]] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Get all mentorships

        Args:
            closeMentorshipReason:  (optional)
            closed:  (optional)
            inProgress:  (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            mentee:  (optional)
            mentor:  (optional)
            mentorType:  (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/mentorships"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if closeMentorshipReason is not None:
            params["closeMentorshipReason"] = closeMentorshipReason
        if closed is not None:
            params["closed"] = closed
        if inProgress is not None:
            params["inProgress"] = inProgress
        if limit is not None:
            params["limit"] = limit
        if mentee is not None:
            params["mentee"] = mentee
        if mentor is not None:
            params["mentor"] = mentor
        if mentorType is not None:
            params["mentorType"] = mentorType
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_talent_management_v2_mentorships {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_talent_management_v2_succession_plan_events_candidates(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves succession plan candidates for the specified succession plan Event ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/successionPlanEvents/{ID}/candidates/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_talent_management_v2_succession_plan_events_candidates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_talent_management_v2_succession_plan_events_candidates(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Removes a succession plan candidate instance associated to the succession plan event.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/successionPlanEvents/{ID}/candidates/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_talent_management_v2_succession_plan_events_candidates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_talent_management_v2_succession_plan_events_candidates(
        self,
        ID: str,
        subresourceID: str,
        successionPlanCandidateDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates a new succession plan candidate instance associated to the succession plan event.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            successionPlanCandidateDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/successionPlanEvents/{ID}/candidates/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if successionPlanCandidateDetails is not None:
            if isinstance(successionPlanCandidateDetails, dict):
                body.update(successionPlanCandidateDetails)
            else:
                body["successionPlanCandidateDetails"] = successionPlanCandidateDetails

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_talent_management_v2_succession_plan_events_candidates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_talent_management_v2_values_succession_plan_strategies(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/values/successionPlan/strategies/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_talent_management_v2_values_succession_plan_strategies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_talent_management_v2_mentorships_close(
        self,
        ID: str,
        closeMentorshipInput: Dict[str, Any]
    ) -> WorkdayResponse:
        """Closes the mentorship.

        Args:
            ID: The Workday ID of the resource. (required)
            closeMentorshipInput:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/mentorships/{ID}/close".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if closeMentorshipInput is not None:
            if isinstance(closeMentorshipInput, dict):
                body.update(closeMentorshipInput)
            else:
                body["closeMentorshipInput"] = closeMentorshipInput

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_talent_management_v2_mentorships_close {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_talent_management_v2_succession_plan_events(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Get Succession Plan Events

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/successionPlanEvents/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_talent_management_v2_succession_plan_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_talent_management_v2_values_succession_plan_readiness(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/values/successionPlan/readiness/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_talent_management_v2_values_succession_plan_readiness {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_talent_management_v2_mentorships_edit(
        self,
        ID: str,
        editMentorshipInput: Dict[str, Any]
    ) -> WorkdayResponse:
        """Edit the mentorship.

        Args:
            ID: The Workday ID of the resource. (required)
            editMentorshipInput:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/mentorships/{ID}/edit".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if editMentorshipInput is not None:
            if isinstance(editMentorshipInput, dict):
                body.update(editMentorshipInput)
            else:
                body["editMentorshipInput"] = editMentorshipInput

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_talent_management_v2_mentorships_edit {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_talent_management_v2_mentorships(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Get all mentorships

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/mentorships/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_talent_management_v2_mentorships {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_talent_management_v2_succession_plans(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        position: Optional[str] = None
    ) -> WorkdayResponse:
        """Get succession plans.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            position: Postion Id (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/successionPlans"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if position is not None:
            params["position"] = position

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_talent_management_v2_succession_plans {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_talent_management_v2_succession_plans(
        self,
        successionPlanDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            successionPlanDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/successionPlans"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if successionPlanDetails is not None:
            if isinstance(successionPlanDetails, dict):
                body.update(successionPlanDetails)
            else:
                body["successionPlanDetails"] = successionPlanDetails

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_talent_management_v2_succession_plans {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_talent_management_v2_succession_plan_events(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        successionPlan: Optional[str] = None
    ) -> WorkdayResponse:
        """Get Succession Plan Events

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            successionPlan: The succession plan instance. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/successionPlanEvents"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if successionPlan is not None:
            params["successionPlan"] = successionPlan

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_talent_management_v2_succession_plan_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_talent_management_v2_succession_plan_events(
        self,
        successionPlanEventDetails: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a succession plan event instance for a succession plan. This roughly corresponds to submissions through the Manage Succession Plan task.

        Args:
            successionPlanEventDetails:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/successionPlanEvents"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if successionPlanEventDetails is not None:
            if isinstance(successionPlanEventDetails, dict):
                body.update(successionPlanEventDetails)
            else:
                body["successionPlanEventDetails"] = successionPlanEventDetails

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_talent_management_v2_succession_plan_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_talent_management_v2_create_mentorship_for_me(
        self,
        createMentorshipForMeInput: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a mentorship for the current processing worker where the user is also the mentee.

        Args:
            createMentorshipForMeInput:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/talentManagement/v2/createMentorshipForMe"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if createMentorshipForMeInput is not None:
            if isinstance(createMentorshipForMeInput, dict):
                body.update(createMentorshipForMeInput)
            else:
                body["createMentorshipForMeInput"] = createMentorshipForMeInput

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_talent_management_v2_create_mentorship_for_me {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_organization_assignment_changes_group_regions(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/organizationAssignmentChangesGroup/regions/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_organization_assignment_changes_group_regions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_job_changes_location(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Returns the location information for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/location".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_job_changes_location {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_staffing_v7_workers_organization_assignment_changes(
        self,
        ID: str,
        organizationAssignmentChangesPost: Dict[str, Any]
    ) -> WorkdayResponse:
        """Initiates an organization assignment change for a specific worker.

        Args:
            ID: The Workday ID of the resource. (required)
            organizationAssignmentChangesPost:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/organizationAssignmentChanges".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if organizationAssignmentChangesPost is not None:
            if isinstance(organizationAssignmentChangesPost, dict):
                body.update(organizationAssignmentChangesPost)
            else:
                body["organizationAssignmentChangesPost"] = organizationAssignmentChangesPost

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_staffing_v7_workers_organization_assignment_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_workers_skill_items(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Returns skill items.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/skillItems".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_workers_skill_items {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_staffing_v7_workers_skill_items(
        self,
        ID: str,
        skillItemsBulkDefinition: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            skillItemsBulkDefinition:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/skillItems".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if skillItemsBulkDefinition is not None:
            if isinstance(skillItemsBulkDefinition, dict):
                body.update(skillItemsBulkDefinition)
            else:
                body["skillItemsBulkDefinition"] = skillItemsBulkDefinition

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_staffing_v7_workers_skill_items {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_job_changes_start_details(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the start details for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/startDetails/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_job_changes_start_details {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_job_changes_start_details(
        self,
        ID: str,
        subresourceID: str,
        jobChangesStartDetailsData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the startDetails options for the specified change job ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            jobChangesStartDetailsData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/startDetails/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if jobChangesStartDetailsData is not None:
            if isinstance(jobChangesStartDetailsData, dict):
                body.update(jobChangesStartDetailsData)
            else:
                body["jobChangesStartDetailsData"] = jobChangesStartDetailsData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_job_changes_start_details {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_staffing_v7_workers_work_contact_information_changes(
        self,
        ID: str,
        workContactChangeEvent: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            workContactChangeEvent:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/workContactInformationChanges".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if workContactChangeEvent is not None:
            if isinstance(workContactChangeEvent, dict):
                body.update(workContactChangeEvent)
            else:
                body["workContactChangeEvent"] = workContactChangeEvent

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_staffing_v7_workers_work_contact_information_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_organization_assignment_changes_region(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a region for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/region".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_organization_assignment_changes_region {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_reason(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/reason/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_reason {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_job_changes_administrative(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves the administrative options for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/administrative".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_job_changes_administrative {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_organization_assignment_changes_group_customs(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/organizationAssignmentChangesGroup/customs/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_organization_assignment_changes_group_customs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_job_changes_job_profile(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a job profile for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/jobProfile/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_job_changes_job_profile {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_job_changes_job_profile(
        self,
        ID: str,
        subresourceID: str,
        changeJobJobProfileData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the jobProfile options for the specified change job ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            changeJobJobProfileData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/jobProfile/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if changeJobJobProfileData is not None:
            if isinstance(changeJobJobProfileData, dict):
                body.update(changeJobJobProfileData)
            else:
                body["changeJobJobProfileData"] = changeJobJobProfileData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_job_changes_job_profile {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_job_changes_location(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Returns the location information for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/location/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_job_changes_location {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_job_changes_location(
        self,
        ID: str,
        subresourceID: str,
        changeJobLocation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the location options for the specified change job ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            changeJobLocation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/location/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if changeJobLocation is not None:
            if isinstance(changeJobLocation, dict):
                body.update(changeJobLocation)
            else:
                body["changeJobLocation"] = changeJobLocation

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_job_changes_location {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_workers_check_in_topics(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of Check-Ins topics.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/checkInTopics".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_workers_check_in_topics {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_staffing_v7_workers_check_in_topics(
        self,
        ID: str,
        checkInTopicDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates Check-In topics.

        Args:
            ID: The Workday ID of the resource. (required)
            checkInTopicDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/checkInTopics".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if checkInTopicDetail is not None:
            if isinstance(checkInTopicDetail, dict):
                body.update(checkInTopicDetail)
            else:
                body["checkInTopicDetail"] = checkInTopicDetail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_staffing_v7_workers_check_in_topics {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_organization_assignment_changes_comment(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves the comment information for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/comment".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_organization_assignment_changes_comment {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_organization_assignment_changes(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single organization assignment change event instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_organization_assignment_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_organization_assignment_changes_custom_organizations(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the custom organizations for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/customOrganizations/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_organization_assignment_changes_custom_organizations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_organization_assignment_changes_custom_organizations(
        self,
        ID: str,
        subresourceID: str,
        organizationAssignmentChangesCustomOrganizationDetailsData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the custom organizations for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            organizationAssignmentChangesCustomOrganizationDetailsData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/customOrganizations/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if organizationAssignmentChangesCustomOrganizationDetailsData is not None:
            if isinstance(organizationAssignmentChangesCustomOrganizationDetailsData, dict):
                body.update(organizationAssignmentChangesCustomOrganizationDetailsData)
            else:
                body["organizationAssignmentChangesCustomOrganizationDetailsData"] = organizationAssignmentChangesCustomOrganizationDetailsData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_organization_assignment_changes_custom_organizations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_supervisory_organization(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/supervisoryOrganization/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_supervisory_organization {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_organization_assignment_changes_business_unit(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a business unit for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/businessUnit/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_organization_assignment_changes_business_unit {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_organization_assignment_changes_business_unit(
        self,
        ID: str,
        subresourceID: str,
        organizationAssignmentChangesBusinessUnitData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the business unit for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            organizationAssignmentChangesBusinessUnitData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/businessUnit/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if organizationAssignmentChangesBusinessUnitData is not None:
            if isinstance(organizationAssignmentChangesBusinessUnitData, dict):
                body.update(organizationAssignmentChangesBusinessUnitData)
            else:
                body["organizationAssignmentChangesBusinessUnitData"] = organizationAssignmentChangesBusinessUnitData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_organization_assignment_changes_business_unit {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_organization_assignment_changes_group_programs(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/organizationAssignmentChangesGroup/programs/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_organization_assignment_changes_group_programs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_organization_assignment_changes_group_jobs(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/organizationAssignmentChangesGroup/jobs/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_organization_assignment_changes_group_jobs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_supervisory_organizations(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single supervisory organization instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/supervisoryOrganizations/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_supervisory_organizations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_job_changes_position(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a position for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/position".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_job_changes_position {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_organization_assignment_changes_group_funds(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/organizationAssignmentChangesGroup/funds/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_organization_assignment_changes_group_funds {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_job_changes_start_details(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves the start details for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/startDetails".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_job_changes_start_details {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_workers_compensation_code_overrides(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/workersCompensationCodeOverrides/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_workers_compensation_code_overrides {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_supervisory_organizations_org_chart(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves information about an organization chart of the specified supervisory organization id.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/supervisoryOrganizations/{ID}/orgChart".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_supervisory_organizations_org_chart {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_workers_check_in_topics(
        self,
        ID: str,
        subresourceID: str,
        checkInTopicArchiveDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates an existing Check-In topic to archived or un-archived.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            checkInTopicArchiveDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/checkInTopics/{subresourceID}?type=archive".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if checkInTopicArchiveDetail is not None:
            if isinstance(checkInTopicArchiveDetail, dict):
                body.update(checkInTopicArchiveDetail)
            else:
                body["checkInTopicArchiveDetail"] = checkInTopicArchiveDetail

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_workers_check_in_topics {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_workers_skill_items(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Returns skill items.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/skillItems/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_workers_skill_items {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_workers_external_skill_level(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves all external skill level information for a worker. You can filter the external skill levels by externalSkillId.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/externalSkillLevel/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_workers_external_skill_level {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_workers_external_skill_level(
        self,
        ID: str,
        subresourceID: str,
        externalSkillLevel: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates external skill levels.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            externalSkillLevel:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/externalSkillLevel/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if externalSkillLevel is not None:
            if isinstance(externalSkillLevel, dict):
                body.update(externalSkillLevel)
            else:
                body["externalSkillLevel"] = externalSkillLevel

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_workers_external_skill_level {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_organization_assignment_changes_start_details(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the start details for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/startDetails/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_organization_assignment_changes_start_details {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_organization_assignment_changes_start_details(
        self,
        ID: str,
        subresourceID: str,
        organizationAssignmentChangesStartDetailsData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the start details for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            organizationAssignmentChangesStartDetailsData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/startDetails/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if organizationAssignmentChangesStartDetailsData is not None:
            if isinstance(organizationAssignmentChangesStartDetailsData, dict):
                body.update(organizationAssignmentChangesStartDetailsData)
            else:
                body["organizationAssignmentChangesStartDetailsData"] = organizationAssignmentChangesStartDetailsData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_organization_assignment_changes_start_details {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_job_changes_move_team(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a move team option from the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/moveTeam/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_job_changes_move_team {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_job_changes_move_team(
        self,
        ID: str,
        subresourceID: str,
        changeJobMoveTeamData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the moveTeam options for the specified change job ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            changeJobMoveTeamData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/moveTeam/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if changeJobMoveTeamData is not None:
            if isinstance(changeJobMoveTeamData, dict):
                body.update(changeJobMoveTeamData)
            else:
                body["changeJobMoveTeamData"] = changeJobMoveTeamData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_job_changes_move_team {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_staffing_v7_workers_home_contact_information_changes(
        self,
        ID: str,
        homeContactChangeEvent: Dict[str, Any]
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            homeContactChangeEvent:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/homeContactInformationChanges".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if homeContactChangeEvent is not None:
            if isinstance(homeContactChangeEvent, dict):
                body.update(homeContactChangeEvent)
            else:
                body["homeContactChangeEvent"] = homeContactChangeEvent

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_staffing_v7_workers_home_contact_information_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_job_changes_position(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a position for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/position/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_job_changes_position {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_job_changes_position(
        self,
        ID: str,
        subresourceID: str,
        changeJobPositionData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the position options for the specified change job ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            changeJobPositionData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/position/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if changeJobPositionData is not None:
            if isinstance(changeJobPositionData, dict):
                body.update(changeJobPositionData)
            else:
                body["changeJobPositionData"] = changeJobPositionData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_job_changes_position {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_job_changes_comment(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Returns the comment information for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/comment".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_job_changes_comment {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_job_profiles(
        self,
        includeInactive: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of job profiles.

        Args:
            includeInactive: If true, the method returns inactive job profiles. Default is false. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobProfiles"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if includeInactive is not None:
            params["includeInactive"] = includeInactive
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_job_profiles {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_job_changes_business_title(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a business title for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/businessTitle/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_job_changes_business_title {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_job_changes_business_title(
        self,
        ID: str,
        subresourceID: str,
        changeJobBusinessTitle: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the businessTitle options for the specified change job ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            changeJobBusinessTitle:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/businessTitle/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if changeJobBusinessTitle is not None:
            if isinstance(changeJobBusinessTitle, dict):
                body.update(changeJobBusinessTitle)
            else:
                body["changeJobBusinessTitle"] = changeJobBusinessTitle

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_job_changes_business_title {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_workers_check_ins(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single Check-In instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/checkIns/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_workers_check_ins {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_staffing_v7_workers_check_ins(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Deletes an existing Check-In instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/checkIns/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_staffing_v7_workers_check_ins {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_workers_check_ins(
        self,
        ID: str,
        subresourceID: str,
        checkInDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates an existing Check-In instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            checkInDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/checkIns/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if checkInDetail is not None:
            if isinstance(checkInDetail, dict):
                body.update(checkInDetail)
            else:
                body["checkInDetail"] = checkInDetail

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_workers_check_ins {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_time_types(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/timeTypes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_time_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_job_changes_job_classification(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a job classification for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/jobClassification".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_job_changes_job_classification {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_work_shifts(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/workShifts/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_work_shifts {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_organization_assignment_changes_group_cost_centers(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/organizationAssignmentChangesGroup/costCenters/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_organization_assignment_changes_group_cost_centers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_job_changes_administrative(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the administrative options for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/administrative/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_job_changes_administrative {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_job_changes_administrative(
        self,
        ID: str,
        subresourceID: str,
        changeJobAdministrativeDetailsData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the administrative options for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            changeJobAdministrativeDetailsData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/administrative/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if changeJobAdministrativeDetailsData is not None:
            if isinstance(changeJobAdministrativeDetailsData, dict):
                body.update(changeJobAdministrativeDetailsData)
            else:
                body["changeJobAdministrativeDetailsData"] = changeJobAdministrativeDetailsData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_job_changes_administrative {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_job_changes_move_team(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a move team option from the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/moveTeam".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_job_changes_move_team {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_job_changes_opening(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves the opening options for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/opening".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_job_changes_opening {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_workers_explicit_skills(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        skill: Optional[str] = None,
        skillSource: Optional[str] = None
    ) -> WorkdayResponse:
        """Get Explicit Skills for Skill Enabled

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            skill: Retrieves the skills for the specified skill name. (optional)
            skillSource: The Workday ID of the skill source. Returns skills associated with the skill source. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/explicitSkills".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if skill is not None:
            params["skill"] = skill
        if skillSource is not None:
            params["skillSource"] = skillSource

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_workers_explicit_skills {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_staffing_v7_workers_explicit_skills(
        self,
        ID: str,
        createSkillUsageRepresentation: Dict[str, Any]
    ) -> WorkdayResponse:
        """Save skills a user has

        Args:
            ID: The Workday ID of the resource. (required)
            createSkillUsageRepresentation:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/explicitSkills".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if createSkillUsageRepresentation is not None:
            if isinstance(createSkillUsageRepresentation, dict):
                body.update(createSkillUsageRepresentation)
            else:
                body["createSkillUsageRepresentation"] = createSkillUsageRepresentation

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_staffing_v7_workers_explicit_skills {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_job_changes_business_title(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a business title for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/businessTitle".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_job_changes_business_title {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_organization_assignment_changes_group_business_units(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/organizationAssignmentChangesGroup/businessUnits/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_organization_assignment_changes_group_business_units {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_workers_explicit_skills(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Get Explicit Skills for Skill Enabled

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/explicitSkills/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_workers_explicit_skills {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_organization_assignment_changes_company(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a company for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/company/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_organization_assignment_changes_company {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_organization_assignment_changes_company(
        self,
        ID: str,
        subresourceID: str,
        organizationAssignmentChangesCompanyData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the company for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            organizationAssignmentChangesCompanyData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/company/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if organizationAssignmentChangesCompanyData is not None:
            if isinstance(organizationAssignmentChangesCompanyData, dict):
                body.update(organizationAssignmentChangesCompanyData)
            else:
                body["organizationAssignmentChangesCompanyData"] = organizationAssignmentChangesCompanyData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_organization_assignment_changes_company {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_job_families(
        self,
        inactive: Optional[bool] = None,
        jobFamilyGroup: Optional[List[str]] = None,
        jobProfile: Optional[List[str]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of job families.

        Args:
            inactive: If true, the method returns inactive job families. Default is false. (optional)
            jobFamilyGroup: The job family group for the job family. You can specify more than 1 jobFamilyGroup query parameter. (optional)
            jobProfile: The job profile for the job family. You can specify more than 1 jobFamilyGroup query parameter. For possible values, you can use a returned id from GET /jobProfiles. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobFamilies"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if inactive is not None:
            params["inactive"] = inactive
        if jobFamilyGroup is not None:
            params["jobFamilyGroup"] = jobFamilyGroup
        if jobProfile is not None:
            params["jobProfile"] = jobProfile
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_job_families {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_organization_assignment_changes_costing(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the costing organizations for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/costing/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_organization_assignment_changes_costing {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_organization_assignment_changes_costing(
        self,
        ID: str,
        subresourceID: str,
        organizationAssignmentChangesCostingData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the costing organization options for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            organizationAssignmentChangesCostingData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/costing/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if organizationAssignmentChangesCostingData is not None:
            if isinstance(organizationAssignmentChangesCostingData, dict):
                body.update(organizationAssignmentChangesCostingData)
            else:
                body["organizationAssignmentChangesCostingData"] = organizationAssignmentChangesCostingData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_organization_assignment_changes_costing {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_workers_check_in_topics(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single Check-In topic instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/checkInTopics/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_workers_check_in_topics {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_staffing_v7_workers_check_in_topics(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Deletes an existing Check-In topic instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/checkInTopics/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_staffing_v7_workers_check_in_topics {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_workers_check_in_topics_1(
        self,
        ID: str,
        subresourceID: str,
        checkInTopicDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates an existing Check-In topic instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            checkInTopicDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/checkInTopics/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if checkInTopicDetail is not None:
            if isinstance(checkInTopicDetail, dict):
                body.update(checkInTopicDetail)
            else:
                body["checkInTopicDetail"] = checkInTopicDetail

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_workers_check_in_topics_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_frequencies(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/frequencies/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_frequencies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_workers_home_contact_information_changes(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves an existing Home Contact Change event for the Person.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/homeContactInformationChanges/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_workers_home_contact_information_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_jobs_workspace(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of workspaces for the specified job ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobs/{ID}/workspace".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_jobs_workspace {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_job_changes_contract(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves the contract options for the specified change job ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/contract".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_job_changes_contract {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_organization_assignment_changes_start_details(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves the start details for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/startDetails".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_organization_assignment_changes_start_details {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_organization_assignment_changes_region(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a region for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/region/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_organization_assignment_changes_region {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_organization_assignment_changes_region(
        self,
        ID: str,
        subresourceID: str,
        organizationAssignmentChangesRegionData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the region for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            organizationAssignmentChangesRegionData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/region/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if organizationAssignmentChangesRegionData is not None:
            if isinstance(organizationAssignmentChangesRegionData, dict):
                body.update(organizationAssignmentChangesRegionData)
            else:
                body["organizationAssignmentChangesRegionData"] = organizationAssignmentChangesRegionData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_organization_assignment_changes_region {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_employee_types(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/employeeTypes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_employee_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_workers_work_contact_information_changes(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves an existing Work Contact Change event for the Person.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/workContactInformationChanges/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_workers_work_contact_information_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_pay_rate_types(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/payRateTypes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_pay_rate_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_jobs(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single job instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobs/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_jobs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_job_changes(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single change job event instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_job_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_workers_check_ins(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of Check-Ins.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/checkIns".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_workers_check_ins {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_staffing_v7_workers_check_ins(
        self,
        ID: str,
        checkInDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates Check-Ins.

        Args:
            ID: The Workday ID of the resource. (required)
            checkInDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/checkIns".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if checkInDetail is not None:
            if isinstance(checkInDetail, dict):
                body.update(checkInDetail)
            else:
                body["checkInDetail"] = checkInDetail

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_staffing_v7_workers_check_ins {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_templates(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/templates/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_templates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_job_families(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single job family instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobFamilies/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_job_families {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_workers(
        self,
        includeTerminatedWorkers: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        search: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of workers and current staffing information.

        Args:
            includeTerminatedWorkers: Include terminated workers in the output (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            search: Searches workers by name or worker ID. The search is case-insensitive. You can include space-delimited search strings for an OR search. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if includeTerminatedWorkers is not None:
            params["includeTerminatedWorkers"] = includeTerminatedWorkers
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if search is not None:
            params["search"] = search

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_organization_assignment_changes_custom_organizations(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves the custom organizations for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/customOrganizations".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_organization_assignment_changes_custom_organizations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_workers(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/workers/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_staffing_v7_job_changes_submit(
        self,
        ID: str,
        eventState: Dict[str, Any]
    ) -> WorkdayResponse:
        """Submit the specified change job ID.

        Args:
            ID: The Workday ID of the resource. (required)
            eventState:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/submit".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if eventState is not None:
            if isinstance(eventState, dict):
                body.update(eventState)
            else:
                body["eventState"] = eventState

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_staffing_v7_job_changes_submit {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_contingent_worker_types(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/contingentWorkerTypes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_contingent_worker_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_supervisory_organizations_members(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single member instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/supervisoryOrganizations/{ID}/members/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_supervisory_organizations_members {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_job_changes_job_classification(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a job classification for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/jobClassification/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_job_changes_job_classification {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_job_changes_job_classification(
        self,
        ID: str,
        subresourceID: str,
        changeJobJobClassificationData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the jobClassification options for the specified change job ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            changeJobJobClassificationData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/jobClassification/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if changeJobJobClassificationData is not None:
            if isinstance(changeJobJobClassificationData, dict):
                body.update(changeJobJobClassificationData)
            else:
                body["changeJobJobClassificationData"] = changeJobJobClassificationData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_job_changes_job_classification {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_staffing_v7_workers_job_changes(
        self,
        ID: str,
        jobChangesStartDetailsPOSTData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Initiates a job change request for a specific worker

        Args:
            ID: The Workday ID of the resource. (required)
            jobChangesStartDetailsPOSTData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/jobChanges".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if jobChangesStartDetailsPOSTData is not None:
            if isinstance(jobChangesStartDetailsPOSTData, dict):
                body.update(jobChangesStartDetailsPOSTData)
            else:
                body["jobChangesStartDetailsPOSTData"] = jobChangesStartDetailsPOSTData

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_staffing_v7_workers_job_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_job_changes_opening(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the opening options for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/opening/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_job_changes_opening {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_job_changes_opening(
        self,
        ID: str,
        subresourceID: str,
        changeJobOpeningData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the opening options for the specified change job ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            changeJobOpeningData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/opening/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if changeJobOpeningData is not None:
            if isinstance(changeJobOpeningData, dict):
                body.update(changeJobOpeningData)
            else:
                body["changeJobOpeningData"] = changeJobOpeningData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_job_changes_opening {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_supervisory_organizations(
        self,
        includeInactive: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a supervisory organization for the specified ID.

        Args:
            includeInactive: If true, this method returns the inactive organizations. Default is false. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/supervisoryOrganizations"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if includeInactive is not None:
            params["includeInactive"] = includeInactive
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_supervisory_organizations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_organization_assignment_changes_costing(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves the costing organizations for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/costing".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_organization_assignment_changes_costing {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_currencies(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/currencies/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_currencies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_workers(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a collection of workers and current staffing information.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_proposed_position(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/proposedPosition/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_proposed_position {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_jobs(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/jobs/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_jobs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_workers_service_dates(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single service date information instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/serviceDates/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_workers_service_dates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_staffing_v7_organization_assignment_changes_submit(
        self,
        ID: str,
        eventStateOrganizationAssignment: Dict[str, Any]
    ) -> WorkdayResponse:
        """Submits the organization changes request for the specified ID, and initiates the Change Organization Assignment business process.

        Args:
            ID: The Workday ID of the resource. (required)
            eventStateOrganizationAssignment:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/submit".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if eventStateOrganizationAssignment is not None:
            if isinstance(eventStateOrganizationAssignment, dict):
                body.update(eventStateOrganizationAssignment)
            else:
                body["eventStateOrganizationAssignment"] = eventStateOrganizationAssignment

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_staffing_v7_organization_assignment_changes_submit {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_company_insider_types(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/companyInsiderTypes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_company_insider_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_organization_assignment_changes_cost_center(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a cost center for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/costCenter/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_organization_assignment_changes_cost_center {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_organization_assignment_changes_cost_center(
        self,
        ID: str,
        subresourceID: str,
        organizationAssignmentChangesCostCenterData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the cost center for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            organizationAssignmentChangesCostCenterData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/costCenter/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if organizationAssignmentChangesCostCenterData is not None:
            if isinstance(organizationAssignmentChangesCostCenterData, dict):
                body.update(organizationAssignmentChangesCostCenterData)
            else:
                body["organizationAssignmentChangesCostCenterData"] = organizationAssignmentChangesCostCenterData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_organization_assignment_changes_cost_center {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_organization_assignment_changes_comment(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the comment information for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/comment/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_organization_assignment_changes_comment {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_organization_assignment_changes_comment(
        self,
        ID: str,
        subresourceID: str,
        comments: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates  the comment for the organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            comments:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/comment/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if comments is not None:
            if isinstance(comments, dict):
                body.update(comments)
            else:
                body["comments"] = comments

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_organization_assignment_changes_comment {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_headcount_options(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/headcountOptions/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_headcount_options {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_organization_assignment_changes_group_grants(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/organizationAssignmentChangesGroup/grants/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_organization_assignment_changes_group_grants {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_workers_service_dates(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of service dates for the specified worker id.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/serviceDates".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_workers_service_dates {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_worker_types(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/workerTypes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_worker_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_organization_assignment_changes_group_workers(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/organizationAssignmentChangesGroup/workers/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_organization_assignment_changes_group_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_job_changes_contract(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves the contract options for the specified change job ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/contract/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_job_changes_contract {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_job_changes_contract(
        self,
        ID: str,
        subresourceID: str,
        changeJobContractDetailsData: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the contract options for the specified change job ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            changeJobContractDetailsData:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/contract/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if changeJobContractDetailsData is not None:
            if isinstance(changeJobContractDetailsData, dict):
                body.update(changeJobContractDetailsData)
            else:
                body["changeJobContractDetailsData"] = changeJobContractDetailsData

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_job_changes_contract {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_jobs(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of jobs.

        Args:
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobs"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_jobs {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_workers_check_ins_1(
        self,
        ID: str,
        subresourceID: str,
        checkInArchiveDetail: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates an existing Check-In to archived or un-archived.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            checkInArchiveDetail:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/checkIns/{subresourceID}?type=archive".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if checkInArchiveDetail is not None:
            if isinstance(checkInArchiveDetail, dict):
                body.update(checkInArchiveDetail)
            else:
                body["checkInArchiveDetail"] = checkInArchiveDetail

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_workers_check_ins_1 {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_work_study_awards(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/workStudyAwards/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_work_study_awards {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_locations(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/locations/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_locations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_job_changes_job_profile(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a job profile for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/jobProfile".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_job_changes_job_profile {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_job_profiles(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a single job profile instance.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobProfiles/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_job_profiles {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_organization_assignment_changes_group_positions(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/organizationAssignmentChangesGroup/positions/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_organization_assignment_changes_group_positions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_workers_external_skill_level(
        self,
        ID: str,
        externalSkillId: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves all external skill level information for a worker. You can filter the external skill levels by externalSkillId.

        Args:
            ID: The Workday ID of the resource. (required)
            externalSkillId: All External Skills. If passed, the External Skill Level associated with the External Skill ID. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/externalSkillLevel".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if externalSkillId is not None:
            params["externalSkillId"] = externalSkillId
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_workers_external_skill_level {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_staffing_v7_workers_external_skill_level(
        self,
        ID: str,
        externalSkillLevel: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates external skill levels.

        Args:
            ID: The Workday ID of the resource. (required)
            externalSkillLevel:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/workers/{ID}/externalSkillLevel".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if externalSkillLevel is not None:
            if isinstance(externalSkillLevel, dict):
                body.update(externalSkillLevel)
            else:
                body["externalSkillLevel"] = externalSkillLevel

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_staffing_v7_workers_external_skill_level {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_staffing_v7_organization_assignment_changes(
        self,
        organizationAssignmentChangesPostPosition: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a new change organization assignment event for a specific filled or unfilled position.

        Args:
            organizationAssignmentChangesPostPosition:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if organizationAssignmentChangesPostPosition is not None:
            if isinstance(organizationAssignmentChangesPostPosition, dict):
                body.update(organizationAssignmentChangesPostPosition)
            else:
                body["organizationAssignmentChangesPostPosition"] = organizationAssignmentChangesPostPosition

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_staffing_v7_organization_assignment_changes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_supervisory_organizations_members(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of members for the specified supervisory organization ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/supervisoryOrganizations/{ID}/members".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_supervisory_organizations_members {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_jobs_workspace(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single workspace instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobs/{ID}/workspace/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_jobs_workspace {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_job_requisitions(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/jobRequisitions/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_job_requisitions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_job_profiles(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/jobProfiles/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_job_profiles {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_organization_assignment_changes_group_companies(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/organizationAssignmentChangesGroup/companies/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_organization_assignment_changes_group_companies {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_work_spaces(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/workSpaces/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_work_spaces {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_organization_assignment_changes_business_unit(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a business unit for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/businessUnit".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_organization_assignment_changes_business_unit {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_assignment_types(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/assignmentTypes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_assignment_types {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_job_changes_group_job_classifications(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/jobChangesGroup/jobClassifications/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_job_changes_group_job_classifications {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_values_organization_assignment_changes_group_gifts(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/values/organizationAssignmentChangesGroup/gifts/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_values_organization_assignment_changes_group_gifts {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_organization_assignment_changes_company(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a company for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/company".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_organization_assignment_changes_company {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_supervisory_organizations_org_chart(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a single organization chart instance.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/supervisoryOrganizations/{ID}/orgChart/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_supervisory_organizations_org_chart {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_staffing_v7_job_changes_comment(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Returns the comment information for the specified job change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/comment/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_staffing_v7_job_changes_comment {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_staffing_v7_job_changes_comment(
        self,
        ID: str,
        subresourceID: str,
        comments: Dict[str, Any]
    ) -> WorkdayResponse:
        """Partially updates the comment for the specified change job ID.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            comments:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/jobChanges/{ID}/comment/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if comments is not None:
            if isinstance(comments, dict):
                body.update(comments)
            else:
                body["comments"] = comments

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_staffing_v7_job_changes_comment {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_staffing_v7_organization_assignment_changes_cost_center(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a cost center for the specified organization assignment change ID.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/staffing/v7/organizationAssignmentChanges/{ID}/costCenter".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_staffing_v7_organization_assignment_changes_cost_center {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_worker_time_attestation_followup_worker_time_attestation(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/workerTimeAttestation/{ID}/followupWorkerTimeAttestation".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_worker_time_attestation_followup_worker_time_attestation {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_time_validations(
        self,
        date: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        worker: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of time entry validations.

        Args:
            date: The required date that determines the time entry validations. The method validates the time entries within week or time period of the specified date. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            worker: The required Workday ID of the worker who entered the time entries. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/timeValidations"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if date is not None:
            params["date"] = date
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if worker is not None:
            params["worker"] = worker

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_time_validations {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_values_time_types_time_entry_codes(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/values/timeTypes/timeEntryCodes/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_values_time_types_time_entry_codes {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_values_time_values_positions(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/values/timeValues/positions/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_values_time_values_positions {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_values_enter_time_by_type_time_type_nested(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/values/enterTimeByType/timeTypeNested/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_values_enter_time_by_type_time_type_nested {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_values_time_types_default_time_entry_code(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/values/timeTypes/defaultTimeEntryCode/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_values_time_types_default_time_entry_code {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_time_tracking_v5_workers_worker_time_block(
        self,
        ID: str,
        timeBlockView: Dict[str, Any]
    ) -> WorkdayResponse:
        """Creates a worker time block.

        Args:
            ID: The Workday ID of the resource. (required)
            timeBlockView:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/workers/{ID}/workerTimeBlock".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if timeBlockView is not None:
            if isinstance(timeBlockView, dict):
                body.update(timeBlockView)
            else:
                body["timeBlockView"] = timeBlockView

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_time_tracking_v5_workers_worker_time_block {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_workers(
        self,
        includeTerminatedWorkers: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        search: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of workers and current staffing information.

        Args:
            includeTerminatedWorkers: Include terminated workers in the output (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            search: Searches workers by name or worker ID. The search is case-insensitive. You can include space-delimited search strings for an OR search. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/workers"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if includeTerminatedWorkers is not None:
            params["includeTerminatedWorkers"] = includeTerminatedWorkers
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if search is not None:
            params["search"] = search

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_time_tracking_v5_workers_worker_time_block(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Deletes a specified worker time block.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/workers/{ID}/workerTimeBlock/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_time_tracking_v5_workers_worker_time_block {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_time_tracking_v5_workers_worker_time_block(
        self,
        ID: str,
        subresourceID: str,
        timeBlockView: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates a specified worker time block.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)
            timeBlockView:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/workers/{ID}/workerTimeBlock/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if timeBlockView is not None:
            if isinstance(timeBlockView, dict):
                body.update(timeBlockView)
            else:
                body["timeBlockView"] = timeBlockView

        try:
            request = HTTPRequest(
                url=url,
                method="PATCH",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_time_tracking_v5_workers_worker_time_block {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_workers_time_totals(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        periodDate: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a summary of reported hours for a worker over a period.

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            periodDate: Contains the specified date used to match to a period containing the date. The default is today's date. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/workers/{ID}/timeTotals".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if periodDate is not None:
            params["periodDate"] = periodDate

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_workers_time_totals {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_time_tracking_v5_worker_time_blocks(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a worker time block.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/workerTimeBlocks/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_time_tracking_v5_worker_time_blocks {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_time_clock_events(
        self,
        fromDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        toDate: Optional[str] = None,
        worker: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of time clock events for a worker for a date range.

        Args:
            fromDate: The start date of the time event using the yyyy-mm-dd format. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            toDate: The end date of the time event using the yyyy-mm-dd format. (optional)
            worker: The Workday ID of the worker for the time block or clock event. You can specify multiple worker query parameters. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/timeClockEvents"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if fromDate is not None:
            params["fromDate"] = fromDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if toDate is not None:
            params["toDate"] = toDate
        if worker is not None:
            params["worker"] = worker

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_time_clock_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_time_tracking_v5_time_clock_events(
        self,
        timeClockEventView: Dict[str, Any]
    ) -> WorkdayResponse:
        """Adds time clock events for the specified workers. This endpoint is used for both check in and check out.

        Args:
            timeClockEventView:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/timeClockEvents"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if timeClockEventView is not None:
            if isinstance(timeClockEventView, dict):
                body.update(timeClockEventView)
            else:
                body["timeClockEventView"] = timeClockEventView

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_time_tracking_v5_time_clock_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def create_time_tracking_v5_workers_time_review_events(
        self,
        ID: str,
        timeReviewEventContainerView: Dict[str, Any]
    ) -> WorkdayResponse:
        """Adds time review events for the specified worker.

        Args:
            ID: The Workday ID of the resource. (required)
            timeReviewEventContainerView:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/workers/{ID}/timeReviewEvents".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if timeReviewEventContainerView is not None:
            if isinstance(timeReviewEventContainerView, dict):
                body.update(timeReviewEventContainerView)
            else:
                body["timeReviewEventContainerView"] = timeReviewEventContainerView

        try:
            request = HTTPRequest(
                url=url,
                method="POST",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"create_time_tracking_v5_workers_time_review_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_time_tracking_v5_worker_time_attestation(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a worker time attestation.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/workerTimeAttestation/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_time_tracking_v5_worker_time_attestation {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_values_time_values_worker_time_zone(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/values/timeValues/workerTimeZone/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_values_time_values_worker_time_zone {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_time_tracking_v5_workers_time_totals(
        self,
        ID: str,
        subresourceID: str
    ) -> WorkdayResponse:
        """Retrieves a summary of reported hours for a worker over a period.

        Args:
            ID: The Workday ID of the resource. (required)
            subresourceID: The Workday ID of the subresource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/workers/{ID}/timeTotals/{subresourceID}".replace("{ID}", str(ID)).replace("{subresourceID}", str(subresourceID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_time_tracking_v5_workers_time_totals {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_time_tracking_v5_time_clock_events(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a time clock event.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/timeClockEvents/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_time_tracking_v5_time_clock_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def update_time_tracking_v5_time_clock_events(
        self,
        ID: str,
        timeClockEventView: Dict[str, Any]
    ) -> WorkdayResponse:
        """Updates the time clock event for the specified ID.

        Args:
            ID: The Workday ID of the resource. (required)
            timeClockEventView:  (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/timeClockEvents/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if timeClockEventView is not None:
            if isinstance(timeClockEventView, dict):
                body.update(timeClockEventView)
            else:
                body["timeClockEventView"] = timeClockEventView

        try:
            request = HTTPRequest(
                url=url,
                method="PUT",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"update_time_tracking_v5_time_clock_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def delete_time_tracking_v5_time_clock_events(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Deletes a time clock event.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/timeClockEvents/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="DELETE",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"delete_time_tracking_v5_time_clock_events {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_values_time_types_project_plan_tasks(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/values/timeTypes/projectPlanTasks/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_values_time_types_project_plan_tasks {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_workers_period(
        self,
        ID: str,
        date: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """Retrieves a period from the period schedule the worker is eligible for.

        Args:
            ID: The Workday ID of the resource. (required)
            date: The date on which the worker is eligible, using the yyyy-mm-dd format. If date isn't given it will default to the current Date. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/workers/{ID}/period".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if date is not None:
            params["date"] = date
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_workers_period {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_values_time_types_projects(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/values/timeTypes/projects/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_values_time_types_projects {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def get_time_tracking_v5_workers(
        self,
        ID: str
    ) -> WorkdayResponse:
        """Retrieves a collection of workers and current staffing information.

        Args:
            ID: The Workday ID of the resource. (required)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/workers/{ID}".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"get_time_tracking_v5_workers {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_worker_time_attestation_followup_time_attestation_prompt(
        self,
        ID: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None
    ) -> WorkdayResponse:
        """No summary

        Args:
            ID: The Workday ID of the resource. (required)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/workerTimeAttestation/{ID}/followupTimeAttestationPrompt".replace("{ID}", str(ID))
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_worker_time_attestation_followup_time_attestation_prompt {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_values_time_values_out_reason(
        self
    ) -> WorkdayResponse:
        """No summary

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/values/timeValues/outReason/"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_values_time_values_out_reason {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_worker_time_blocks(
        self,
        fromDate: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        phase: Optional[List[str]] = None,
        project: Optional[List[str]] = None,
        projectPlanTask: Optional[List[str]] = None,
        status: Optional[List[str]] = None,
        toDate: Optional[str] = None,
        worker: Optional[List[str]] = None
    ) -> WorkdayResponse:
        """Retrieves time blocks for specified workers over a date range.

        Args:
            fromDate: The start date of the time block date range, using the yyyy-mm-dd format. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            phase: The Workday ID of the project plan phase for the time block.
You can specify 1 or more project plan phase query parameters.
You can use a returned id from the GET /planPhases endpoint in the Projects REST web service. (optional)
            project: The Workday ID of the project for the time block.
You can specify 1 or more project query parameters.
You can use a returned id from the GET /projects endpoint in the Projects REST web service. (optional)
            projectPlanTask: The Workday ID of the project plan task for the time block.
You can specify 1 or more project plan task query parameters.
You can use a returned id from the GET /planTasks endpoint in the Projects REST web service. (optional)
            status: The Workday ID of the approval status of the worker time block. Valid IDs are:

* Submitted: dd817fe688db4ac7bf84e3ef79f72948

* Unsubmitted (Not Submitted): ddf5968e6d4430ca4bce9a4cfaba337

* Approved: 0391102bd1b542538d996936c8fa2fa7

* Denied: 8fee8e9d07554b968bb1f19e679e5a05

* Sent Back: 070b249867f747a19bca64f73eafc9b8

You can specify 1 or more status query parameters. (optional)
            toDate: The end date of the time block date range, using the yyyy-mm-dd format. (optional)
            worker: The Workday ID of the worker for the time block. Specify workers that the user has permission to access.
You can specify 1 or more worker query parameters.
You can use returned ids from GET /workers. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/workerTimeBlocks"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if fromDate is not None:
            params["fromDate"] = fromDate
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if phase is not None:
            params["phase"] = phase
        if project is not None:
            params["project"] = project
        if projectPlanTask is not None:
            params["projectPlanTask"] = projectPlanTask
        if status is not None:
            params["status"] = status
        if toDate is not None:
            params["toDate"] = toDate
        if worker is not None:
            params["worker"] = worker

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_worker_time_blocks {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))

    async def list_time_tracking_v5_time_attestation_prompts(
        self,
        dateTime: Optional[str] = None,
        eventType: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeZone: Optional[str] = None,
        worker: Optional[str] = None
    ) -> WorkdayResponse:
        """Retrieves a collection of time attestation prompts for a time clock event.

        Args:
            dateTime: The date and time of the simulated time clock event using the yyyy-mm-ddThh:mm:ss.sss format. (optional)
            eventType: The Workday ID of the event type for the simulated time clock event. (optional)
            limit: The maximum number of objects in a single response. The default is 20. The maximum is 100. (optional)
            offset: The zero-based index of the first object in a response collection. The default is 0. Use offset with the limit parameter to control paging of a response collection. Example: If limit is 5 and offset is 9, the response returns a collection of 5 objects starting with the 10th object. (optional)
            timeZone: The Workday ID of the time zone for the simulated time clock event. (optional)
            worker: The Workday ID of the worker for the simulated time clock event. (optional)

        Returns:
            WorkdayResponse
        """
        url = f"{self.base_url}/timeTracking/v5/timeAttestationPrompts"
        params: Dict[str, Any] = {}
        body: Dict[str, Any] = {}
        if dateTime is not None:
            params["dateTime"] = dateTime
        if eventType is not None:
            params["eventType"] = eventType
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if timeZone is not None:
            params["timeZone"] = timeZone
        if worker is not None:
            params["worker"] = worker

        try:
            request = HTTPRequest(
                url=url,
                method="GET",
                headers={"Content-Type": "application/json"},
                query_params=params,
                body=body if body else None
            )
            response = await self.http_client.execute(request)

            success = response.status < HTTP_ERROR_THRESHOLD
            return WorkdayResponse(
                success=success,
                data=response.json() if response.text else None,
                message=f"list_time_tracking_v5_time_attestation_prompts {'succeeded' if success else 'failed'}",
                error=response.text if not success else None
            )
        except Exception as e:
            return WorkdayResponse(success=False, error=str(e), message=str(e))
