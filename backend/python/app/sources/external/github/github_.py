import logging

from app.sources.client.github.github import GitHubClient, GitHubResponse

logger = logging.getLogger(__name__)
class GitHubDataSource:
    def __init__(self, client: GitHubClient) -> None:
        self.client = client

    async def actions_add_custom_labels_to_self_hosted_runner_for_org(self, **kwargs) -> GitHubResponse:
        """Add custom labels to a self-hosted runner for an organization (HTTP POST /orgs/{org}/actions/runners/{runner_id}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_add_custom_labels_to_self_hosted_runner_for_org" in method_map:
                result = method_map["actions_add_custom_labels_to_self_hosted_runner_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/add-custom-labels-to-self-hosted-runner-for-org' (actions_add_custom_labels_to_self_hosted_runner_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_add_custom_labels_to_self_hosted_runner_for_repo(self, **kwargs) -> GitHubResponse:
        """Add custom labels to a self-hosted runner for a repository (HTTP POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_add_custom_labels_to_self_hosted_runner_for_repo" in method_map:
                result = method_map["actions_add_custom_labels_to_self_hosted_runner_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/add-custom-labels-to-self-hosted-runner-for-repo' (actions_add_custom_labels_to_self_hosted_runner_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_add_repo_access_to_self_hosted_runner_group_in_org(self, **kwargs) -> GitHubResponse:
        """Add repository access to a self-hosted runner group in an organization (HTTP PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_add_repo_access_to_self_hosted_runner_group_in_org" in method_map:
                result = method_map["actions_add_repo_access_to_self_hosted_runner_group_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/add-repo-access-to-self-hosted-runner-group-in-org' (actions_add_repo_access_to_self_hosted_runner_group_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_add_selected_repo_to_org_secret(self, **kwargs) -> GitHubResponse:
        """Add selected repository to an organization secret (HTTP PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_add_selected_repo_to_org_secret" in method_map:
                result = method_map["actions_add_selected_repo_to_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/add-selected-repo-to-org-secret' (actions_add_selected_repo_to_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_add_selected_repo_to_org_variable(self, **kwargs) -> GitHubResponse:
        """Add selected repository to an organization variable (HTTP PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_add_selected_repo_to_org_variable" in method_map:
                result = method_map["actions_add_selected_repo_to_org_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/add-selected-repo-to-org-variable' (actions_add_selected_repo_to_org_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_add_self_hosted_runner_to_group_for_org(self, **kwargs) -> GitHubResponse:
        """Add a self-hosted runner to a group for an organization (HTTP PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_add_self_hosted_runner_to_group_for_org" in method_map:
                result = method_map["actions_add_self_hosted_runner_to_group_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/add-self-hosted-runner-to-group-for-org' (actions_add_self_hosted_runner_to_group_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_approve_workflow_run(self, **kwargs) -> GitHubResponse:
        """Approve a workflow run for a fork pull request (HTTP POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_approve_workflow_run" in method_map:
                result = method_map["actions_approve_workflow_run"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/approve-workflow-run' (actions_approve_workflow_run). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_cancel_workflow_run(self, **kwargs) -> GitHubResponse:
        """Cancel a workflow run (HTTP POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_cancel_workflow_run" in method_map:
                result = method_map["actions_cancel_workflow_run"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/cancel-workflow-run' (actions_cancel_workflow_run). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_create_environment_variable(self, **kwargs) -> GitHubResponse:
        """Create an environment variable (HTTP POST /repos/{owner}/{repo}/environments/{environment_name}/variables)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_create_environment_variable" in method_map:
                result = method_map["actions_create_environment_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/create-environment-variable' (actions_create_environment_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_create_hosted_runner_for_org(self, **kwargs) -> GitHubResponse:
        """Create a GitHub-hosted runner for an organization (HTTP POST /orgs/{org}/actions/hosted-runners)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_create_hosted_runner_for_org" in method_map:
                result = method_map["actions_create_hosted_runner_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/create-hosted-runner-for-org' (actions_create_hosted_runner_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_create_or_update_environment_secret(self, **kwargs) -> GitHubResponse:
        """Create or update an environment secret (HTTP PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_create_or_update_environment_secret" in method_map:
                result = method_map["actions_create_or_update_environment_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/create-or-update-environment-secret' (actions_create_or_update_environment_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_create_or_update_org_secret(self, **kwargs) -> GitHubResponse:
        """Create or update an organization secret (HTTP PUT /orgs/{org}/actions/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_create_or_update_org_secret" in method_map:
                result = method_map["actions_create_or_update_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/create-or-update-org-secret' (actions_create_or_update_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_create_or_update_repo_secret(self, **kwargs) -> GitHubResponse:
        """Create or update a repository secret (HTTP PUT /repos/{owner}/{repo}/actions/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_create_or_update_repo_secret" in method_map:
                result = method_map["actions_create_or_update_repo_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/create-or-update-repo-secret' (actions_create_or_update_repo_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_create_org_variable(self, **kwargs) -> GitHubResponse:
        """Create an organization variable (HTTP POST /orgs/{org}/actions/variables)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_create_org_variable" in method_map:
                result = method_map["actions_create_org_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/create-org-variable' (actions_create_org_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_create_registration_token_for_org(self, **kwargs) -> GitHubResponse:
        """Create a registration token for an organization (HTTP POST /orgs/{org}/actions/runners/registration-token)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_create_registration_token_for_org" in method_map:
                result = method_map["actions_create_registration_token_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/create-registration-token-for-org' (actions_create_registration_token_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_create_registration_token_for_repo(self, **kwargs) -> GitHubResponse:
        """Create a registration token for a repository (HTTP POST /repos/{owner}/{repo}/actions/runners/registration-token)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_create_registration_token_for_repo" in method_map:
                result = method_map["actions_create_registration_token_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/create-registration-token-for-repo' (actions_create_registration_token_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_create_remove_token_for_org(self, **kwargs) -> GitHubResponse:
        """Create a remove token for an organization (HTTP POST /orgs/{org}/actions/runners/remove-token)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_create_remove_token_for_org" in method_map:
                result = method_map["actions_create_remove_token_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/create-remove-token-for-org' (actions_create_remove_token_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_create_remove_token_for_repo(self, **kwargs) -> GitHubResponse:
        """Create a remove token for a repository (HTTP POST /repos/{owner}/{repo}/actions/runners/remove-token)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_create_remove_token_for_repo" in method_map:
                result = method_map["actions_create_remove_token_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/create-remove-token-for-repo' (actions_create_remove_token_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_create_repo_variable(self, **kwargs) -> GitHubResponse:
        """Create a repository variable (HTTP POST /repos/{owner}/{repo}/actions/variables)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_create_repo_variable" in method_map:
                result = method_map["actions_create_repo_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/create-repo-variable' (actions_create_repo_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_create_self_hosted_runner_group_for_org(self, **kwargs) -> GitHubResponse:
        """Create a self-hosted runner group for an organization (HTTP POST /orgs/{org}/actions/runner-groups)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_create_self_hosted_runner_group_for_org" in method_map:
                result = method_map["actions_create_self_hosted_runner_group_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/create-self-hosted-runner-group-for-org' (actions_create_self_hosted_runner_group_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_create_workflow_dispatch(self, **kwargs) -> GitHubResponse:
        """Create a workflow dispatch event (HTTP POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_create_workflow_dispatch" in method_map:
                result = method_map["actions_create_workflow_dispatch"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/create-workflow-dispatch' (actions_create_workflow_dispatch). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_actions_cache_by_id(self, **kwargs) -> GitHubResponse:
        """Delete a GitHub Actions cache for a repository (using a cache ID) (HTTP DELETE /repos/{owner}/{repo}/actions/caches/{cache_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_actions_cache_by_id" in method_map:
                result = method_map["actions_delete_actions_cache_by_id"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-actions-cache-by-id' (actions_delete_actions_cache_by_id). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_actions_cache_by_key(self, **kwargs) -> GitHubResponse:
        """Delete GitHub Actions caches for a repository (using a cache key) (HTTP DELETE /repos/{owner}/{repo}/actions/caches)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_actions_cache_by_key" in method_map:
                result = method_map["actions_delete_actions_cache_by_key"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-actions-cache-by-key' (actions_delete_actions_cache_by_key). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_artifact(self, **kwargs) -> GitHubResponse:
        """Delete an artifact (HTTP DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_artifact" in method_map:
                result = method_map["actions_delete_artifact"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-artifact' (actions_delete_artifact). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_environment_secret(self, **kwargs) -> GitHubResponse:
        """Delete an environment secret (HTTP DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_environment_secret" in method_map:
                result = method_map["actions_delete_environment_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-environment-secret' (actions_delete_environment_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_environment_variable(self, **kwargs) -> GitHubResponse:
        """Delete an environment variable (HTTP DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_environment_variable" in method_map:
                result = method_map["actions_delete_environment_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-environment-variable' (actions_delete_environment_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_hosted_runner_for_org(self, **kwargs) -> GitHubResponse:
        """Delete a GitHub-hosted runner for an organization (HTTP DELETE /orgs/{org}/actions/hosted-runners/{hosted_runner_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_hosted_runner_for_org" in method_map:
                result = method_map["actions_delete_hosted_runner_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-hosted-runner-for-org' (actions_delete_hosted_runner_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_org_secret(self, **kwargs) -> GitHubResponse:
        """Delete an organization secret (HTTP DELETE /orgs/{org}/actions/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_org_secret" in method_map:
                result = method_map["actions_delete_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-org-secret' (actions_delete_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_org_variable(self, **kwargs) -> GitHubResponse:
        """Delete an organization variable (HTTP DELETE /orgs/{org}/actions/variables/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_org_variable" in method_map:
                result = method_map["actions_delete_org_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-org-variable' (actions_delete_org_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_repo_secret(self, **kwargs) -> GitHubResponse:
        """Delete a repository secret (HTTP DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_repo_secret" in method_map:
                result = method_map["actions_delete_repo_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-repo-secret' (actions_delete_repo_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_repo_variable(self, **kwargs) -> GitHubResponse:
        """Delete a repository variable (HTTP DELETE /repos/{owner}/{repo}/actions/variables/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_repo_variable" in method_map:
                result = method_map["actions_delete_repo_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-repo-variable' (actions_delete_repo_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_self_hosted_runner_from_org(self, **kwargs) -> GitHubResponse:
        """Delete a self-hosted runner from an organization (HTTP DELETE /orgs/{org}/actions/runners/{runner_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_self_hosted_runner_from_org" in method_map:
                result = method_map["actions_delete_self_hosted_runner_from_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-self-hosted-runner-from-org' (actions_delete_self_hosted_runner_from_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_self_hosted_runner_from_repo(self, **kwargs) -> GitHubResponse:
        """Delete a self-hosted runner from a repository (HTTP DELETE /repos/{owner}/{repo}/actions/runners/{runner_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_self_hosted_runner_from_repo" in method_map:
                result = method_map["actions_delete_self_hosted_runner_from_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-self-hosted-runner-from-repo' (actions_delete_self_hosted_runner_from_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_self_hosted_runner_group_from_org(self, **kwargs) -> GitHubResponse:
        """Delete a self-hosted runner group from an organization (HTTP DELETE /orgs/{org}/actions/runner-groups/{runner_group_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_self_hosted_runner_group_from_org" in method_map:
                result = method_map["actions_delete_self_hosted_runner_group_from_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-self-hosted-runner-group-from-org' (actions_delete_self_hosted_runner_group_from_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_workflow_run(self, **kwargs) -> GitHubResponse:
        """Delete a workflow run (HTTP DELETE /repos/{owner}/{repo}/actions/runs/{run_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_workflow_run" in method_map:
                result = method_map["actions_delete_workflow_run"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-workflow-run' (actions_delete_workflow_run). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_delete_workflow_run_logs(self, **kwargs) -> GitHubResponse:
        """Delete workflow run logs (HTTP DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_delete_workflow_run_logs" in method_map:
                result = method_map["actions_delete_workflow_run_logs"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/delete-workflow-run-logs' (actions_delete_workflow_run_logs). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_disable_selected_repository_github_actions_organization(self, **kwargs) -> GitHubResponse:
        """Disable a selected repository for GitHub Actions in an organization (HTTP DELETE /orgs/{org}/actions/permissions/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_disable_selected_repository_github_actions_organization" in method_map:
                result = method_map["actions_disable_selected_repository_github_actions_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/disable-selected-repository-github-actions-organization' (actions_disable_selected_repository_github_actions_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_disable_selected_repository_self_hosted_runners_organization(self, **kwargs) -> GitHubResponse:
        """Remove a repository from the list of repositories allowed to use self-hosted runners in an organization (HTTP DELETE /orgs/{org}/actions/permissions/self-hosted-runners/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_disable_selected_repository_self_hosted_runners_organization" in method_map:
                result = method_map["actions_disable_selected_repository_self_hosted_runners_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/disable-selected-repository-self-hosted-runners-organization' (actions_disable_selected_repository_self_hosted_runners_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_disable_workflow(self, **kwargs) -> GitHubResponse:
        """Disable a workflow (HTTP PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_disable_workflow" in method_map:
                result = method_map["actions_disable_workflow"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/disable-workflow' (actions_disable_workflow). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_download_artifact(self, **kwargs) -> GitHubResponse:
        """Download an artifact (HTTP GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_download_artifact" in method_map:
                result = method_map["actions_download_artifact"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/download-artifact' (actions_download_artifact). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_download_job_logs_for_workflow_run(self, **kwargs) -> GitHubResponse:
        """Download job logs for a workflow run (HTTP GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_download_job_logs_for_workflow_run" in method_map:
                result = method_map["actions_download_job_logs_for_workflow_run"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/download-job-logs-for-workflow-run' (actions_download_job_logs_for_workflow_run). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_download_workflow_run_attempt_logs(self, **kwargs) -> GitHubResponse:
        """Download workflow run attempt logs (HTTP GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_download_workflow_run_attempt_logs" in method_map:
                result = method_map["actions_download_workflow_run_attempt_logs"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/download-workflow-run-attempt-logs' (actions_download_workflow_run_attempt_logs). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_download_workflow_run_logs(self, **kwargs) -> GitHubResponse:
        """Download workflow run logs (HTTP GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_download_workflow_run_logs" in method_map:
                result = method_map["actions_download_workflow_run_logs"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/download-workflow-run-logs' (actions_download_workflow_run_logs). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_enable_selected_repository_github_actions_organization(self, **kwargs) -> GitHubResponse:
        """Enable a selected repository for GitHub Actions in an organization (HTTP PUT /orgs/{org}/actions/permissions/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_enable_selected_repository_github_actions_organization" in method_map:
                result = method_map["actions_enable_selected_repository_github_actions_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/enable-selected-repository-github-actions-organization' (actions_enable_selected_repository_github_actions_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_enable_selected_repository_self_hosted_runners_organization(self, **kwargs) -> GitHubResponse:
        """Add a repository to the list of repositories allowed to use self-hosted runners in an organization (HTTP PUT /orgs/{org}/actions/permissions/self-hosted-runners/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_enable_selected_repository_self_hosted_runners_organization" in method_map:
                result = method_map["actions_enable_selected_repository_self_hosted_runners_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/enable-selected-repository-self-hosted-runners-organization' (actions_enable_selected_repository_self_hosted_runners_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_enable_workflow(self, **kwargs) -> GitHubResponse:
        """Enable a workflow (HTTP PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_enable_workflow" in method_map:
                result = method_map["actions_enable_workflow"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/enable-workflow' (actions_enable_workflow). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_force_cancel_workflow_run(self, **kwargs) -> GitHubResponse:
        """Force cancel a workflow run (HTTP POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_force_cancel_workflow_run" in method_map:
                result = method_map["actions_force_cancel_workflow_run"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/force-cancel-workflow-run' (actions_force_cancel_workflow_run). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_generate_runner_jitconfig_for_org(self, **kwargs) -> GitHubResponse:
        """Create configuration for a just-in-time runner for an organization (HTTP POST /orgs/{org}/actions/runners/generate-jitconfig)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_generate_runner_jitconfig_for_org" in method_map:
                result = method_map["actions_generate_runner_jitconfig_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/generate-runner-jitconfig-for-org' (actions_generate_runner_jitconfig_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_generate_runner_jitconfig_for_repo(self, **kwargs) -> GitHubResponse:
        """Create configuration for a just-in-time runner for a repository (HTTP POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_generate_runner_jitconfig_for_repo" in method_map:
                result = method_map["actions_generate_runner_jitconfig_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/generate-runner-jitconfig-for-repo' (actions_generate_runner_jitconfig_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_actions_cache_list(self, **kwargs) -> GitHubResponse:
        """List GitHub Actions caches for a repository (HTTP GET /repos/{owner}/{repo}/actions/caches)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_actions_cache_list" in method_map:
                result = method_map["actions_get_actions_cache_list"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-actions-cache-list' (actions_get_actions_cache_list). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_actions_cache_usage(self, **kwargs) -> GitHubResponse:
        """Get GitHub Actions cache usage for a repository (HTTP GET /repos/{owner}/{repo}/actions/cache/usage)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_actions_cache_usage" in method_map:
                result = method_map["actions_get_actions_cache_usage"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-actions-cache-usage' (actions_get_actions_cache_usage). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_actions_cache_usage_by_repo_for_org(self, **kwargs) -> GitHubResponse:
        """List repositories with GitHub Actions cache usage for an organization (HTTP GET /orgs/{org}/actions/cache/usage-by-repository)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_actions_cache_usage_by_repo_for_org" in method_map:
                result = method_map["actions_get_actions_cache_usage_by_repo_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-actions-cache-usage-by-repo-for-org' (actions_get_actions_cache_usage_by_repo_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_actions_cache_usage_for_org(self, **kwargs) -> GitHubResponse:
        """Get GitHub Actions cache usage for an organization (HTTP GET /orgs/{org}/actions/cache/usage)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_actions_cache_usage_for_org" in method_map:
                result = method_map["actions_get_actions_cache_usage_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-actions-cache-usage-for-org' (actions_get_actions_cache_usage_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_allowed_actions_organization(self, **kwargs) -> GitHubResponse:
        """Get allowed actions and reusable workflows for an organization (HTTP GET /orgs/{org}/actions/permissions/selected-actions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_allowed_actions_organization" in method_map:
                result = method_map["actions_get_allowed_actions_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-allowed-actions-organization' (actions_get_allowed_actions_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_allowed_actions_repository(self, **kwargs) -> GitHubResponse:
        """Get allowed actions and reusable workflows for a repository (HTTP GET /repos/{owner}/{repo}/actions/permissions/selected-actions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_allowed_actions_repository" in method_map:
                result = method_map["actions_get_allowed_actions_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-allowed-actions-repository' (actions_get_allowed_actions_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_artifact(self, **kwargs) -> GitHubResponse:
        """Get an artifact (HTTP GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_artifact" in method_map:
                result = method_map["actions_get_artifact"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-artifact' (actions_get_artifact). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_artifact_and_log_retention_settings_organization(self, **kwargs) -> GitHubResponse:
        """Get artifact and log retention settings for an organization (HTTP GET /orgs/{org}/actions/permissions/artifact-and-log-retention)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_artifact_and_log_retention_settings_organization" in method_map:
                result = method_map["actions_get_artifact_and_log_retention_settings_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-artifact-and-log-retention-settings-organization' (actions_get_artifact_and_log_retention_settings_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_artifact_and_log_retention_settings_repository(self, **kwargs) -> GitHubResponse:
        """Get artifact and log retention settings for a repository (HTTP GET /repos/{owner}/{repo}/actions/permissions/artifact-and-log-retention)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_artifact_and_log_retention_settings_repository" in method_map:
                result = method_map["actions_get_artifact_and_log_retention_settings_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-artifact-and-log-retention-settings-repository' (actions_get_artifact_and_log_retention_settings_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_custom_oidc_sub_claim_for_repo(self, **kwargs) -> GitHubResponse:
        """Get the customization template for an OIDC subject claim for a repository (HTTP GET /repos/{owner}/{repo}/actions/oidc/customization/sub)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_custom_oidc_sub_claim_for_repo" in method_map:
                result = method_map["actions_get_custom_oidc_sub_claim_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-custom-oidc-sub-claim-for-repo' (actions_get_custom_oidc_sub_claim_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_environment_public_key(self, **kwargs) -> GitHubResponse:
        """Get an environment public key (HTTP GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_environment_public_key" in method_map:
                result = method_map["actions_get_environment_public_key"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-environment-public-key' (actions_get_environment_public_key). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_environment_secret(self, **kwargs) -> GitHubResponse:
        """Get an environment secret (HTTP GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_environment_secret" in method_map:
                result = method_map["actions_get_environment_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-environment-secret' (actions_get_environment_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_environment_variable(self, **kwargs) -> GitHubResponse:
        """Get an environment variable (HTTP GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_environment_variable" in method_map:
                result = method_map["actions_get_environment_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-environment-variable' (actions_get_environment_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_fork_pr_contributor_approval_permissions_organization(self, **kwargs) -> GitHubResponse:
        """Get fork PR contributor approval permissions for an organization (HTTP GET /orgs/{org}/actions/permissions/fork-pr-contributor-approval)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_fork_pr_contributor_approval_permissions_organization" in method_map:
                result = method_map["actions_get_fork_pr_contributor_approval_permissions_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-fork-pr-contributor-approval-permissions-organization' (actions_get_fork_pr_contributor_approval_permissions_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_fork_pr_contributor_approval_permissions_repository(self, **kwargs) -> GitHubResponse:
        """Get fork PR contributor approval permissions for a repository (HTTP GET /repos/{owner}/{repo}/actions/permissions/fork-pr-contributor-approval)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_fork_pr_contributor_approval_permissions_repository" in method_map:
                result = method_map["actions_get_fork_pr_contributor_approval_permissions_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-fork-pr-contributor-approval-permissions-repository' (actions_get_fork_pr_contributor_approval_permissions_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_github_actions_default_workflow_permissions_organization(self, **kwargs) -> GitHubResponse:
        """Get default workflow permissions for an organization (HTTP GET /orgs/{org}/actions/permissions/workflow)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_github_actions_default_workflow_permissions_organization" in method_map:
                result = method_map["actions_get_github_actions_default_workflow_permissions_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-github-actions-default-workflow-permissions-organization' (actions_get_github_actions_default_workflow_permissions_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_github_actions_default_workflow_permissions_repository(self, **kwargs) -> GitHubResponse:
        """Get default workflow permissions for a repository (HTTP GET /repos/{owner}/{repo}/actions/permissions/workflow)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_github_actions_default_workflow_permissions_repository" in method_map:
                result = method_map["actions_get_github_actions_default_workflow_permissions_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-github-actions-default-workflow-permissions-repository' (actions_get_github_actions_default_workflow_permissions_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_github_actions_permissions_organization(self, **kwargs) -> GitHubResponse:
        """Get GitHub Actions permissions for an organization (HTTP GET /orgs/{org}/actions/permissions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_github_actions_permissions_organization" in method_map:
                result = method_map["actions_get_github_actions_permissions_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-github-actions-permissions-organization' (actions_get_github_actions_permissions_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_github_actions_permissions_repository(self, **kwargs) -> GitHubResponse:
        """Get GitHub Actions permissions for a repository (HTTP GET /repos/{owner}/{repo}/actions/permissions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_github_actions_permissions_repository" in method_map:
                result = method_map["actions_get_github_actions_permissions_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-github-actions-permissions-repository' (actions_get_github_actions_permissions_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_hosted_runner_for_org(self, **kwargs) -> GitHubResponse:
        """Get a GitHub-hosted runner for an organization (HTTP GET /orgs/{org}/actions/hosted-runners/{hosted_runner_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_hosted_runner_for_org" in method_map:
                result = method_map["actions_get_hosted_runner_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-hosted-runner-for-org' (actions_get_hosted_runner_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_hosted_runners_github_owned_images_for_org(self, **kwargs) -> GitHubResponse:
        """Get GitHub-owned images for GitHub-hosted runners in an organization (HTTP GET /orgs/{org}/actions/hosted-runners/images/github-owned)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_hosted_runners_github_owned_images_for_org" in method_map:
                result = method_map["actions_get_hosted_runners_github_owned_images_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-hosted-runners-github-owned-images-for-org' (actions_get_hosted_runners_github_owned_images_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_hosted_runners_limits_for_org(self, **kwargs) -> GitHubResponse:
        """Get limits on GitHub-hosted runners for an organization (HTTP GET /orgs/{org}/actions/hosted-runners/limits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_hosted_runners_limits_for_org" in method_map:
                result = method_map["actions_get_hosted_runners_limits_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-hosted-runners-limits-for-org' (actions_get_hosted_runners_limits_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_hosted_runners_machine_specs_for_org(self, **kwargs) -> GitHubResponse:
        """Get GitHub-hosted runners machine specs for an organization (HTTP GET /orgs/{org}/actions/hosted-runners/machine-sizes)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_hosted_runners_machine_specs_for_org" in method_map:
                result = method_map["actions_get_hosted_runners_machine_specs_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-hosted-runners-machine-specs-for-org' (actions_get_hosted_runners_machine_specs_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_hosted_runners_partner_images_for_org(self, **kwargs) -> GitHubResponse:
        """Get partner images for GitHub-hosted runners in an organization (HTTP GET /orgs/{org}/actions/hosted-runners/images/partner)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_hosted_runners_partner_images_for_org" in method_map:
                result = method_map["actions_get_hosted_runners_partner_images_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-hosted-runners-partner-images-for-org' (actions_get_hosted_runners_partner_images_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_hosted_runners_platforms_for_org(self, **kwargs) -> GitHubResponse:
        """Get platforms for GitHub-hosted runners in an organization (HTTP GET /orgs/{org}/actions/hosted-runners/platforms)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_hosted_runners_platforms_for_org" in method_map:
                result = method_map["actions_get_hosted_runners_platforms_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-hosted-runners-platforms-for-org' (actions_get_hosted_runners_platforms_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_job_for_workflow_run(self, **kwargs) -> GitHubResponse:
        """Get a job for a workflow run (HTTP GET /repos/{owner}/{repo}/actions/jobs/{job_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_job_for_workflow_run" in method_map:
                result = method_map["actions_get_job_for_workflow_run"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-job-for-workflow-run' (actions_get_job_for_workflow_run). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_org_public_key(self, **kwargs) -> GitHubResponse:
        """Get an organization public key (HTTP GET /orgs/{org}/actions/secrets/public-key)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_org_public_key" in method_map:
                result = method_map["actions_get_org_public_key"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-org-public-key' (actions_get_org_public_key). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_org_secret(self, **kwargs) -> GitHubResponse:
        """Get an organization secret (HTTP GET /orgs/{org}/actions/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_org_secret" in method_map:
                result = method_map["actions_get_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-org-secret' (actions_get_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_org_variable(self, **kwargs) -> GitHubResponse:
        """Get an organization variable (HTTP GET /orgs/{org}/actions/variables/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_org_variable" in method_map:
                result = method_map["actions_get_org_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-org-variable' (actions_get_org_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_pending_deployments_for_run(self, **kwargs) -> GitHubResponse:
        """Get pending deployments for a workflow run (HTTP GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_pending_deployments_for_run" in method_map:
                result = method_map["actions_get_pending_deployments_for_run"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-pending-deployments-for-run' (actions_get_pending_deployments_for_run). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_private_repo_fork_pr_workflows_settings_organization(self, **kwargs) -> GitHubResponse:
        """Get private repo fork PR workflow settings for an organization (HTTP GET /orgs/{org}/actions/permissions/fork-pr-workflows-private-repos)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_private_repo_fork_pr_workflows_settings_organization" in method_map:
                result = method_map["actions_get_private_repo_fork_pr_workflows_settings_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-private-repo-fork-pr-workflows-settings-organization' (actions_get_private_repo_fork_pr_workflows_settings_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_private_repo_fork_pr_workflows_settings_repository(self, **kwargs) -> GitHubResponse:
        """Get private repo fork PR workflow settings for a repository (HTTP GET /repos/{owner}/{repo}/actions/permissions/fork-pr-workflows-private-repos)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_private_repo_fork_pr_workflows_settings_repository" in method_map:
                result = method_map["actions_get_private_repo_fork_pr_workflows_settings_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-private-repo-fork-pr-workflows-settings-repository' (actions_get_private_repo_fork_pr_workflows_settings_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_repo_public_key(self, **kwargs) -> GitHubResponse:
        """Get a repository public key (HTTP GET /repos/{owner}/{repo}/actions/secrets/public-key)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_repo_public_key" in method_map:
                result = method_map["actions_get_repo_public_key"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-repo-public-key' (actions_get_repo_public_key). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_repo_secret(self, **kwargs) -> GitHubResponse:
        """Get a repository secret (HTTP GET /repos/{owner}/{repo}/actions/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_repo_secret" in method_map:
                result = method_map["actions_get_repo_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-repo-secret' (actions_get_repo_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_repo_variable(self, **kwargs) -> GitHubResponse:
        """Get a repository variable (HTTP GET /repos/{owner}/{repo}/actions/variables/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_repo_variable" in method_map:
                result = method_map["actions_get_repo_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-repo-variable' (actions_get_repo_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_reviews_for_run(self, **kwargs) -> GitHubResponse:
        """Get the review history for a workflow run (HTTP GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_reviews_for_run" in method_map:
                result = method_map["actions_get_reviews_for_run"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-reviews-for-run' (actions_get_reviews_for_run). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_self_hosted_runner_for_org(self, **kwargs) -> GitHubResponse:
        """Get a self-hosted runner for an organization (HTTP GET /orgs/{org}/actions/runners/{runner_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_self_hosted_runner_for_org" in method_map:
                result = method_map["actions_get_self_hosted_runner_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-self-hosted-runner-for-org' (actions_get_self_hosted_runner_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_self_hosted_runner_for_repo(self, **kwargs) -> GitHubResponse:
        """Get a self-hosted runner for a repository (HTTP GET /repos/{owner}/{repo}/actions/runners/{runner_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_self_hosted_runner_for_repo" in method_map:
                result = method_map["actions_get_self_hosted_runner_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-self-hosted-runner-for-repo' (actions_get_self_hosted_runner_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_self_hosted_runner_group_for_org(self, **kwargs) -> GitHubResponse:
        """Get a self-hosted runner group for an organization (HTTP GET /orgs/{org}/actions/runner-groups/{runner_group_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_self_hosted_runner_group_for_org" in method_map:
                result = method_map["actions_get_self_hosted_runner_group_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-self-hosted-runner-group-for-org' (actions_get_self_hosted_runner_group_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_self_hosted_runners_permissions_organization(self, **kwargs) -> GitHubResponse:
        """Get self-hosted runners settings for an organization (HTTP GET /orgs/{org}/actions/permissions/self-hosted-runners)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_self_hosted_runners_permissions_organization" in method_map:
                result = method_map["actions_get_self_hosted_runners_permissions_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-self-hosted-runners-permissions-organization' (actions_get_self_hosted_runners_permissions_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_workflow(self, **kwargs) -> GitHubResponse:
        """Get a workflow (HTTP GET /repos/{owner}/{repo}/actions/workflows/{workflow_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_workflow" in method_map:
                result = method_map["actions_get_workflow"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-workflow' (actions_get_workflow). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_workflow_access_to_repository(self, **kwargs) -> GitHubResponse:
        """Get the level of access for workflows outside of the repository (HTTP GET /repos/{owner}/{repo}/actions/permissions/access)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_workflow_access_to_repository" in method_map:
                result = method_map["actions_get_workflow_access_to_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-workflow-access-to-repository' (actions_get_workflow_access_to_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_workflow_run(self, **kwargs) -> GitHubResponse:
        """Get a workflow run (HTTP GET /repos/{owner}/{repo}/actions/runs/{run_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_workflow_run" in method_map:
                result = method_map["actions_get_workflow_run"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-workflow-run' (actions_get_workflow_run). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_workflow_run_attempt(self, **kwargs) -> GitHubResponse:
        """Get a workflow run attempt (HTTP GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_workflow_run_attempt" in method_map:
                result = method_map["actions_get_workflow_run_attempt"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-workflow-run-attempt' (actions_get_workflow_run_attempt). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_workflow_run_usage(self, **kwargs) -> GitHubResponse:
        """Get workflow run usage (HTTP GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_workflow_run_usage" in method_map:
                result = method_map["actions_get_workflow_run_usage"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-workflow-run-usage' (actions_get_workflow_run_usage). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_get_workflow_usage(self, **kwargs) -> GitHubResponse:
        """Get workflow usage (HTTP GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_get_workflow_usage" in method_map:
                result = method_map["actions_get_workflow_usage"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/get-workflow-usage' (actions_get_workflow_usage). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_artifacts_for_repo(self, **kwargs) -> GitHubResponse:
        """List artifacts for a repository (HTTP GET /repos/{owner}/{repo}/actions/artifacts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_artifacts_for_repo" in method_map:
                result = method_map["actions_list_artifacts_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-artifacts-for-repo' (actions_list_artifacts_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_environment_secrets(self, **kwargs) -> GitHubResponse:
        """List environment secrets (HTTP GET /repos/{owner}/{repo}/environments/{environment_name}/secrets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_environment_secrets" in method_map:
                result = method_map["actions_list_environment_secrets"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-environment-secrets' (actions_list_environment_secrets). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_environment_variables(self, **kwargs) -> GitHubResponse:
        """List environment variables (HTTP GET /repos/{owner}/{repo}/environments/{environment_name}/variables)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_environment_variables" in method_map:
                result = method_map["actions_list_environment_variables"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-environment-variables' (actions_list_environment_variables). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_github_hosted_runners_in_group_for_org(self, **kwargs) -> GitHubResponse:
        """List GitHub-hosted runners in a group for an organization (HTTP GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_github_hosted_runners_in_group_for_org" in method_map:
                result = method_map["actions_list_github_hosted_runners_in_group_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-github-hosted-runners-in-group-for-org' (actions_list_github_hosted_runners_in_group_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_hosted_runners_for_org(self, **kwargs) -> GitHubResponse:
        """List GitHub-hosted runners for an organization (HTTP GET /orgs/{org}/actions/hosted-runners)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_hosted_runners_for_org" in method_map:
                result = method_map["actions_list_hosted_runners_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-hosted-runners-for-org' (actions_list_hosted_runners_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_jobs_for_workflow_run(self, **kwargs) -> GitHubResponse:
        """List jobs for a workflow run (HTTP GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_jobs_for_workflow_run" in method_map:
                result = method_map["actions_list_jobs_for_workflow_run"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-jobs-for-workflow-run' (actions_list_jobs_for_workflow_run). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_jobs_for_workflow_run_attempt(self, **kwargs) -> GitHubResponse:
        """List jobs for a workflow run attempt (HTTP GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_jobs_for_workflow_run_attempt" in method_map:
                result = method_map["actions_list_jobs_for_workflow_run_attempt"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-jobs-for-workflow-run-attempt' (actions_list_jobs_for_workflow_run_attempt). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_labels_for_self_hosted_runner_for_org(self, **kwargs) -> GitHubResponse:
        """List labels for a self-hosted runner for an organization (HTTP GET /orgs/{org}/actions/runners/{runner_id}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_labels_for_self_hosted_runner_for_org" in method_map:
                result = method_map["actions_list_labels_for_self_hosted_runner_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-labels-for-self-hosted-runner-for-org' (actions_list_labels_for_self_hosted_runner_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_labels_for_self_hosted_runner_for_repo(self, **kwargs) -> GitHubResponse:
        """List labels for a self-hosted runner for a repository (HTTP GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_labels_for_self_hosted_runner_for_repo" in method_map:
                result = method_map["actions_list_labels_for_self_hosted_runner_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-labels-for-self-hosted-runner-for-repo' (actions_list_labels_for_self_hosted_runner_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_org_secrets(self, **kwargs) -> GitHubResponse:
        """List organization secrets (HTTP GET /orgs/{org}/actions/secrets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_org_secrets" in method_map:
                result = method_map["actions_list_org_secrets"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-org-secrets' (actions_list_org_secrets). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_org_variables(self, **kwargs) -> GitHubResponse:
        """List organization variables (HTTP GET /orgs/{org}/actions/variables)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_org_variables" in method_map:
                result = method_map["actions_list_org_variables"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-org-variables' (actions_list_org_variables). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_repo_access_to_self_hosted_runner_group_in_org(self, **kwargs) -> GitHubResponse:
        """List repository access to a self-hosted runner group in an organization (HTTP GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_repo_access_to_self_hosted_runner_group_in_org" in method_map:
                result = method_map["actions_list_repo_access_to_self_hosted_runner_group_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-repo-access-to-self-hosted-runner-group-in-org' (actions_list_repo_access_to_self_hosted_runner_group_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_repo_organization_secrets(self, **kwargs) -> GitHubResponse:
        """List repository organization secrets (HTTP GET /repos/{owner}/{repo}/actions/organization-secrets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_repo_organization_secrets" in method_map:
                result = method_map["actions_list_repo_organization_secrets"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-repo-organization-secrets' (actions_list_repo_organization_secrets). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_repo_organization_variables(self, **kwargs) -> GitHubResponse:
        """List repository organization variables (HTTP GET /repos/{owner}/{repo}/actions/organization-variables)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_repo_organization_variables" in method_map:
                result = method_map["actions_list_repo_organization_variables"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-repo-organization-variables' (actions_list_repo_organization_variables). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_repo_secrets(self, **kwargs) -> GitHubResponse:
        """List repository secrets (HTTP GET /repos/{owner}/{repo}/actions/secrets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_repo_secrets" in method_map:
                result = method_map["actions_list_repo_secrets"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-repo-secrets' (actions_list_repo_secrets). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_repo_variables(self, **kwargs) -> GitHubResponse:
        """List repository variables (HTTP GET /repos/{owner}/{repo}/actions/variables)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_repo_variables" in method_map:
                result = method_map["actions_list_repo_variables"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-repo-variables' (actions_list_repo_variables). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_repo_workflows(self, **kwargs) -> GitHubResponse:
        """List repository workflows (HTTP GET /repos/{owner}/{repo}/actions/workflows)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_repo_workflows" in method_map:
                result = method_map["actions_list_repo_workflows"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-repo-workflows' (actions_list_repo_workflows). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_runner_applications_for_org(self, **kwargs) -> GitHubResponse:
        """List runner applications for an organization (HTTP GET /orgs/{org}/actions/runners/downloads)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_runner_applications_for_org" in method_map:
                result = method_map["actions_list_runner_applications_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-runner-applications-for-org' (actions_list_runner_applications_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_runner_applications_for_repo(self, **kwargs) -> GitHubResponse:
        """List runner applications for a repository (HTTP GET /repos/{owner}/{repo}/actions/runners/downloads)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_runner_applications_for_repo" in method_map:
                result = method_map["actions_list_runner_applications_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-runner-applications-for-repo' (actions_list_runner_applications_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_selected_repos_for_org_secret(self, **kwargs) -> GitHubResponse:
        """List selected repositories for an organization secret (HTTP GET /orgs/{org}/actions/secrets/{secret_name}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_selected_repos_for_org_secret" in method_map:
                result = method_map["actions_list_selected_repos_for_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-selected-repos-for-org-secret' (actions_list_selected_repos_for_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_selected_repos_for_org_variable(self, **kwargs) -> GitHubResponse:
        """List selected repositories for an organization variable (HTTP GET /orgs/{org}/actions/variables/{name}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_selected_repos_for_org_variable" in method_map:
                result = method_map["actions_list_selected_repos_for_org_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-selected-repos-for-org-variable' (actions_list_selected_repos_for_org_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_selected_repositories_enabled_github_actions_organization(self, **kwargs) -> GitHubResponse:
        """List selected repositories enabled for GitHub Actions in an organization (HTTP GET /orgs/{org}/actions/permissions/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_selected_repositories_enabled_github_actions_organization" in method_map:
                result = method_map["actions_list_selected_repositories_enabled_github_actions_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-selected-repositories-enabled-github-actions-organization' (actions_list_selected_repositories_enabled_github_actions_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_selected_repositories_self_hosted_runners_organization(self, **kwargs) -> GitHubResponse:
        """List repositories allowed to use self-hosted runners in an organization (HTTP GET /orgs/{org}/actions/permissions/self-hosted-runners/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_selected_repositories_self_hosted_runners_organization" in method_map:
                result = method_map["actions_list_selected_repositories_self_hosted_runners_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-selected-repositories-self-hosted-runners-organization' (actions_list_selected_repositories_self_hosted_runners_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_self_hosted_runner_groups_for_org(self, **kwargs) -> GitHubResponse:
        """List self-hosted runner groups for an organization (HTTP GET /orgs/{org}/actions/runner-groups)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_self_hosted_runner_groups_for_org" in method_map:
                result = method_map["actions_list_self_hosted_runner_groups_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-self-hosted-runner-groups-for-org' (actions_list_self_hosted_runner_groups_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_self_hosted_runners_for_org(self, **kwargs) -> GitHubResponse:
        """List self-hosted runners for an organization (HTTP GET /orgs/{org}/actions/runners)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_self_hosted_runners_for_org" in method_map:
                result = method_map["actions_list_self_hosted_runners_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-self-hosted-runners-for-org' (actions_list_self_hosted_runners_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_self_hosted_runners_for_repo(self, **kwargs) -> GitHubResponse:
        """List self-hosted runners for a repository (HTTP GET /repos/{owner}/{repo}/actions/runners)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_self_hosted_runners_for_repo" in method_map:
                result = method_map["actions_list_self_hosted_runners_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-self-hosted-runners-for-repo' (actions_list_self_hosted_runners_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_self_hosted_runners_in_group_for_org(self, **kwargs) -> GitHubResponse:
        """List self-hosted runners in a group for an organization (HTTP GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_self_hosted_runners_in_group_for_org" in method_map:
                result = method_map["actions_list_self_hosted_runners_in_group_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-self-hosted-runners-in-group-for-org' (actions_list_self_hosted_runners_in_group_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_workflow_run_artifacts(self, **kwargs) -> GitHubResponse:
        """List workflow run artifacts (HTTP GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_workflow_run_artifacts" in method_map:
                result = method_map["actions_list_workflow_run_artifacts"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-workflow-run-artifacts' (actions_list_workflow_run_artifacts). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_workflow_runs(self, **kwargs) -> GitHubResponse:
        """List workflow runs for a workflow (HTTP GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_workflow_runs" in method_map:
                result = method_map["actions_list_workflow_runs"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-workflow-runs' (actions_list_workflow_runs). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_list_workflow_runs_for_repo(self, **kwargs) -> GitHubResponse:
        """List workflow runs for a repository (HTTP GET /repos/{owner}/{repo}/actions/runs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_list_workflow_runs_for_repo" in method_map:
                result = method_map["actions_list_workflow_runs_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/list-workflow-runs-for-repo' (actions_list_workflow_runs_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_re_run_job_for_workflow_run(self, **kwargs) -> GitHubResponse:
        """Re-run a job from a workflow run (HTTP POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_re_run_job_for_workflow_run" in method_map:
                result = method_map["actions_re_run_job_for_workflow_run"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/re-run-job-for-workflow-run' (actions_re_run_job_for_workflow_run). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_re_run_workflow(self, **kwargs) -> GitHubResponse:
        """Re-run a workflow (HTTP POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_re_run_workflow" in method_map:
                result = method_map["actions_re_run_workflow"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/re-run-workflow' (actions_re_run_workflow). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_re_run_workflow_failed_jobs(self, **kwargs) -> GitHubResponse:
        """Re-run failed jobs from a workflow run (HTTP POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_re_run_workflow_failed_jobs" in method_map:
                result = method_map["actions_re_run_workflow_failed_jobs"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/re-run-workflow-failed-jobs' (actions_re_run_workflow_failed_jobs). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_remove_all_custom_labels_from_self_hosted_runner_for_org(self, **kwargs) -> GitHubResponse:
        """Remove all custom labels from a self-hosted runner for an organization (HTTP DELETE /orgs/{org}/actions/runners/{runner_id}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_remove_all_custom_labels_from_self_hosted_runner_for_org" in method_map:
                result = method_map["actions_remove_all_custom_labels_from_self_hosted_runner_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/remove-all-custom-labels-from-self-hosted-runner-for-org' (actions_remove_all_custom_labels_from_self_hosted_runner_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_remove_all_custom_labels_from_self_hosted_runner_for_repo(self, **kwargs) -> GitHubResponse:
        """Remove all custom labels from a self-hosted runner for a repository (HTTP DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_remove_all_custom_labels_from_self_hosted_runner_for_repo" in method_map:
                result = method_map["actions_remove_all_custom_labels_from_self_hosted_runner_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/remove-all-custom-labels-from-self-hosted-runner-for-repo' (actions_remove_all_custom_labels_from_self_hosted_runner_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_remove_custom_label_from_self_hosted_runner_for_org(self, **kwargs) -> GitHubResponse:
        """Remove a custom label from a self-hosted runner for an organization (HTTP DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_remove_custom_label_from_self_hosted_runner_for_org" in method_map:
                result = method_map["actions_remove_custom_label_from_self_hosted_runner_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/remove-custom-label-from-self-hosted-runner-for-org' (actions_remove_custom_label_from_self_hosted_runner_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_remove_custom_label_from_self_hosted_runner_for_repo(self, **kwargs) -> GitHubResponse:
        """Remove a custom label from a self-hosted runner for a repository (HTTP DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_remove_custom_label_from_self_hosted_runner_for_repo" in method_map:
                result = method_map["actions_remove_custom_label_from_self_hosted_runner_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/remove-custom-label-from-self-hosted-runner-for-repo' (actions_remove_custom_label_from_self_hosted_runner_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_remove_repo_access_to_self_hosted_runner_group_in_org(self, **kwargs) -> GitHubResponse:
        """Remove repository access to a self-hosted runner group in an organization (HTTP DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_remove_repo_access_to_self_hosted_runner_group_in_org" in method_map:
                result = method_map["actions_remove_repo_access_to_self_hosted_runner_group_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/remove-repo-access-to-self-hosted-runner-group-in-org' (actions_remove_repo_access_to_self_hosted_runner_group_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_remove_selected_repo_from_org_secret(self, **kwargs) -> GitHubResponse:
        """Remove selected repository from an organization secret (HTTP DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_remove_selected_repo_from_org_secret" in method_map:
                result = method_map["actions_remove_selected_repo_from_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/remove-selected-repo-from-org-secret' (actions_remove_selected_repo_from_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_remove_selected_repo_from_org_variable(self, **kwargs) -> GitHubResponse:
        """Remove selected repository from an organization variable (HTTP DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_remove_selected_repo_from_org_variable" in method_map:
                result = method_map["actions_remove_selected_repo_from_org_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/remove-selected-repo-from-org-variable' (actions_remove_selected_repo_from_org_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_remove_self_hosted_runner_from_group_for_org(self, **kwargs) -> GitHubResponse:
        """Remove a self-hosted runner from a group for an organization (HTTP DELETE /orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_remove_self_hosted_runner_from_group_for_org" in method_map:
                result = method_map["actions_remove_self_hosted_runner_from_group_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/remove-self-hosted-runner-from-group-for-org' (actions_remove_self_hosted_runner_from_group_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_review_custom_gates_for_run(self, **kwargs) -> GitHubResponse:
        """Review custom deployment protection rules for a workflow run (HTTP POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_review_custom_gates_for_run" in method_map:
                result = method_map["actions_review_custom_gates_for_run"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/review-custom-gates-for-run' (actions_review_custom_gates_for_run). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_review_pending_deployments_for_run(self, **kwargs) -> GitHubResponse:
        """Review pending deployments for a workflow run (HTTP POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_review_pending_deployments_for_run" in method_map:
                result = method_map["actions_review_pending_deployments_for_run"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/review-pending-deployments-for-run' (actions_review_pending_deployments_for_run). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_allowed_actions_organization(self, **kwargs) -> GitHubResponse:
        """Set allowed actions and reusable workflows for an organization (HTTP PUT /orgs/{org}/actions/permissions/selected-actions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_allowed_actions_organization" in method_map:
                result = method_map["actions_set_allowed_actions_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-allowed-actions-organization' (actions_set_allowed_actions_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_allowed_actions_repository(self, **kwargs) -> GitHubResponse:
        """Set allowed actions and reusable workflows for a repository (HTTP PUT /repos/{owner}/{repo}/actions/permissions/selected-actions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_allowed_actions_repository" in method_map:
                result = method_map["actions_set_allowed_actions_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-allowed-actions-repository' (actions_set_allowed_actions_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_artifact_and_log_retention_settings_organization(self, **kwargs) -> GitHubResponse:
        """Set artifact and log retention settings for an organization (HTTP PUT /orgs/{org}/actions/permissions/artifact-and-log-retention)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_artifact_and_log_retention_settings_organization" in method_map:
                result = method_map["actions_set_artifact_and_log_retention_settings_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-artifact-and-log-retention-settings-organization' (actions_set_artifact_and_log_retention_settings_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_artifact_and_log_retention_settings_repository(self, **kwargs) -> GitHubResponse:
        """Set artifact and log retention settings for a repository (HTTP PUT /repos/{owner}/{repo}/actions/permissions/artifact-and-log-retention)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_artifact_and_log_retention_settings_repository" in method_map:
                result = method_map["actions_set_artifact_and_log_retention_settings_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-artifact-and-log-retention-settings-repository' (actions_set_artifact_and_log_retention_settings_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_custom_labels_for_self_hosted_runner_for_org(self, **kwargs) -> GitHubResponse:
        """Set custom labels for a self-hosted runner for an organization (HTTP PUT /orgs/{org}/actions/runners/{runner_id}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_custom_labels_for_self_hosted_runner_for_org" in method_map:
                result = method_map["actions_set_custom_labels_for_self_hosted_runner_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-custom-labels-for-self-hosted-runner-for-org' (actions_set_custom_labels_for_self_hosted_runner_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_custom_labels_for_self_hosted_runner_for_repo(self, **kwargs) -> GitHubResponse:
        """Set custom labels for a self-hosted runner for a repository (HTTP PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_custom_labels_for_self_hosted_runner_for_repo" in method_map:
                result = method_map["actions_set_custom_labels_for_self_hosted_runner_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-custom-labels-for-self-hosted-runner-for-repo' (actions_set_custom_labels_for_self_hosted_runner_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_custom_oidc_sub_claim_for_repo(self, **kwargs) -> GitHubResponse:
        """Set the customization template for an OIDC subject claim for a repository (HTTP PUT /repos/{owner}/{repo}/actions/oidc/customization/sub)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_custom_oidc_sub_claim_for_repo" in method_map:
                result = method_map["actions_set_custom_oidc_sub_claim_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-custom-oidc-sub-claim-for-repo' (actions_set_custom_oidc_sub_claim_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_fork_pr_contributor_approval_permissions_organization(self, **kwargs) -> GitHubResponse:
        """Set fork PR contributor approval permissions for an organization (HTTP PUT /orgs/{org}/actions/permissions/fork-pr-contributor-approval)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_fork_pr_contributor_approval_permissions_organization" in method_map:
                result = method_map["actions_set_fork_pr_contributor_approval_permissions_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-fork-pr-contributor-approval-permissions-organization' (actions_set_fork_pr_contributor_approval_permissions_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_fork_pr_contributor_approval_permissions_repository(self, **kwargs) -> GitHubResponse:
        """Set fork PR contributor approval permissions for a repository (HTTP PUT /repos/{owner}/{repo}/actions/permissions/fork-pr-contributor-approval)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_fork_pr_contributor_approval_permissions_repository" in method_map:
                result = method_map["actions_set_fork_pr_contributor_approval_permissions_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-fork-pr-contributor-approval-permissions-repository' (actions_set_fork_pr_contributor_approval_permissions_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_github_actions_default_workflow_permissions_organization(self, **kwargs) -> GitHubResponse:
        """Set default workflow permissions for an organization (HTTP PUT /orgs/{org}/actions/permissions/workflow)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_github_actions_default_workflow_permissions_organization" in method_map:
                result = method_map["actions_set_github_actions_default_workflow_permissions_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-github-actions-default-workflow-permissions-organization' (actions_set_github_actions_default_workflow_permissions_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_github_actions_default_workflow_permissions_repository(self, **kwargs) -> GitHubResponse:
        """Set default workflow permissions for a repository (HTTP PUT /repos/{owner}/{repo}/actions/permissions/workflow)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_github_actions_default_workflow_permissions_repository" in method_map:
                result = method_map["actions_set_github_actions_default_workflow_permissions_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-github-actions-default-workflow-permissions-repository' (actions_set_github_actions_default_workflow_permissions_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_github_actions_permissions_organization(self, **kwargs) -> GitHubResponse:
        """Set GitHub Actions permissions for an organization (HTTP PUT /orgs/{org}/actions/permissions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_github_actions_permissions_organization" in method_map:
                result = method_map["actions_set_github_actions_permissions_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-github-actions-permissions-organization' (actions_set_github_actions_permissions_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_github_actions_permissions_repository(self, **kwargs) -> GitHubResponse:
        """Set GitHub Actions permissions for a repository (HTTP PUT /repos/{owner}/{repo}/actions/permissions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_github_actions_permissions_repository" in method_map:
                result = method_map["actions_set_github_actions_permissions_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-github-actions-permissions-repository' (actions_set_github_actions_permissions_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_private_repo_fork_pr_workflows_settings_organization(self, **kwargs) -> GitHubResponse:
        """Set private repo fork PR workflow settings for an organization (HTTP PUT /orgs/{org}/actions/permissions/fork-pr-workflows-private-repos)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_private_repo_fork_pr_workflows_settings_organization" in method_map:
                result = method_map["actions_set_private_repo_fork_pr_workflows_settings_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-private-repo-fork-pr-workflows-settings-organization' (actions_set_private_repo_fork_pr_workflows_settings_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_private_repo_fork_pr_workflows_settings_repository(self, **kwargs) -> GitHubResponse:
        """Set private repo fork PR workflow settings for a repository (HTTP PUT /repos/{owner}/{repo}/actions/permissions/fork-pr-workflows-private-repos)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_private_repo_fork_pr_workflows_settings_repository" in method_map:
                result = method_map["actions_set_private_repo_fork_pr_workflows_settings_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-private-repo-fork-pr-workflows-settings-repository' (actions_set_private_repo_fork_pr_workflows_settings_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_repo_access_to_self_hosted_runner_group_in_org(self, **kwargs) -> GitHubResponse:
        """Set repository access for a self-hosted runner group in an organization (HTTP PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_repo_access_to_self_hosted_runner_group_in_org" in method_map:
                result = method_map["actions_set_repo_access_to_self_hosted_runner_group_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-repo-access-to-self-hosted-runner-group-in-org' (actions_set_repo_access_to_self_hosted_runner_group_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_selected_repos_for_org_secret(self, **kwargs) -> GitHubResponse:
        """Set selected repositories for an organization secret (HTTP PUT /orgs/{org}/actions/secrets/{secret_name}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_selected_repos_for_org_secret" in method_map:
                result = method_map["actions_set_selected_repos_for_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-selected-repos-for-org-secret' (actions_set_selected_repos_for_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_selected_repos_for_org_variable(self, **kwargs) -> GitHubResponse:
        """Set selected repositories for an organization variable (HTTP PUT /orgs/{org}/actions/variables/{name}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_selected_repos_for_org_variable" in method_map:
                result = method_map["actions_set_selected_repos_for_org_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-selected-repos-for-org-variable' (actions_set_selected_repos_for_org_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_selected_repositories_enabled_github_actions_organization(self, **kwargs) -> GitHubResponse:
        """Set selected repositories enabled for GitHub Actions in an organization (HTTP PUT /orgs/{org}/actions/permissions/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_selected_repositories_enabled_github_actions_organization" in method_map:
                result = method_map["actions_set_selected_repositories_enabled_github_actions_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-selected-repositories-enabled-github-actions-organization' (actions_set_selected_repositories_enabled_github_actions_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_selected_repositories_self_hosted_runners_organization(self, **kwargs) -> GitHubResponse:
        """Set repositories allowed to use self-hosted runners in an organization (HTTP PUT /orgs/{org}/actions/permissions/self-hosted-runners/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_selected_repositories_self_hosted_runners_organization" in method_map:
                result = method_map["actions_set_selected_repositories_self_hosted_runners_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-selected-repositories-self-hosted-runners-organization' (actions_set_selected_repositories_self_hosted_runners_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_self_hosted_runners_in_group_for_org(self, **kwargs) -> GitHubResponse:
        """Set self-hosted runners in a group for an organization (HTTP PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/runners)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_self_hosted_runners_in_group_for_org" in method_map:
                result = method_map["actions_set_self_hosted_runners_in_group_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-self-hosted-runners-in-group-for-org' (actions_set_self_hosted_runners_in_group_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_self_hosted_runners_permissions_organization(self, **kwargs) -> GitHubResponse:
        """Set self-hosted runners settings for an organization (HTTP PUT /orgs/{org}/actions/permissions/self-hosted-runners)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_self_hosted_runners_permissions_organization" in method_map:
                result = method_map["actions_set_self_hosted_runners_permissions_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-self-hosted-runners-permissions-organization' (actions_set_self_hosted_runners_permissions_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_set_workflow_access_to_repository(self, **kwargs) -> GitHubResponse:
        """Set the level of access for workflows outside of the repository (HTTP PUT /repos/{owner}/{repo}/actions/permissions/access)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_set_workflow_access_to_repository" in method_map:
                result = method_map["actions_set_workflow_access_to_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/set-workflow-access-to-repository' (actions_set_workflow_access_to_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_update_environment_variable(self, **kwargs) -> GitHubResponse:
        """Update an environment variable (HTTP PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_update_environment_variable" in method_map:
                result = method_map["actions_update_environment_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/update-environment-variable' (actions_update_environment_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_update_hosted_runner_for_org(self, **kwargs) -> GitHubResponse:
        """Update a GitHub-hosted runner for an organization (HTTP PATCH /orgs/{org}/actions/hosted-runners/{hosted_runner_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_update_hosted_runner_for_org" in method_map:
                result = method_map["actions_update_hosted_runner_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/update-hosted-runner-for-org' (actions_update_hosted_runner_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_update_org_variable(self, **kwargs) -> GitHubResponse:
        """Update an organization variable (HTTP PATCH /orgs/{org}/actions/variables/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_update_org_variable" in method_map:
                result = method_map["actions_update_org_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/update-org-variable' (actions_update_org_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_update_repo_variable(self, **kwargs) -> GitHubResponse:
        """Update a repository variable (HTTP PATCH /repos/{owner}/{repo}/actions/variables/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_update_repo_variable" in method_map:
                result = method_map["actions_update_repo_variable"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/update-repo-variable' (actions_update_repo_variable). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def actions_update_self_hosted_runner_group_for_org(self, **kwargs) -> GitHubResponse:
        """Update a self-hosted runner group for an organization (HTTP PATCH /orgs/{org}/actions/runner-groups/{runner_group_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "actions_update_self_hosted_runner_group_for_org" in method_map:
                result = method_map["actions_update_self_hosted_runner_group_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'actions/update-self-hosted-runner-group-for-org' (actions_update_self_hosted_runner_group_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_check_repo_is_starred_by_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Check if a repository is starred by the authenticated user (HTTP GET /user/starred/{owner}/{repo})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_check_repo_is_starred_by_authenticated_user" in method_map:
                result = method_map["activity_check_repo_is_starred_by_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/check-repo-is-starred-by-authenticated-user' (activity_check_repo_is_starred_by_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_delete_repo_subscription(self, **kwargs) -> GitHubResponse:
        """Delete a repository subscription (HTTP DELETE /repos/{owner}/{repo}/subscription)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_delete_repo_subscription" in method_map:
                result = method_map["activity_delete_repo_subscription"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/delete-repo-subscription' (activity_delete_repo_subscription). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_delete_thread_subscription(self, **kwargs) -> GitHubResponse:
        """Delete a thread subscription (HTTP DELETE /notifications/threads/{thread_id}/subscription)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_delete_thread_subscription" in method_map:
                result = method_map["activity_delete_thread_subscription"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/delete-thread-subscription' (activity_delete_thread_subscription). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_get_feeds(self, **kwargs) -> GitHubResponse:
        """Get feeds (HTTP GET /feeds)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_get_feeds" in method_map:
                result = method_map["activity_get_feeds"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/get-feeds' (activity_get_feeds). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_get_repo_subscription(self, **kwargs) -> GitHubResponse:
        """Get a repository subscription (HTTP GET /repos/{owner}/{repo}/subscription)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_get_repo_subscription" in method_map:
                result = method_map["activity_get_repo_subscription"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/get-repo-subscription' (activity_get_repo_subscription). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_get_thread(self, **kwargs) -> GitHubResponse:
        """Get a thread (HTTP GET /notifications/threads/{thread_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_get_thread" in method_map:
                result = method_map["activity_get_thread"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/get-thread' (activity_get_thread). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_get_thread_subscription_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get a thread subscription for the authenticated user (HTTP GET /notifications/threads/{thread_id}/subscription)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_get_thread_subscription_for_authenticated_user" in method_map:
                result = method_map["activity_get_thread_subscription_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/get-thread-subscription-for-authenticated-user' (activity_get_thread_subscription_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_events_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List events for the authenticated user (HTTP GET /users/{username}/events)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_events_for_authenticated_user" in method_map:
                result = method_map["activity_list_events_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-events-for-authenticated-user' (activity_list_events_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_notifications_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List notifications for the authenticated user (HTTP GET /notifications)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_notifications_for_authenticated_user" in method_map:
                result = method_map["activity_list_notifications_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-notifications-for-authenticated-user' (activity_list_notifications_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_org_events_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List organization events for the authenticated user (HTTP GET /users/{username}/events/orgs/{org})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_org_events_for_authenticated_user" in method_map:
                result = method_map["activity_list_org_events_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-org-events-for-authenticated-user' (activity_list_org_events_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_public_events(self, **kwargs) -> GitHubResponse:
        """List public events (HTTP GET /events)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_public_events" in method_map:
                result = method_map["activity_list_public_events"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-public-events' (activity_list_public_events). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_public_events_for_repo_network(self, **kwargs) -> GitHubResponse:
        """List public events for a network of repositories (HTTP GET /networks/{owner}/{repo}/events)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_public_events_for_repo_network" in method_map:
                result = method_map["activity_list_public_events_for_repo_network"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-public-events-for-repo-network' (activity_list_public_events_for_repo_network). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_public_events_for_user(self, **kwargs) -> GitHubResponse:
        """List public events for a user (HTTP GET /users/{username}/events/public)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_public_events_for_user" in method_map:
                result = method_map["activity_list_public_events_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-public-events-for-user' (activity_list_public_events_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_public_org_events(self, **kwargs) -> GitHubResponse:
        """List public organization events (HTTP GET /orgs/{org}/events)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_public_org_events" in method_map:
                result = method_map["activity_list_public_org_events"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-public-org-events' (activity_list_public_org_events). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_received_events_for_user(self, **kwargs) -> GitHubResponse:
        """List events received by the authenticated user (HTTP GET /users/{username}/received_events)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_received_events_for_user" in method_map:
                result = method_map["activity_list_received_events_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-received-events-for-user' (activity_list_received_events_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_received_public_events_for_user(self, **kwargs) -> GitHubResponse:
        """List public events received by a user (HTTP GET /users/{username}/received_events/public)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_received_public_events_for_user" in method_map:
                result = method_map["activity_list_received_public_events_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-received-public-events-for-user' (activity_list_received_public_events_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_repo_events(self, **kwargs) -> GitHubResponse:
        """List repository events (HTTP GET /repos/{owner}/{repo}/events)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_repo_events" in method_map:
                result = method_map["activity_list_repo_events"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-repo-events' (activity_list_repo_events). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_repo_notifications_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List repository notifications for the authenticated user (HTTP GET /repos/{owner}/{repo}/notifications)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_repo_notifications_for_authenticated_user" in method_map:
                result = method_map["activity_list_repo_notifications_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-repo-notifications-for-authenticated-user' (activity_list_repo_notifications_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_repos_starred_by_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List repositories starred by the authenticated user (HTTP GET /user/starred)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_repos_starred_by_authenticated_user" in method_map:
                result = method_map["activity_list_repos_starred_by_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-repos-starred-by-authenticated-user' (activity_list_repos_starred_by_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_repos_starred_by_user(self, **kwargs) -> GitHubResponse:
        """List repositories starred by a user (HTTP GET /users/{username}/starred)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_repos_starred_by_user" in method_map:
                result = method_map["activity_list_repos_starred_by_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-repos-starred-by-user' (activity_list_repos_starred_by_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_repos_watched_by_user(self, **kwargs) -> GitHubResponse:
        """List repositories watched by a user (HTTP GET /users/{username}/subscriptions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_repos_watched_by_user" in method_map:
                result = method_map["activity_list_repos_watched_by_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-repos-watched-by-user' (activity_list_repos_watched_by_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_stargazers_for_repo(self, **kwargs) -> GitHubResponse:
        """List stargazers (HTTP GET /repos/{owner}/{repo}/stargazers)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_stargazers_for_repo" in method_map:
                result = method_map["activity_list_stargazers_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-stargazers-for-repo' (activity_list_stargazers_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_watched_repos_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List repositories watched by the authenticated user (HTTP GET /user/subscriptions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_watched_repos_for_authenticated_user" in method_map:
                result = method_map["activity_list_watched_repos_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-watched-repos-for-authenticated-user' (activity_list_watched_repos_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_list_watchers_for_repo(self, **kwargs) -> GitHubResponse:
        """List watchers (HTTP GET /repos/{owner}/{repo}/subscribers)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_list_watchers_for_repo" in method_map:
                result = method_map["activity_list_watchers_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/list-watchers-for-repo' (activity_list_watchers_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_mark_notifications_as_read(self, **kwargs) -> GitHubResponse:
        """Mark notifications as read (HTTP PUT /notifications)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_mark_notifications_as_read" in method_map:
                result = method_map["activity_mark_notifications_as_read"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/mark-notifications-as-read' (activity_mark_notifications_as_read). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_mark_repo_notifications_as_read(self, **kwargs) -> GitHubResponse:
        """Mark repository notifications as read (HTTP PUT /repos/{owner}/{repo}/notifications)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_mark_repo_notifications_as_read" in method_map:
                result = method_map["activity_mark_repo_notifications_as_read"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/mark-repo-notifications-as-read' (activity_mark_repo_notifications_as_read). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_mark_thread_as_done(self, **kwargs) -> GitHubResponse:
        """Mark a thread as done (HTTP DELETE /notifications/threads/{thread_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_mark_thread_as_done" in method_map:
                result = method_map["activity_mark_thread_as_done"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/mark-thread-as-done' (activity_mark_thread_as_done). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_mark_thread_as_read(self, **kwargs) -> GitHubResponse:
        """Mark a thread as read (HTTP PATCH /notifications/threads/{thread_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_mark_thread_as_read" in method_map:
                result = method_map["activity_mark_thread_as_read"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/mark-thread-as-read' (activity_mark_thread_as_read). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_set_repo_subscription(self, **kwargs) -> GitHubResponse:
        """Set a repository subscription (HTTP PUT /repos/{owner}/{repo}/subscription)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_set_repo_subscription" in method_map:
                result = method_map["activity_set_repo_subscription"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/set-repo-subscription' (activity_set_repo_subscription). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_set_thread_subscription(self, **kwargs) -> GitHubResponse:
        """Set a thread subscription (HTTP PUT /notifications/threads/{thread_id}/subscription)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_set_thread_subscription" in method_map:
                result = method_map["activity_set_thread_subscription"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/set-thread-subscription' (activity_set_thread_subscription). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_star_repo_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Star a repository for the authenticated user (HTTP PUT /user/starred/{owner}/{repo})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_star_repo_for_authenticated_user" in method_map:
                result = method_map["activity_star_repo_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/star-repo-for-authenticated-user' (activity_star_repo_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def activity_unstar_repo_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Unstar a repository for the authenticated user (HTTP DELETE /user/starred/{owner}/{repo})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "activity_unstar_repo_for_authenticated_user" in method_map:
                result = method_map["activity_unstar_repo_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'activity/unstar-repo-for-authenticated-user' (activity_unstar_repo_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def api_insights_get_route_stats_by_actor(self, **kwargs) -> GitHubResponse:
        """Get route stats by actor (HTTP GET /orgs/{org}/insights/api/route-stats/{actor_type}/{actor_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "api_insights_get_route_stats_by_actor" in method_map:
                result = method_map["api_insights_get_route_stats_by_actor"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'api-insights/get-route-stats-by-actor' (api_insights_get_route_stats_by_actor). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def api_insights_get_subject_stats(self, **kwargs) -> GitHubResponse:
        """Get subject stats (HTTP GET /orgs/{org}/insights/api/subject-stats)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "api_insights_get_subject_stats" in method_map:
                result = method_map["api_insights_get_subject_stats"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'api-insights/get-subject-stats' (api_insights_get_subject_stats). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def api_insights_get_summary_stats(self, **kwargs) -> GitHubResponse:
        """Get summary stats (HTTP GET /orgs/{org}/insights/api/summary-stats)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "api_insights_get_summary_stats" in method_map:
                result = method_map["api_insights_get_summary_stats"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'api-insights/get-summary-stats' (api_insights_get_summary_stats). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def api_insights_get_summary_stats_by_actor(self, **kwargs) -> GitHubResponse:
        """Get summary stats by actor (HTTP GET /orgs/{org}/insights/api/summary-stats/{actor_type}/{actor_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "api_insights_get_summary_stats_by_actor" in method_map:
                result = method_map["api_insights_get_summary_stats_by_actor"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'api-insights/get-summary-stats-by-actor' (api_insights_get_summary_stats_by_actor). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def api_insights_get_summary_stats_by_user(self, **kwargs) -> GitHubResponse:
        """Get summary stats by user (HTTP GET /orgs/{org}/insights/api/summary-stats/users/{user_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "api_insights_get_summary_stats_by_user" in method_map:
                result = method_map["api_insights_get_summary_stats_by_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'api-insights/get-summary-stats-by-user' (api_insights_get_summary_stats_by_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def api_insights_get_time_stats(self, **kwargs) -> GitHubResponse:
        """Get time stats (HTTP GET /orgs/{org}/insights/api/time-stats)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "api_insights_get_time_stats" in method_map:
                result = method_map["api_insights_get_time_stats"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'api-insights/get-time-stats' (api_insights_get_time_stats). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def api_insights_get_time_stats_by_actor(self, **kwargs) -> GitHubResponse:
        """Get time stats by actor (HTTP GET /orgs/{org}/insights/api/time-stats/{actor_type}/{actor_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "api_insights_get_time_stats_by_actor" in method_map:
                result = method_map["api_insights_get_time_stats_by_actor"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'api-insights/get-time-stats-by-actor' (api_insights_get_time_stats_by_actor). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def api_insights_get_time_stats_by_user(self, **kwargs) -> GitHubResponse:
        """Get time stats by user (HTTP GET /orgs/{org}/insights/api/time-stats/users/{user_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "api_insights_get_time_stats_by_user" in method_map:
                result = method_map["api_insights_get_time_stats_by_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'api-insights/get-time-stats-by-user' (api_insights_get_time_stats_by_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def api_insights_get_user_stats(self, **kwargs) -> GitHubResponse:
        """Get user stats (HTTP GET /orgs/{org}/insights/api/user-stats/{user_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "api_insights_get_user_stats" in method_map:
                result = method_map["api_insights_get_user_stats"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'api-insights/get-user-stats' (api_insights_get_user_stats). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_add_repo_to_installation_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Add a repository to an app installation (HTTP PUT /user/installations/{installation_id}/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_add_repo_to_installation_for_authenticated_user" in method_map:
                result = method_map["apps_add_repo_to_installation_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/add-repo-to-installation-for-authenticated-user' (apps_add_repo_to_installation_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_check_token(self, **kwargs) -> GitHubResponse:
        """Check a token (HTTP POST /applications/{client_id}/token)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_check_token" in method_map:
                result = method_map["apps_check_token"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/check-token' (apps_check_token). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_create_from_manifest(self, **kwargs) -> GitHubResponse:
        """Create a GitHub App from a manifest (HTTP POST /app-manifests/{code}/conversions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_create_from_manifest" in method_map:
                result = method_map["apps_create_from_manifest"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/create-from-manifest' (apps_create_from_manifest). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_create_installation_access_token(self, **kwargs) -> GitHubResponse:
        """Create an installation access token for an app (HTTP POST /app/installations/{installation_id}/access_tokens)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_create_installation_access_token" in method_map:
                result = method_map["apps_create_installation_access_token"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/create-installation-access-token' (apps_create_installation_access_token). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_delete_authorization(self, **kwargs) -> GitHubResponse:
        """Delete an app authorization (HTTP DELETE /applications/{client_id}/grant)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_delete_authorization" in method_map:
                result = method_map["apps_delete_authorization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/delete-authorization' (apps_delete_authorization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_delete_installation(self, **kwargs) -> GitHubResponse:
        """Delete an installation for the authenticated app (HTTP DELETE /app/installations/{installation_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_delete_installation" in method_map:
                result = method_map["apps_delete_installation"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/delete-installation' (apps_delete_installation). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_delete_token(self, **kwargs) -> GitHubResponse:
        """Delete an app token (HTTP DELETE /applications/{client_id}/token)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_delete_token" in method_map:
                result = method_map["apps_delete_token"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/delete-token' (apps_delete_token). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_get_authenticated(self, **kwargs) -> GitHubResponse:
        """Get the authenticated app (HTTP GET /app)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_get_authenticated" in method_map:
                result = method_map["apps_get_authenticated"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/get-authenticated' (apps_get_authenticated). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_get_by_slug(self, **kwargs) -> GitHubResponse:
        """Get an app (HTTP GET /apps/{app_slug})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_get_by_slug" in method_map:
                result = method_map["apps_get_by_slug"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/get-by-slug' (apps_get_by_slug). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_get_installation(self, **kwargs) -> GitHubResponse:
        """Get an installation for the authenticated app (HTTP GET /app/installations/{installation_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_get_installation" in method_map:
                result = method_map["apps_get_installation"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/get-installation' (apps_get_installation). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_get_org_installation(self, **kwargs) -> GitHubResponse:
        """Get an organization installation for the authenticated app (HTTP GET /orgs/{org}/installation)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_get_org_installation" in method_map:
                result = method_map["apps_get_org_installation"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/get-org-installation' (apps_get_org_installation). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_get_repo_installation(self, **kwargs) -> GitHubResponse:
        """Get a repository installation for the authenticated app (HTTP GET /repos/{owner}/{repo}/installation)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_get_repo_installation" in method_map:
                result = method_map["apps_get_repo_installation"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/get-repo-installation' (apps_get_repo_installation). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_get_subscription_plan_for_account(self, **kwargs) -> GitHubResponse:
        """Get a subscription plan for an account (HTTP GET /marketplace_listing/accounts/{account_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_get_subscription_plan_for_account" in method_map:
                result = method_map["apps_get_subscription_plan_for_account"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/get-subscription-plan-for-account' (apps_get_subscription_plan_for_account). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_get_subscription_plan_for_account_stubbed(self, **kwargs) -> GitHubResponse:
        """Get a subscription plan for an account (stubbed) (HTTP GET /marketplace_listing/stubbed/accounts/{account_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_get_subscription_plan_for_account_stubbed" in method_map:
                result = method_map["apps_get_subscription_plan_for_account_stubbed"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/get-subscription-plan-for-account-stubbed' (apps_get_subscription_plan_for_account_stubbed). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_get_user_installation(self, **kwargs) -> GitHubResponse:
        """Get a user installation for the authenticated app (HTTP GET /users/{username}/installation)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_get_user_installation" in method_map:
                result = method_map["apps_get_user_installation"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/get-user-installation' (apps_get_user_installation). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_get_webhook_config_for_app(self, **kwargs) -> GitHubResponse:
        """Get a webhook configuration for an app (HTTP GET /app/hook/config)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_get_webhook_config_for_app" in method_map:
                result = method_map["apps_get_webhook_config_for_app"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/get-webhook-config-for-app' (apps_get_webhook_config_for_app). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_get_webhook_delivery(self, **kwargs) -> GitHubResponse:
        """Get a delivery for an app webhook (HTTP GET /app/hook/deliveries/{delivery_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_get_webhook_delivery" in method_map:
                result = method_map["apps_get_webhook_delivery"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/get-webhook-delivery' (apps_get_webhook_delivery). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_list_accounts_for_plan(self, **kwargs) -> GitHubResponse:
        """List accounts for a plan (HTTP GET /marketplace_listing/plans/{plan_id}/accounts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_list_accounts_for_plan" in method_map:
                result = method_map["apps_list_accounts_for_plan"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/list-accounts-for-plan' (apps_list_accounts_for_plan). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_list_accounts_for_plan_stubbed(self, **kwargs) -> GitHubResponse:
        """List accounts for a plan (stubbed) (HTTP GET /marketplace_listing/stubbed/plans/{plan_id}/accounts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_list_accounts_for_plan_stubbed" in method_map:
                result = method_map["apps_list_accounts_for_plan_stubbed"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/list-accounts-for-plan-stubbed' (apps_list_accounts_for_plan_stubbed). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_list_installation_repos_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List repositories accessible to the user access token (HTTP GET /user/installations/{installation_id}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_list_installation_repos_for_authenticated_user" in method_map:
                result = method_map["apps_list_installation_repos_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/list-installation-repos-for-authenticated-user' (apps_list_installation_repos_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_list_installation_requests_for_authenticated_app(self, **kwargs) -> GitHubResponse:
        """List installation requests for the authenticated app (HTTP GET /app/installation-requests)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_list_installation_requests_for_authenticated_app" in method_map:
                result = method_map["apps_list_installation_requests_for_authenticated_app"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/list-installation-requests-for-authenticated-app' (apps_list_installation_requests_for_authenticated_app). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_list_installations(self, **kwargs) -> GitHubResponse:
        """List installations for the authenticated app (HTTP GET /app/installations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_list_installations" in method_map:
                result = method_map["apps_list_installations"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/list-installations' (apps_list_installations). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_list_installations_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List app installations accessible to the user access token (HTTP GET /user/installations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_list_installations_for_authenticated_user" in method_map:
                result = method_map["apps_list_installations_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/list-installations-for-authenticated-user' (apps_list_installations_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_list_plans(self, **kwargs) -> GitHubResponse:
        """List plans (HTTP GET /marketplace_listing/plans)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_list_plans" in method_map:
                result = method_map["apps_list_plans"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/list-plans' (apps_list_plans). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_list_plans_stubbed(self, **kwargs) -> GitHubResponse:
        """List plans (stubbed) (HTTP GET /marketplace_listing/stubbed/plans)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_list_plans_stubbed" in method_map:
                result = method_map["apps_list_plans_stubbed"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/list-plans-stubbed' (apps_list_plans_stubbed). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_list_repos_accessible_to_installation(self, **kwargs) -> GitHubResponse:
        """List repositories accessible to the app installation (HTTP GET /installation/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_list_repos_accessible_to_installation" in method_map:
                result = method_map["apps_list_repos_accessible_to_installation"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/list-repos-accessible-to-installation' (apps_list_repos_accessible_to_installation). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_list_subscriptions_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List subscriptions for the authenticated user (HTTP GET /user/marketplace_purchases)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_list_subscriptions_for_authenticated_user" in method_map:
                result = method_map["apps_list_subscriptions_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/list-subscriptions-for-authenticated-user' (apps_list_subscriptions_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_list_subscriptions_for_authenticated_user_stubbed(self, **kwargs) -> GitHubResponse:
        """List subscriptions for the authenticated user (stubbed) (HTTP GET /user/marketplace_purchases/stubbed)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_list_subscriptions_for_authenticated_user_stubbed" in method_map:
                result = method_map["apps_list_subscriptions_for_authenticated_user_stubbed"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/list-subscriptions-for-authenticated-user-stubbed' (apps_list_subscriptions_for_authenticated_user_stubbed). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_list_webhook_deliveries(self, **kwargs) -> GitHubResponse:
        """List deliveries for an app webhook (HTTP GET /app/hook/deliveries)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_list_webhook_deliveries" in method_map:
                result = method_map["apps_list_webhook_deliveries"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/list-webhook-deliveries' (apps_list_webhook_deliveries). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_redeliver_webhook_delivery(self, **kwargs) -> GitHubResponse:
        """Redeliver a delivery for an app webhook (HTTP POST /app/hook/deliveries/{delivery_id}/attempts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_redeliver_webhook_delivery" in method_map:
                result = method_map["apps_redeliver_webhook_delivery"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/redeliver-webhook-delivery' (apps_redeliver_webhook_delivery). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_remove_repo_from_installation_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Remove a repository from an app installation (HTTP DELETE /user/installations/{installation_id}/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_remove_repo_from_installation_for_authenticated_user" in method_map:
                result = method_map["apps_remove_repo_from_installation_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/remove-repo-from-installation-for-authenticated-user' (apps_remove_repo_from_installation_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_reset_token(self, **kwargs) -> GitHubResponse:
        """Reset a token (HTTP PATCH /applications/{client_id}/token)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_reset_token" in method_map:
                result = method_map["apps_reset_token"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/reset-token' (apps_reset_token). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_revoke_installation_access_token(self, **kwargs) -> GitHubResponse:
        """Revoke an installation access token (HTTP DELETE /installation/token)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_revoke_installation_access_token" in method_map:
                result = method_map["apps_revoke_installation_access_token"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/revoke-installation-access-token' (apps_revoke_installation_access_token). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_scope_token(self, **kwargs) -> GitHubResponse:
        """Create a scoped access token (HTTP POST /applications/{client_id}/token/scoped)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_scope_token" in method_map:
                result = method_map["apps_scope_token"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/scope-token' (apps_scope_token). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_suspend_installation(self, **kwargs) -> GitHubResponse:
        """Suspend an app installation (HTTP PUT /app/installations/{installation_id}/suspended)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_suspend_installation" in method_map:
                result = method_map["apps_suspend_installation"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/suspend-installation' (apps_suspend_installation). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_unsuspend_installation(self, **kwargs) -> GitHubResponse:
        """Unsuspend an app installation (HTTP DELETE /app/installations/{installation_id}/suspended)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_unsuspend_installation" in method_map:
                result = method_map["apps_unsuspend_installation"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/unsuspend-installation' (apps_unsuspend_installation). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def apps_update_webhook_config_for_app(self, **kwargs) -> GitHubResponse:
        """Update a webhook configuration for an app (HTTP PATCH /app/hook/config)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "apps_update_webhook_config_for_app" in method_map:
                result = method_map["apps_update_webhook_config_for_app"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'apps/update-webhook-config-for-app' (apps_update_webhook_config_for_app). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def billing_get_github_actions_billing_org(self, **kwargs) -> GitHubResponse:
        """Get GitHub Actions billing for an organization (HTTP GET /orgs/{org}/settings/billing/actions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "billing_get_github_actions_billing_org" in method_map:
                result = method_map["billing_get_github_actions_billing_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'billing/get-github-actions-billing-org' (billing_get_github_actions_billing_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def billing_get_github_actions_billing_user(self, **kwargs) -> GitHubResponse:
        """Get GitHub Actions billing for a user (HTTP GET /users/{username}/settings/billing/actions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "billing_get_github_actions_billing_user" in method_map:
                result = method_map["billing_get_github_actions_billing_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'billing/get-github-actions-billing-user' (billing_get_github_actions_billing_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def billing_get_github_billing_usage_report_org(self, **kwargs) -> GitHubResponse:
        """Get billing usage report for an organization (HTTP GET /organizations/{org}/settings/billing/usage)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "billing_get_github_billing_usage_report_org" in method_map:
                result = method_map["billing_get_github_billing_usage_report_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'billing/get-github-billing-usage-report-org' (billing_get_github_billing_usage_report_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def billing_get_github_billing_usage_report_user(self, **kwargs) -> GitHubResponse:
        """Get billing usage report for a user (HTTP GET /users/{username}/settings/billing/usage)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "billing_get_github_billing_usage_report_user" in method_map:
                result = method_map["billing_get_github_billing_usage_report_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'billing/get-github-billing-usage-report-user' (billing_get_github_billing_usage_report_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def billing_get_github_packages_billing_org(self, **kwargs) -> GitHubResponse:
        """Get GitHub Packages billing for an organization (HTTP GET /orgs/{org}/settings/billing/packages)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "billing_get_github_packages_billing_org" in method_map:
                result = method_map["billing_get_github_packages_billing_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'billing/get-github-packages-billing-org' (billing_get_github_packages_billing_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def billing_get_github_packages_billing_user(self, **kwargs) -> GitHubResponse:
        """Get GitHub Packages billing for a user (HTTP GET /users/{username}/settings/billing/packages)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "billing_get_github_packages_billing_user" in method_map:
                result = method_map["billing_get_github_packages_billing_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'billing/get-github-packages-billing-user' (billing_get_github_packages_billing_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def billing_get_shared_storage_billing_org(self, **kwargs) -> GitHubResponse:
        """Get shared storage billing for an organization (HTTP GET /orgs/{org}/settings/billing/shared-storage)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "billing_get_shared_storage_billing_org" in method_map:
                result = method_map["billing_get_shared_storage_billing_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'billing/get-shared-storage-billing-org' (billing_get_shared_storage_billing_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def billing_get_shared_storage_billing_user(self, **kwargs) -> GitHubResponse:
        """Get shared storage billing for a user (HTTP GET /users/{username}/settings/billing/shared-storage)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "billing_get_shared_storage_billing_user" in method_map:
                result = method_map["billing_get_shared_storage_billing_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'billing/get-shared-storage-billing-user' (billing_get_shared_storage_billing_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def campaigns_create_campaign(self, **kwargs) -> GitHubResponse:
        """Create a campaign for an organization (HTTP POST /orgs/{org}/campaigns)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "campaigns_create_campaign" in method_map:
                result = method_map["campaigns_create_campaign"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'campaigns/create-campaign' (campaigns_create_campaign). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def campaigns_delete_campaign(self, **kwargs) -> GitHubResponse:
        """Delete a campaign for an organization (HTTP DELETE /orgs/{org}/campaigns/{campaign_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "campaigns_delete_campaign" in method_map:
                result = method_map["campaigns_delete_campaign"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'campaigns/delete-campaign' (campaigns_delete_campaign). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def campaigns_get_campaign_summary(self, **kwargs) -> GitHubResponse:
        """Get a campaign for an organization (HTTP GET /orgs/{org}/campaigns/{campaign_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "campaigns_get_campaign_summary" in method_map:
                result = method_map["campaigns_get_campaign_summary"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'campaigns/get-campaign-summary' (campaigns_get_campaign_summary). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def campaigns_list_org_campaigns(self, **kwargs) -> GitHubResponse:
        """List campaigns for an organization (HTTP GET /orgs/{org}/campaigns)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "campaigns_list_org_campaigns" in method_map:
                result = method_map["campaigns_list_org_campaigns"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'campaigns/list-org-campaigns' (campaigns_list_org_campaigns). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def campaigns_update_campaign(self, **kwargs) -> GitHubResponse:
        """Update a campaign (HTTP PATCH /orgs/{org}/campaigns/{campaign_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "campaigns_update_campaign" in method_map:
                result = method_map["campaigns_update_campaign"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'campaigns/update-campaign' (campaigns_update_campaign). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def checks_create(self, **kwargs) -> GitHubResponse:
        """Create a check run (HTTP POST /repos/{owner}/{repo}/check-runs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "checks_create" in method_map:
                result = method_map["checks_create"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'checks/create' (checks_create). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def checks_create_suite(self, **kwargs) -> GitHubResponse:
        """Create a check suite (HTTP POST /repos/{owner}/{repo}/check-suites)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "checks_create_suite" in method_map:
                result = method_map["checks_create_suite"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'checks/create-suite' (checks_create_suite). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def checks_get(self, **kwargs) -> GitHubResponse:
        """Get a check run (HTTP GET /repos/{owner}/{repo}/check-runs/{check_run_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "checks_get" in method_map:
                result = method_map["checks_get"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'checks/get' (checks_get). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def checks_get_suite(self, **kwargs) -> GitHubResponse:
        """Get a check suite (HTTP GET /repos/{owner}/{repo}/check-suites/{check_suite_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "checks_get_suite" in method_map:
                result = method_map["checks_get_suite"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'checks/get-suite' (checks_get_suite). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def checks_list_annotations(self, **kwargs) -> GitHubResponse:
        """List check run annotations (HTTP GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "checks_list_annotations" in method_map:
                result = method_map["checks_list_annotations"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'checks/list-annotations' (checks_list_annotations). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def checks_list_for_ref(self, **kwargs) -> GitHubResponse:
        """List check runs for a Git reference (HTTP GET /repos/{owner}/{repo}/commits/{ref}/check-runs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "checks_list_for_ref" in method_map:
                result = method_map["checks_list_for_ref"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'checks/list-for-ref' (checks_list_for_ref). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def checks_list_for_suite(self, **kwargs) -> GitHubResponse:
        """List check runs in a check suite (HTTP GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "checks_list_for_suite" in method_map:
                result = method_map["checks_list_for_suite"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'checks/list-for-suite' (checks_list_for_suite). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def checks_list_suites_for_ref(self, **kwargs) -> GitHubResponse:
        """List check suites for a Git reference (HTTP GET /repos/{owner}/{repo}/commits/{ref}/check-suites)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "checks_list_suites_for_ref" in method_map:
                result = method_map["checks_list_suites_for_ref"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'checks/list-suites-for-ref' (checks_list_suites_for_ref). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def checks_rerequest_run(self, **kwargs) -> GitHubResponse:
        """Rerequest a check run (HTTP POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "checks_rerequest_run" in method_map:
                result = method_map["checks_rerequest_run"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'checks/rerequest-run' (checks_rerequest_run). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def checks_rerequest_suite(self, **kwargs) -> GitHubResponse:
        """Rerequest a check suite (HTTP POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "checks_rerequest_suite" in method_map:
                result = method_map["checks_rerequest_suite"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'checks/rerequest-suite' (checks_rerequest_suite). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def checks_set_suites_preferences(self, **kwargs) -> GitHubResponse:
        """Update repository preferences for check suites (HTTP PATCH /repos/{owner}/{repo}/check-suites/preferences)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "checks_set_suites_preferences" in method_map:
                result = method_map["checks_set_suites_preferences"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'checks/set-suites-preferences' (checks_set_suites_preferences). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def checks_update(self, **kwargs) -> GitHubResponse:
        """Update a check run (HTTP PATCH /repos/{owner}/{repo}/check-runs/{check_run_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "checks_update" in method_map:
                result = method_map["checks_update"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'checks/update' (checks_update). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def classroom_get_a_classroom(self, **kwargs) -> GitHubResponse:
        """Get a classroom (HTTP GET /classrooms/{classroom_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "classroom_get_a_classroom" in method_map:
                result = method_map["classroom_get_a_classroom"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'classroom/get-a-classroom' (classroom_get_a_classroom). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def classroom_get_an_assignment(self, **kwargs) -> GitHubResponse:
        """Get an assignment (HTTP GET /assignments/{assignment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "classroom_get_an_assignment" in method_map:
                result = method_map["classroom_get_an_assignment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'classroom/get-an-assignment' (classroom_get_an_assignment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def classroom_get_assignment_grades(self, **kwargs) -> GitHubResponse:
        """Get assignment grades (HTTP GET /assignments/{assignment_id}/grades)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "classroom_get_assignment_grades" in method_map:
                result = method_map["classroom_get_assignment_grades"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'classroom/get-assignment-grades' (classroom_get_assignment_grades). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def classroom_list_accepted_assignments_for_an_assignment(self, **kwargs) -> GitHubResponse:
        """List accepted assignments for an assignment (HTTP GET /assignments/{assignment_id}/accepted_assignments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "classroom_list_accepted_assignments_for_an_assignment" in method_map:
                result = method_map["classroom_list_accepted_assignments_for_an_assignment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'classroom/list-accepted-assignments-for-an-assignment' (classroom_list_accepted_assignments_for_an_assignment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def classroom_list_assignments_for_a_classroom(self, **kwargs) -> GitHubResponse:
        """List assignments for a classroom (HTTP GET /classrooms/{classroom_id}/assignments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "classroom_list_assignments_for_a_classroom" in method_map:
                result = method_map["classroom_list_assignments_for_a_classroom"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'classroom/list-assignments-for-a-classroom' (classroom_list_assignments_for_a_classroom). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def classroom_list_classrooms(self, **kwargs) -> GitHubResponse:
        """List classrooms (HTTP GET /classrooms)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "classroom_list_classrooms" in method_map:
                result = method_map["classroom_list_classrooms"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'classroom/list-classrooms' (classroom_list_classrooms). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_commit_autofix(self, **kwargs) -> GitHubResponse:
        """Commit an autofix for a code scanning alert (HTTP POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_commit_autofix" in method_map:
                result = method_map["code_scanning_commit_autofix"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/commit-autofix' (code_scanning_commit_autofix). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_create_autofix(self, **kwargs) -> GitHubResponse:
        """Create an autofix for a code scanning alert (HTTP POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_create_autofix" in method_map:
                result = method_map["code_scanning_create_autofix"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/create-autofix' (code_scanning_create_autofix). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_create_variant_analysis(self, **kwargs) -> GitHubResponse:
        """Create a CodeQL variant analysis (HTTP POST /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_create_variant_analysis" in method_map:
                result = method_map["code_scanning_create_variant_analysis"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/create-variant-analysis' (code_scanning_create_variant_analysis). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_delete_analysis(self, **kwargs) -> GitHubResponse:
        """Delete a code scanning analysis from a repository (HTTP DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_delete_analysis" in method_map:
                result = method_map["code_scanning_delete_analysis"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/delete-analysis' (code_scanning_delete_analysis). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_delete_codeql_database(self, **kwargs) -> GitHubResponse:
        """Delete a CodeQL database (HTTP DELETE /repos/{owner}/{repo}/code-scanning/codeql/databases/{language})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_delete_codeql_database" in method_map:
                result = method_map["code_scanning_delete_codeql_database"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/delete-codeql-database' (code_scanning_delete_codeql_database). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_get_alert(self, **kwargs) -> GitHubResponse:
        """Get a code scanning alert (HTTP GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_get_alert" in method_map:
                result = method_map["code_scanning_get_alert"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/get-alert' (code_scanning_get_alert). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_get_analysis(self, **kwargs) -> GitHubResponse:
        """Get a code scanning analysis for a repository (HTTP GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_get_analysis" in method_map:
                result = method_map["code_scanning_get_analysis"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/get-analysis' (code_scanning_get_analysis). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_get_autofix(self, **kwargs) -> GitHubResponse:
        """Get the status of an autofix for a code scanning alert (HTTP GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_get_autofix" in method_map:
                result = method_map["code_scanning_get_autofix"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/get-autofix' (code_scanning_get_autofix). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_get_codeql_database(self, **kwargs) -> GitHubResponse:
        """Get a CodeQL database for a repository (HTTP GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_get_codeql_database" in method_map:
                result = method_map["code_scanning_get_codeql_database"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/get-codeql-database' (code_scanning_get_codeql_database). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_get_default_setup(self, **kwargs) -> GitHubResponse:
        """Get a code scanning default setup configuration (HTTP GET /repos/{owner}/{repo}/code-scanning/default-setup)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_get_default_setup" in method_map:
                result = method_map["code_scanning_get_default_setup"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/get-default-setup' (code_scanning_get_default_setup). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_get_sarif(self, **kwargs) -> GitHubResponse:
        """Get information about a SARIF upload (HTTP GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_get_sarif" in method_map:
                result = method_map["code_scanning_get_sarif"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/get-sarif' (code_scanning_get_sarif). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_get_variant_analysis(self, **kwargs) -> GitHubResponse:
        """Get the summary of a CodeQL variant analysis (HTTP GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_get_variant_analysis" in method_map:
                result = method_map["code_scanning_get_variant_analysis"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/get-variant-analysis' (code_scanning_get_variant_analysis). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_get_variant_analysis_repo_task(self, **kwargs) -> GitHubResponse:
        """Get the analysis status of a repository in a CodeQL variant analysis (HTTP GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_get_variant_analysis_repo_task" in method_map:
                result = method_map["code_scanning_get_variant_analysis_repo_task"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/get-variant-analysis-repo-task' (code_scanning_get_variant_analysis_repo_task). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_list_alert_instances(self, **kwargs) -> GitHubResponse:
        """List instances of a code scanning alert (HTTP GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_list_alert_instances" in method_map:
                result = method_map["code_scanning_list_alert_instances"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/list-alert-instances' (code_scanning_list_alert_instances). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_list_alerts_for_org(self, **kwargs) -> GitHubResponse:
        """List code scanning alerts for an organization (HTTP GET /orgs/{org}/code-scanning/alerts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_list_alerts_for_org" in method_map:
                result = method_map["code_scanning_list_alerts_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/list-alerts-for-org' (code_scanning_list_alerts_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_list_alerts_for_repo(self, **kwargs) -> GitHubResponse:
        """List code scanning alerts for a repository (HTTP GET /repos/{owner}/{repo}/code-scanning/alerts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_list_alerts_for_repo" in method_map:
                result = method_map["code_scanning_list_alerts_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/list-alerts-for-repo' (code_scanning_list_alerts_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_list_codeql_databases(self, **kwargs) -> GitHubResponse:
        """List CodeQL databases for a repository (HTTP GET /repos/{owner}/{repo}/code-scanning/codeql/databases)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_list_codeql_databases" in method_map:
                result = method_map["code_scanning_list_codeql_databases"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/list-codeql-databases' (code_scanning_list_codeql_databases). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_list_recent_analyses(self, **kwargs) -> GitHubResponse:
        """List code scanning analyses for a repository (HTTP GET /repos/{owner}/{repo}/code-scanning/analyses)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_list_recent_analyses" in method_map:
                result = method_map["code_scanning_list_recent_analyses"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/list-recent-analyses' (code_scanning_list_recent_analyses). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_update_alert(self, **kwargs) -> GitHubResponse:
        """Update a code scanning alert (HTTP PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_update_alert" in method_map:
                result = method_map["code_scanning_update_alert"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/update-alert' (code_scanning_update_alert). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_update_default_setup(self, **kwargs) -> GitHubResponse:
        """Update a code scanning default setup configuration (HTTP PATCH /repos/{owner}/{repo}/code-scanning/default-setup)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_update_default_setup" in method_map:
                result = method_map["code_scanning_update_default_setup"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/update-default-setup' (code_scanning_update_default_setup). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_scanning_upload_sarif(self, **kwargs) -> GitHubResponse:
        """Upload an analysis as SARIF data (HTTP POST /repos/{owner}/{repo}/code-scanning/sarifs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_scanning_upload_sarif" in method_map:
                result = method_map["code_scanning_upload_sarif"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-scanning/upload-sarif' (code_scanning_upload_sarif). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_attach_configuration(self, **kwargs) -> GitHubResponse:
        """Attach a configuration to repositories (HTTP POST /orgs/{org}/code-security/configurations/{configuration_id}/attach)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_attach_configuration" in method_map:
                result = method_map["code_security_attach_configuration"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/attach-configuration' (code_security_attach_configuration). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_attach_enterprise_configuration(self, **kwargs) -> GitHubResponse:
        """Attach an enterprise configuration to repositories (HTTP POST /enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_attach_enterprise_configuration" in method_map:
                result = method_map["code_security_attach_enterprise_configuration"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/attach-enterprise-configuration' (code_security_attach_enterprise_configuration). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_create_configuration(self, **kwargs) -> GitHubResponse:
        """Create a code security configuration (HTTP POST /orgs/{org}/code-security/configurations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_create_configuration" in method_map:
                result = method_map["code_security_create_configuration"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/create-configuration' (code_security_create_configuration). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_create_configuration_for_enterprise(self, **kwargs) -> GitHubResponse:
        """Create a code security configuration for an enterprise (HTTP POST /enterprises/{enterprise}/code-security/configurations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_create_configuration_for_enterprise" in method_map:
                result = method_map["code_security_create_configuration_for_enterprise"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/create-configuration-for-enterprise' (code_security_create_configuration_for_enterprise). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_delete_configuration(self, **kwargs) -> GitHubResponse:
        """Delete a code security configuration (HTTP DELETE /orgs/{org}/code-security/configurations/{configuration_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_delete_configuration" in method_map:
                result = method_map["code_security_delete_configuration"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/delete-configuration' (code_security_delete_configuration). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_delete_configuration_for_enterprise(self, **kwargs) -> GitHubResponse:
        """Delete a code security configuration for an enterprise (HTTP DELETE /enterprises/{enterprise}/code-security/configurations/{configuration_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_delete_configuration_for_enterprise" in method_map:
                result = method_map["code_security_delete_configuration_for_enterprise"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/delete-configuration-for-enterprise' (code_security_delete_configuration_for_enterprise). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_detach_configuration(self, **kwargs) -> GitHubResponse:
        """Detach configurations from repositories (HTTP DELETE /orgs/{org}/code-security/configurations/detach)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_detach_configuration" in method_map:
                result = method_map["code_security_detach_configuration"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/detach-configuration' (code_security_detach_configuration). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_get_configuration(self, **kwargs) -> GitHubResponse:
        """Get a code security configuration (HTTP GET /orgs/{org}/code-security/configurations/{configuration_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_get_configuration" in method_map:
                result = method_map["code_security_get_configuration"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/get-configuration' (code_security_get_configuration). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_get_configuration_for_repository(self, **kwargs) -> GitHubResponse:
        """Get the code security configuration associated with a repository (HTTP GET /repos/{owner}/{repo}/code-security-configuration)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_get_configuration_for_repository" in method_map:
                result = method_map["code_security_get_configuration_for_repository"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/get-configuration-for-repository' (code_security_get_configuration_for_repository). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_get_configurations_for_enterprise(self, **kwargs) -> GitHubResponse:
        """Get code security configurations for an enterprise (HTTP GET /enterprises/{enterprise}/code-security/configurations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_get_configurations_for_enterprise" in method_map:
                result = method_map["code_security_get_configurations_for_enterprise"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/get-configurations-for-enterprise' (code_security_get_configurations_for_enterprise). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_get_configurations_for_org(self, **kwargs) -> GitHubResponse:
        """Get code security configurations for an organization (HTTP GET /orgs/{org}/code-security/configurations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_get_configurations_for_org" in method_map:
                result = method_map["code_security_get_configurations_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/get-configurations-for-org' (code_security_get_configurations_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_get_default_configurations(self, **kwargs) -> GitHubResponse:
        """Get default code security configurations (HTTP GET /orgs/{org}/code-security/configurations/defaults)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_get_default_configurations" in method_map:
                result = method_map["code_security_get_default_configurations"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/get-default-configurations' (code_security_get_default_configurations). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_get_default_configurations_for_enterprise(self, **kwargs) -> GitHubResponse:
        """Get default code security configurations for an enterprise (HTTP GET /enterprises/{enterprise}/code-security/configurations/defaults)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_get_default_configurations_for_enterprise" in method_map:
                result = method_map["code_security_get_default_configurations_for_enterprise"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/get-default-configurations-for-enterprise' (code_security_get_default_configurations_for_enterprise). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_get_repositories_for_configuration(self, **kwargs) -> GitHubResponse:
        """Get repositories associated with a code security configuration (HTTP GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_get_repositories_for_configuration" in method_map:
                result = method_map["code_security_get_repositories_for_configuration"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/get-repositories-for-configuration' (code_security_get_repositories_for_configuration). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_get_repositories_for_enterprise_configuration(self, **kwargs) -> GitHubResponse:
        """Get repositories associated with an enterprise code security configuration (HTTP GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_get_repositories_for_enterprise_configuration" in method_map:
                result = method_map["code_security_get_repositories_for_enterprise_configuration"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/get-repositories-for-enterprise-configuration' (code_security_get_repositories_for_enterprise_configuration). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_get_single_configuration_for_enterprise(self, **kwargs) -> GitHubResponse:
        """Retrieve a code security configuration of an enterprise (HTTP GET /enterprises/{enterprise}/code-security/configurations/{configuration_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_get_single_configuration_for_enterprise" in method_map:
                result = method_map["code_security_get_single_configuration_for_enterprise"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/get-single-configuration-for-enterprise' (code_security_get_single_configuration_for_enterprise). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_set_configuration_as_default(self, **kwargs) -> GitHubResponse:
        """Set a code security configuration as a default for an organization (HTTP PUT /orgs/{org}/code-security/configurations/{configuration_id}/defaults)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_set_configuration_as_default" in method_map:
                result = method_map["code_security_set_configuration_as_default"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/set-configuration-as-default' (code_security_set_configuration_as_default). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_set_configuration_as_default_for_enterprise(self, **kwargs) -> GitHubResponse:
        """Set a code security configuration as a default for an enterprise (HTTP PUT /enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_set_configuration_as_default_for_enterprise" in method_map:
                result = method_map["code_security_set_configuration_as_default_for_enterprise"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/set-configuration-as-default-for-enterprise' (code_security_set_configuration_as_default_for_enterprise). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_update_configuration(self, **kwargs) -> GitHubResponse:
        """Update a code security configuration (HTTP PATCH /orgs/{org}/code-security/configurations/{configuration_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_update_configuration" in method_map:
                result = method_map["code_security_update_configuration"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/update-configuration' (code_security_update_configuration). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def code_security_update_enterprise_configuration(self, **kwargs) -> GitHubResponse:
        """Update a custom code security configuration for an enterprise (HTTP PATCH /enterprises/{enterprise}/code-security/configurations/{configuration_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "code_security_update_enterprise_configuration" in method_map:
                result = method_map["code_security_update_enterprise_configuration"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'code-security/update-enterprise-configuration' (code_security_update_enterprise_configuration). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codes_of_conduct_get_all_codes_of_conduct(self, **kwargs) -> GitHubResponse:
        """Get all codes of conduct (HTTP GET /codes_of_conduct)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codes_of_conduct_get_all_codes_of_conduct" in method_map:
                result = method_map["codes_of_conduct_get_all_codes_of_conduct"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codes-of-conduct/get-all-codes-of-conduct' (codes_of_conduct_get_all_codes_of_conduct). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codes_of_conduct_get_conduct_code(self, **kwargs) -> GitHubResponse:
        """Get a code of conduct (HTTP GET /codes_of_conduct/{key})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codes_of_conduct_get_conduct_code" in method_map:
                result = method_map["codes_of_conduct_get_conduct_code"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codes-of-conduct/get-conduct-code' (codes_of_conduct_get_conduct_code). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_add_repository_for_secret_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Add a selected repository to a user secret (HTTP PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_add_repository_for_secret_for_authenticated_user" in method_map:
                result = method_map["codespaces_add_repository_for_secret_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/add-repository-for-secret-for-authenticated-user' (codespaces_add_repository_for_secret_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_add_selected_repo_to_org_secret(self, **kwargs) -> GitHubResponse:
        """Add selected repository to an organization secret (HTTP PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_add_selected_repo_to_org_secret" in method_map:
                result = method_map["codespaces_add_selected_repo_to_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/add-selected-repo-to-org-secret' (codespaces_add_selected_repo_to_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_check_permissions_for_devcontainer(self, **kwargs) -> GitHubResponse:
        """Check if permissions defined by a devcontainer have been accepted by the authenticated user (HTTP GET /repos/{owner}/{repo}/codespaces/permissions_check)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_check_permissions_for_devcontainer" in method_map:
                result = method_map["codespaces_check_permissions_for_devcontainer"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/check-permissions-for-devcontainer' (codespaces_check_permissions_for_devcontainer). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_codespace_machines_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List machine types for a codespace (HTTP GET /user/codespaces/{codespace_name}/machines)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_codespace_machines_for_authenticated_user" in method_map:
                result = method_map["codespaces_codespace_machines_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/codespace-machines-for-authenticated-user' (codespaces_codespace_machines_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_create_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Create a codespace for the authenticated user (HTTP POST /user/codespaces)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_create_for_authenticated_user" in method_map:
                result = method_map["codespaces_create_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/create-for-authenticated-user' (codespaces_create_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_create_or_update_org_secret(self, **kwargs) -> GitHubResponse:
        """Create or update an organization secret (HTTP PUT /orgs/{org}/codespaces/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_create_or_update_org_secret" in method_map:
                result = method_map["codespaces_create_or_update_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/create-or-update-org-secret' (codespaces_create_or_update_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_create_or_update_repo_secret(self, **kwargs) -> GitHubResponse:
        """Create or update a repository secret (HTTP PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_create_or_update_repo_secret" in method_map:
                result = method_map["codespaces_create_or_update_repo_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/create-or-update-repo-secret' (codespaces_create_or_update_repo_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_create_or_update_secret_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Create or update a secret for the authenticated user (HTTP PUT /user/codespaces/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_create_or_update_secret_for_authenticated_user" in method_map:
                result = method_map["codespaces_create_or_update_secret_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/create-or-update-secret-for-authenticated-user' (codespaces_create_or_update_secret_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_create_with_pr_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Create a codespace from a pull request (HTTP POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_create_with_pr_for_authenticated_user" in method_map:
                result = method_map["codespaces_create_with_pr_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/create-with-pr-for-authenticated-user' (codespaces_create_with_pr_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_create_with_repo_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Create a codespace in a repository (HTTP POST /repos/{owner}/{repo}/codespaces)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_create_with_repo_for_authenticated_user" in method_map:
                result = method_map["codespaces_create_with_repo_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/create-with-repo-for-authenticated-user' (codespaces_create_with_repo_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_delete_codespaces_access_users(self, **kwargs) -> GitHubResponse:
        """Remove users from Codespaces access for an organization (HTTP DELETE /orgs/{org}/codespaces/access/selected_users)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_delete_codespaces_access_users" in method_map:
                result = method_map["codespaces_delete_codespaces_access_users"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/delete-codespaces-access-users' (codespaces_delete_codespaces_access_users). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_delete_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Delete a codespace for the authenticated user (HTTP DELETE /user/codespaces/{codespace_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_delete_for_authenticated_user" in method_map:
                result = method_map["codespaces_delete_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/delete-for-authenticated-user' (codespaces_delete_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_delete_from_organization(self, **kwargs) -> GitHubResponse:
        """Delete a codespace from the organization (HTTP DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_delete_from_organization" in method_map:
                result = method_map["codespaces_delete_from_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/delete-from-organization' (codespaces_delete_from_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_delete_org_secret(self, **kwargs) -> GitHubResponse:
        """Delete an organization secret (HTTP DELETE /orgs/{org}/codespaces/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_delete_org_secret" in method_map:
                result = method_map["codespaces_delete_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/delete-org-secret' (codespaces_delete_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_delete_repo_secret(self, **kwargs) -> GitHubResponse:
        """Delete a repository secret (HTTP DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_delete_repo_secret" in method_map:
                result = method_map["codespaces_delete_repo_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/delete-repo-secret' (codespaces_delete_repo_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_delete_secret_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Delete a secret for the authenticated user (HTTP DELETE /user/codespaces/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_delete_secret_for_authenticated_user" in method_map:
                result = method_map["codespaces_delete_secret_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/delete-secret-for-authenticated-user' (codespaces_delete_secret_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_export_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Export a codespace for the authenticated user (HTTP POST /user/codespaces/{codespace_name}/exports)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_export_for_authenticated_user" in method_map:
                result = method_map["codespaces_export_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/export-for-authenticated-user' (codespaces_export_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_get_codespaces_for_user_in_org(self, **kwargs) -> GitHubResponse:
        """List codespaces for a user in organization (HTTP GET /orgs/{org}/members/{username}/codespaces)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_get_codespaces_for_user_in_org" in method_map:
                result = method_map["codespaces_get_codespaces_for_user_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/get-codespaces-for-user-in-org' (codespaces_get_codespaces_for_user_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_get_export_details_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get details about a codespace export (HTTP GET /user/codespaces/{codespace_name}/exports/{export_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_get_export_details_for_authenticated_user" in method_map:
                result = method_map["codespaces_get_export_details_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/get-export-details-for-authenticated-user' (codespaces_get_export_details_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_get_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get a codespace for the authenticated user (HTTP GET /user/codespaces/{codespace_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_get_for_authenticated_user" in method_map:
                result = method_map["codespaces_get_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/get-for-authenticated-user' (codespaces_get_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_get_org_public_key(self, **kwargs) -> GitHubResponse:
        """Get an organization public key (HTTP GET /orgs/{org}/codespaces/secrets/public-key)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_get_org_public_key" in method_map:
                result = method_map["codespaces_get_org_public_key"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/get-org-public-key' (codespaces_get_org_public_key). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_get_org_secret(self, **kwargs) -> GitHubResponse:
        """Get an organization secret (HTTP GET /orgs/{org}/codespaces/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_get_org_secret" in method_map:
                result = method_map["codespaces_get_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/get-org-secret' (codespaces_get_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_get_public_key_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get public key for the authenticated user (HTTP GET /user/codespaces/secrets/public-key)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_get_public_key_for_authenticated_user" in method_map:
                result = method_map["codespaces_get_public_key_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/get-public-key-for-authenticated-user' (codespaces_get_public_key_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_get_repo_public_key(self, **kwargs) -> GitHubResponse:
        """Get a repository public key (HTTP GET /repos/{owner}/{repo}/codespaces/secrets/public-key)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_get_repo_public_key" in method_map:
                result = method_map["codespaces_get_repo_public_key"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/get-repo-public-key' (codespaces_get_repo_public_key). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_get_repo_secret(self, **kwargs) -> GitHubResponse:
        """Get a repository secret (HTTP GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_get_repo_secret" in method_map:
                result = method_map["codespaces_get_repo_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/get-repo-secret' (codespaces_get_repo_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_get_secret_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get a secret for the authenticated user (HTTP GET /user/codespaces/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_get_secret_for_authenticated_user" in method_map:
                result = method_map["codespaces_get_secret_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/get-secret-for-authenticated-user' (codespaces_get_secret_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_list_devcontainers_in_repository_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List devcontainer configurations in a repository for the authenticated user (HTTP GET /repos/{owner}/{repo}/codespaces/devcontainers)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_list_devcontainers_in_repository_for_authenticated_user" in method_map:
                result = method_map["codespaces_list_devcontainers_in_repository_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/list-devcontainers-in-repository-for-authenticated-user' (codespaces_list_devcontainers_in_repository_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_list_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List codespaces for the authenticated user (HTTP GET /user/codespaces)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_list_for_authenticated_user" in method_map:
                result = method_map["codespaces_list_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/list-for-authenticated-user' (codespaces_list_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_list_in_organization(self, **kwargs) -> GitHubResponse:
        """List codespaces for the organization (HTTP GET /orgs/{org}/codespaces)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_list_in_organization" in method_map:
                result = method_map["codespaces_list_in_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/list-in-organization' (codespaces_list_in_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_list_in_repository_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List codespaces in a repository for the authenticated user (HTTP GET /repos/{owner}/{repo}/codespaces)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_list_in_repository_for_authenticated_user" in method_map:
                result = method_map["codespaces_list_in_repository_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/list-in-repository-for-authenticated-user' (codespaces_list_in_repository_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_list_org_secrets(self, **kwargs) -> GitHubResponse:
        """List organization secrets (HTTP GET /orgs/{org}/codespaces/secrets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_list_org_secrets" in method_map:
                result = method_map["codespaces_list_org_secrets"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/list-org-secrets' (codespaces_list_org_secrets). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_list_repo_secrets(self, **kwargs) -> GitHubResponse:
        """List repository secrets (HTTP GET /repos/{owner}/{repo}/codespaces/secrets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_list_repo_secrets" in method_map:
                result = method_map["codespaces_list_repo_secrets"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/list-repo-secrets' (codespaces_list_repo_secrets). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_list_repositories_for_secret_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List selected repositories for a user secret (HTTP GET /user/codespaces/secrets/{secret_name}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_list_repositories_for_secret_for_authenticated_user" in method_map:
                result = method_map["codespaces_list_repositories_for_secret_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/list-repositories-for-secret-for-authenticated-user' (codespaces_list_repositories_for_secret_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_list_secrets_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List secrets for the authenticated user (HTTP GET /user/codespaces/secrets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_list_secrets_for_authenticated_user" in method_map:
                result = method_map["codespaces_list_secrets_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/list-secrets-for-authenticated-user' (codespaces_list_secrets_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_list_selected_repos_for_org_secret(self, **kwargs) -> GitHubResponse:
        """List selected repositories for an organization secret (HTTP GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_list_selected_repos_for_org_secret" in method_map:
                result = method_map["codespaces_list_selected_repos_for_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/list-selected-repos-for-org-secret' (codespaces_list_selected_repos_for_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_pre_flight_with_repo_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get default attributes for a codespace (HTTP GET /repos/{owner}/{repo}/codespaces/new)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_pre_flight_with_repo_for_authenticated_user" in method_map:
                result = method_map["codespaces_pre_flight_with_repo_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/pre-flight-with-repo-for-authenticated-user' (codespaces_pre_flight_with_repo_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_publish_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Create a repository from an unpublished codespace (HTTP POST /user/codespaces/{codespace_name}/publish)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_publish_for_authenticated_user" in method_map:
                result = method_map["codespaces_publish_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/publish-for-authenticated-user' (codespaces_publish_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_remove_repository_for_secret_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Remove a selected repository from a user secret (HTTP DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_remove_repository_for_secret_for_authenticated_user" in method_map:
                result = method_map["codespaces_remove_repository_for_secret_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/remove-repository-for-secret-for-authenticated-user' (codespaces_remove_repository_for_secret_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_remove_selected_repo_from_org_secret(self, **kwargs) -> GitHubResponse:
        """Remove selected repository from an organization secret (HTTP DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_remove_selected_repo_from_org_secret" in method_map:
                result = method_map["codespaces_remove_selected_repo_from_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/remove-selected-repo-from-org-secret' (codespaces_remove_selected_repo_from_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_repo_machines_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List available machine types for a repository (HTTP GET /repos/{owner}/{repo}/codespaces/machines)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_repo_machines_for_authenticated_user" in method_map:
                result = method_map["codespaces_repo_machines_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/repo-machines-for-authenticated-user' (codespaces_repo_machines_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_set_codespaces_access(self, **kwargs) -> GitHubResponse:
        """Manage access control for organization codespaces (HTTP PUT /orgs/{org}/codespaces/access)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_set_codespaces_access" in method_map:
                result = method_map["codespaces_set_codespaces_access"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/set-codespaces-access' (codespaces_set_codespaces_access). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_set_codespaces_access_users(self, **kwargs) -> GitHubResponse:
        """Add users to Codespaces access for an organization (HTTP POST /orgs/{org}/codespaces/access/selected_users)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_set_codespaces_access_users" in method_map:
                result = method_map["codespaces_set_codespaces_access_users"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/set-codespaces-access-users' (codespaces_set_codespaces_access_users). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_set_repositories_for_secret_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Set selected repositories for a user secret (HTTP PUT /user/codespaces/secrets/{secret_name}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_set_repositories_for_secret_for_authenticated_user" in method_map:
                result = method_map["codespaces_set_repositories_for_secret_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/set-repositories-for-secret-for-authenticated-user' (codespaces_set_repositories_for_secret_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_set_selected_repos_for_org_secret(self, **kwargs) -> GitHubResponse:
        """Set selected repositories for an organization secret (HTTP PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_set_selected_repos_for_org_secret" in method_map:
                result = method_map["codespaces_set_selected_repos_for_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/set-selected-repos-for-org-secret' (codespaces_set_selected_repos_for_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_start_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Start a codespace for the authenticated user (HTTP POST /user/codespaces/{codespace_name}/start)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_start_for_authenticated_user" in method_map:
                result = method_map["codespaces_start_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/start-for-authenticated-user' (codespaces_start_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_stop_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Stop a codespace for the authenticated user (HTTP POST /user/codespaces/{codespace_name}/stop)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_stop_for_authenticated_user" in method_map:
                result = method_map["codespaces_stop_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/stop-for-authenticated-user' (codespaces_stop_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_stop_in_organization(self, **kwargs) -> GitHubResponse:
        """Stop a codespace for an organization user (HTTP POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_stop_in_organization" in method_map:
                result = method_map["codespaces_stop_in_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/stop-in-organization' (codespaces_stop_in_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def codespaces_update_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Update a codespace for the authenticated user (HTTP PATCH /user/codespaces/{codespace_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "codespaces_update_for_authenticated_user" in method_map:
                result = method_map["codespaces_update_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'codespaces/update-for-authenticated-user' (codespaces_update_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def copilot_add_copilot_seats_for_teams(self, **kwargs) -> GitHubResponse:
        """Add teams to the Copilot subscription for an organization (HTTP POST /orgs/{org}/copilot/billing/selected_teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "copilot_add_copilot_seats_for_teams" in method_map:
                result = method_map["copilot_add_copilot_seats_for_teams"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'copilot/add-copilot-seats-for-teams' (copilot_add_copilot_seats_for_teams). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def copilot_add_copilot_seats_for_users(self, **kwargs) -> GitHubResponse:
        """Add users to the Copilot subscription for an organization (HTTP POST /orgs/{org}/copilot/billing/selected_users)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "copilot_add_copilot_seats_for_users" in method_map:
                result = method_map["copilot_add_copilot_seats_for_users"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'copilot/add-copilot-seats-for-users' (copilot_add_copilot_seats_for_users). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def copilot_cancel_copilot_seat_assignment_for_teams(self, **kwargs) -> GitHubResponse:
        """Remove teams from the Copilot subscription for an organization (HTTP DELETE /orgs/{org}/copilot/billing/selected_teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "copilot_cancel_copilot_seat_assignment_for_teams" in method_map:
                result = method_map["copilot_cancel_copilot_seat_assignment_for_teams"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'copilot/cancel-copilot-seat-assignment-for-teams' (copilot_cancel_copilot_seat_assignment_for_teams). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def copilot_cancel_copilot_seat_assignment_for_users(self, **kwargs) -> GitHubResponse:
        """Remove users from the Copilot subscription for an organization (HTTP DELETE /orgs/{org}/copilot/billing/selected_users)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "copilot_cancel_copilot_seat_assignment_for_users" in method_map:
                result = method_map["copilot_cancel_copilot_seat_assignment_for_users"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'copilot/cancel-copilot-seat-assignment-for-users' (copilot_cancel_copilot_seat_assignment_for_users). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def copilot_copilot_metrics_for_organization(self, **kwargs) -> GitHubResponse:
        """Get Copilot metrics for an organization (HTTP GET /orgs/{org}/copilot/metrics)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "copilot_copilot_metrics_for_organization" in method_map:
                result = method_map["copilot_copilot_metrics_for_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'copilot/copilot-metrics-for-organization' (copilot_copilot_metrics_for_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def copilot_copilot_metrics_for_team(self, **kwargs) -> GitHubResponse:
        """Get Copilot metrics for a team (HTTP GET /orgs/{org}/team/{team_slug}/copilot/metrics)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "copilot_copilot_metrics_for_team" in method_map:
                result = method_map["copilot_copilot_metrics_for_team"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'copilot/copilot-metrics-for-team' (copilot_copilot_metrics_for_team). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def copilot_get_copilot_organization_details(self, **kwargs) -> GitHubResponse:
        """Get Copilot seat information and settings for an organization (HTTP GET /orgs/{org}/copilot/billing)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "copilot_get_copilot_organization_details" in method_map:
                result = method_map["copilot_get_copilot_organization_details"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'copilot/get-copilot-organization-details' (copilot_get_copilot_organization_details). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def copilot_get_copilot_seat_details_for_user(self, **kwargs) -> GitHubResponse:
        """Get Copilot seat assignment details for a user (HTTP GET /orgs/{org}/members/{username}/copilot)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "copilot_get_copilot_seat_details_for_user" in method_map:
                result = method_map["copilot_get_copilot_seat_details_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'copilot/get-copilot-seat-details-for-user' (copilot_get_copilot_seat_details_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def copilot_list_copilot_seats(self, **kwargs) -> GitHubResponse:
        """List all Copilot seat assignments for an organization (HTTP GET /orgs/{org}/copilot/billing/seats)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "copilot_list_copilot_seats" in method_map:
                result = method_map["copilot_list_copilot_seats"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'copilot/list-copilot-seats' (copilot_list_copilot_seats). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def credentials_revoke(self, **kwargs) -> GitHubResponse:
        """Revoke a list of credentials (HTTP POST /credentials/revoke)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "credentials_revoke" in method_map:
                result = method_map["credentials_revoke"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'credentials/revoke' (credentials_revoke). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_add_selected_repo_to_org_secret(self, **kwargs) -> GitHubResponse:
        """Add selected repository to an organization secret (HTTP PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_add_selected_repo_to_org_secret" in method_map:
                result = method_map["dependabot_add_selected_repo_to_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/add-selected-repo-to-org-secret' (dependabot_add_selected_repo_to_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_create_or_update_org_secret(self, **kwargs) -> GitHubResponse:
        """Create or update an organization secret (HTTP PUT /orgs/{org}/dependabot/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_create_or_update_org_secret" in method_map:
                result = method_map["dependabot_create_or_update_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/create-or-update-org-secret' (dependabot_create_or_update_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_create_or_update_repo_secret(self, **kwargs) -> GitHubResponse:
        """Create or update a repository secret (HTTP PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_create_or_update_repo_secret" in method_map:
                result = method_map["dependabot_create_or_update_repo_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/create-or-update-repo-secret' (dependabot_create_or_update_repo_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_delete_org_secret(self, **kwargs) -> GitHubResponse:
        """Delete an organization secret (HTTP DELETE /orgs/{org}/dependabot/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_delete_org_secret" in method_map:
                result = method_map["dependabot_delete_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/delete-org-secret' (dependabot_delete_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_delete_repo_secret(self, **kwargs) -> GitHubResponse:
        """Delete a repository secret (HTTP DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_delete_repo_secret" in method_map:
                result = method_map["dependabot_delete_repo_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/delete-repo-secret' (dependabot_delete_repo_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_get_alert(self, **kwargs) -> GitHubResponse:
        """Get a Dependabot alert (HTTP GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_get_alert" in method_map:
                result = method_map["dependabot_get_alert"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/get-alert' (dependabot_get_alert). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_get_org_public_key(self, **kwargs) -> GitHubResponse:
        """Get an organization public key (HTTP GET /orgs/{org}/dependabot/secrets/public-key)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_get_org_public_key" in method_map:
                result = method_map["dependabot_get_org_public_key"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/get-org-public-key' (dependabot_get_org_public_key). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_get_org_secret(self, **kwargs) -> GitHubResponse:
        """Get an organization secret (HTTP GET /orgs/{org}/dependabot/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_get_org_secret" in method_map:
                result = method_map["dependabot_get_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/get-org-secret' (dependabot_get_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_get_repo_public_key(self, **kwargs) -> GitHubResponse:
        """Get a repository public key (HTTP GET /repos/{owner}/{repo}/dependabot/secrets/public-key)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_get_repo_public_key" in method_map:
                result = method_map["dependabot_get_repo_public_key"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/get-repo-public-key' (dependabot_get_repo_public_key). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_get_repo_secret(self, **kwargs) -> GitHubResponse:
        """Get a repository secret (HTTP GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_get_repo_secret" in method_map:
                result = method_map["dependabot_get_repo_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/get-repo-secret' (dependabot_get_repo_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_list_alerts_for_enterprise(self, **kwargs) -> GitHubResponse:
        """List Dependabot alerts for an enterprise (HTTP GET /enterprises/{enterprise}/dependabot/alerts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_list_alerts_for_enterprise" in method_map:
                result = method_map["dependabot_list_alerts_for_enterprise"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/list-alerts-for-enterprise' (dependabot_list_alerts_for_enterprise). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_list_alerts_for_org(self, **kwargs) -> GitHubResponse:
        """List Dependabot alerts for an organization (HTTP GET /orgs/{org}/dependabot/alerts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_list_alerts_for_org" in method_map:
                result = method_map["dependabot_list_alerts_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/list-alerts-for-org' (dependabot_list_alerts_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_list_alerts_for_repo(self, **kwargs) -> GitHubResponse:
        """List Dependabot alerts for a repository (HTTP GET /repos/{owner}/{repo}/dependabot/alerts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_list_alerts_for_repo" in method_map:
                result = method_map["dependabot_list_alerts_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/list-alerts-for-repo' (dependabot_list_alerts_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_list_org_secrets(self, **kwargs) -> GitHubResponse:
        """List organization secrets (HTTP GET /orgs/{org}/dependabot/secrets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_list_org_secrets" in method_map:
                result = method_map["dependabot_list_org_secrets"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/list-org-secrets' (dependabot_list_org_secrets). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_list_repo_secrets(self, **kwargs) -> GitHubResponse:
        """List repository secrets (HTTP GET /repos/{owner}/{repo}/dependabot/secrets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_list_repo_secrets" in method_map:
                result = method_map["dependabot_list_repo_secrets"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/list-repo-secrets' (dependabot_list_repo_secrets). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_list_selected_repos_for_org_secret(self, **kwargs) -> GitHubResponse:
        """List selected repositories for an organization secret (HTTP GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_list_selected_repos_for_org_secret" in method_map:
                result = method_map["dependabot_list_selected_repos_for_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/list-selected-repos-for-org-secret' (dependabot_list_selected_repos_for_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_remove_selected_repo_from_org_secret(self, **kwargs) -> GitHubResponse:
        """Remove selected repository from an organization secret (HTTP DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_remove_selected_repo_from_org_secret" in method_map:
                result = method_map["dependabot_remove_selected_repo_from_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/remove-selected-repo-from-org-secret' (dependabot_remove_selected_repo_from_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_repository_access_for_org(self, **kwargs) -> GitHubResponse:
        """Lists the repositories Dependabot can access in an organization (HTTP GET /organizations/{org}/dependabot/repository-access)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_repository_access_for_org" in method_map:
                result = method_map["dependabot_repository_access_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/repository-access-for-org' (dependabot_repository_access_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_set_repository_access_default_level(self, **kwargs) -> GitHubResponse:
        """Set the default repository access level for Dependabot (HTTP PUT /organizations/{org}/dependabot/repository-access/default-level)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_set_repository_access_default_level" in method_map:
                result = method_map["dependabot_set_repository_access_default_level"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/set-repository-access-default-level' (dependabot_set_repository_access_default_level). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_set_selected_repos_for_org_secret(self, **kwargs) -> GitHubResponse:
        """Set selected repositories for an organization secret (HTTP PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_set_selected_repos_for_org_secret" in method_map:
                result = method_map["dependabot_set_selected_repos_for_org_secret"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/set-selected-repos-for-org-secret' (dependabot_set_selected_repos_for_org_secret). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_update_alert(self, **kwargs) -> GitHubResponse:
        """Update a Dependabot alert (HTTP PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_update_alert" in method_map:
                result = method_map["dependabot_update_alert"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/update-alert' (dependabot_update_alert). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependabot_update_repository_access_for_org(self, **kwargs) -> GitHubResponse:
        """Updates Dependabot's repository access list for an organization (HTTP PATCH /organizations/{org}/dependabot/repository-access)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependabot_update_repository_access_for_org" in method_map:
                result = method_map["dependabot_update_repository_access_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependabot/update-repository-access-for-org' (dependabot_update_repository_access_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependency_graph_create_repository_snapshot(self, **kwargs) -> GitHubResponse:
        """Create a snapshot of dependencies for a repository (HTTP POST /repos/{owner}/{repo}/dependency-graph/snapshots)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependency_graph_create_repository_snapshot" in method_map:
                result = method_map["dependency_graph_create_repository_snapshot"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependency-graph/create-repository-snapshot' (dependency_graph_create_repository_snapshot). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependency_graph_diff_range(self, **kwargs) -> GitHubResponse:
        """Get a diff of the dependencies between commits (HTTP GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependency_graph_diff_range" in method_map:
                result = method_map["dependency_graph_diff_range"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependency-graph/diff-range' (dependency_graph_diff_range). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def dependency_graph_export_sbom(self, **kwargs) -> GitHubResponse:
        """Export a software bill of materials (SBOM) for a repository. (HTTP GET /repos/{owner}/{repo}/dependency-graph/sbom)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "dependency_graph_export_sbom" in method_map:
                result = method_map["dependency_graph_export_sbom"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'dependency-graph/export-sbom' (dependency_graph_export_sbom). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def emojis_get(self, **kwargs) -> GitHubResponse:
        """Get emojis (HTTP GET /emojis)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "emojis_get" in method_map:
                result = method_map["emojis_get"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'emojis/get' (emojis_get). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def enterprise_team_memberships_add(self, **kwargs) -> GitHubResponse:
        """Add team member (HTTP PUT /enterprises/{enterprise}/teams/{enterprise-team}/memberships/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "enterprise_team_memberships_add" in method_map:
                result = method_map["enterprise_team_memberships_add"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'enterprise-team-memberships/add' (enterprise_team_memberships_add). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def enterprise_team_memberships_bulk_add(self, **kwargs) -> GitHubResponse:
        """Bulk add team members (HTTP POST /enterprises/{enterprise}/teams/{enterprise-team}/memberships/add)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "enterprise_team_memberships_bulk_add" in method_map:
                result = method_map["enterprise_team_memberships_bulk_add"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'enterprise-team-memberships/bulk-add' (enterprise_team_memberships_bulk_add). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def enterprise_team_memberships_bulk_remove(self, **kwargs) -> GitHubResponse:
        """Bulk remove team members (HTTP POST /enterprises/{enterprise}/teams/{enterprise-team}/memberships/remove)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "enterprise_team_memberships_bulk_remove" in method_map:
                result = method_map["enterprise_team_memberships_bulk_remove"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'enterprise-team-memberships/bulk-remove' (enterprise_team_memberships_bulk_remove). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def enterprise_team_memberships_get(self, **kwargs) -> GitHubResponse:
        """Get enterprise team membership (HTTP GET /enterprises/{enterprise}/teams/{enterprise-team}/memberships/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "enterprise_team_memberships_get" in method_map:
                result = method_map["enterprise_team_memberships_get"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'enterprise-team-memberships/get' (enterprise_team_memberships_get). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def enterprise_team_memberships_list(self, **kwargs) -> GitHubResponse:
        """List members in an enterprise team (HTTP GET /enterprises/{enterprise}/teams/{enterprise-team}/memberships)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "enterprise_team_memberships_list" in method_map:
                result = method_map["enterprise_team_memberships_list"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'enterprise-team-memberships/list' (enterprise_team_memberships_list). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def enterprise_team_memberships_remove(self, **kwargs) -> GitHubResponse:
        """Remove team membership (HTTP DELETE /enterprises/{enterprise}/teams/{enterprise-team}/memberships/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "enterprise_team_memberships_remove" in method_map:
                result = method_map["enterprise_team_memberships_remove"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'enterprise-team-memberships/remove' (enterprise_team_memberships_remove). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def enterprise_teams_create(self, **kwargs) -> GitHubResponse:
        """Create an enterprise team (HTTP POST /enterprises/{enterprise}/teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "enterprise_teams_create" in method_map:
                result = method_map["enterprise_teams_create"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'enterprise-teams/create' (enterprise_teams_create). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def enterprise_teams_delete(self, **kwargs) -> GitHubResponse:
        """Delete an enterprise team (HTTP DELETE /enterprises/{enterprise}/teams/{team_slug})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "enterprise_teams_delete" in method_map:
                result = method_map["enterprise_teams_delete"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'enterprise-teams/delete' (enterprise_teams_delete). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def enterprise_teams_get(self, **kwargs) -> GitHubResponse:
        """Get an enterprise team (HTTP GET /enterprises/{enterprise}/teams/{team_slug})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "enterprise_teams_get" in method_map:
                result = method_map["enterprise_teams_get"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'enterprise-teams/get' (enterprise_teams_get). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def enterprise_teams_list(self, **kwargs) -> GitHubResponse:
        """List enterprise teams (HTTP GET /enterprises/{enterprise}/teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "enterprise_teams_list" in method_map:
                result = method_map["enterprise_teams_list"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'enterprise-teams/list' (enterprise_teams_list). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def enterprise_teams_update(self, **kwargs) -> GitHubResponse:
        """Update an enterprise team (HTTP PATCH /enterprises/{enterprise}/teams/{team_slug})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "enterprise_teams_update" in method_map:
                result = method_map["enterprise_teams_update"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'enterprise-teams/update' (enterprise_teams_update). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_check_is_starred(self, **kwargs) -> GitHubResponse:
        """Check if a gist is starred (HTTP GET /gists/{gist_id}/star)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_check_is_starred" in method_map:
                result = method_map["gists_check_is_starred"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/check-is-starred' (gists_check_is_starred). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_create(self, **kwargs) -> GitHubResponse:
        """Create a gist (HTTP POST /gists)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_create" in method_map:
                result = method_map["gists_create"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/create' (gists_create). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_create_comment(self, **kwargs) -> GitHubResponse:
        """Create a gist comment (HTTP POST /gists/{gist_id}/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_create_comment" in method_map:
                result = method_map["gists_create_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/create-comment' (gists_create_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_delete(self, **kwargs) -> GitHubResponse:
        """Delete a gist (HTTP DELETE /gists/{gist_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_delete" in method_map:
                result = method_map["gists_delete"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/delete' (gists_delete). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_delete_comment(self, **kwargs) -> GitHubResponse:
        """Delete a gist comment (HTTP DELETE /gists/{gist_id}/comments/{comment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_delete_comment" in method_map:
                result = method_map["gists_delete_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/delete-comment' (gists_delete_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_fork(self, **kwargs) -> GitHubResponse:
        """Fork a gist (HTTP POST /gists/{gist_id}/forks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_fork" in method_map:
                result = method_map["gists_fork"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/fork' (gists_fork). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_get(self, **kwargs) -> GitHubResponse:
        """Get a gist (HTTP GET /gists/{gist_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_get" in method_map:
                result = method_map["gists_get"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/get' (gists_get). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_get_comment(self, **kwargs) -> GitHubResponse:
        """Get a gist comment (HTTP GET /gists/{gist_id}/comments/{comment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_get_comment" in method_map:
                result = method_map["gists_get_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/get-comment' (gists_get_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_get_revision(self, **kwargs) -> GitHubResponse:
        """Get a gist revision (HTTP GET /gists/{gist_id}/{sha})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_get_revision" in method_map:
                result = method_map["gists_get_revision"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/get-revision' (gists_get_revision). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_list(self, **kwargs) -> GitHubResponse:
        """List gists for the authenticated user (HTTP GET /gists)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_list" in method_map:
                result = method_map["gists_list"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/list' (gists_list). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_list_comments(self, **kwargs) -> GitHubResponse:
        """List gist comments (HTTP GET /gists/{gist_id}/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_list_comments" in method_map:
                result = method_map["gists_list_comments"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/list-comments' (gists_list_comments). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_list_commits(self, **kwargs) -> GitHubResponse:
        """List gist commits (HTTP GET /gists/{gist_id}/commits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_list_commits" in method_map:
                result = method_map["gists_list_commits"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/list-commits' (gists_list_commits). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_list_for_user(self, **kwargs) -> GitHubResponse:
        """List gists for a user (HTTP GET /users/{username}/gists)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_list_for_user" in method_map:
                result = method_map["gists_list_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/list-for-user' (gists_list_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_list_forks(self, **kwargs) -> GitHubResponse:
        """List gist forks (HTTP GET /gists/{gist_id}/forks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_list_forks" in method_map:
                result = method_map["gists_list_forks"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/list-forks' (gists_list_forks). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_list_public(self, **kwargs) -> GitHubResponse:
        """List public gists (HTTP GET /gists/public)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_list_public" in method_map:
                result = method_map["gists_list_public"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/list-public' (gists_list_public). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_list_starred(self, **kwargs) -> GitHubResponse:
        """List starred gists (HTTP GET /gists/starred)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_list_starred" in method_map:
                result = method_map["gists_list_starred"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/list-starred' (gists_list_starred). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_star(self, **kwargs) -> GitHubResponse:
        """Star a gist (HTTP PUT /gists/{gist_id}/star)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_star" in method_map:
                result = method_map["gists_star"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/star' (gists_star). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_unstar(self, **kwargs) -> GitHubResponse:
        """Unstar a gist (HTTP DELETE /gists/{gist_id}/star)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_unstar" in method_map:
                result = method_map["gists_unstar"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/unstar' (gists_unstar). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_update(self, **kwargs) -> GitHubResponse:
        """Update a gist (HTTP PATCH /gists/{gist_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_update" in method_map:
                result = method_map["gists_update"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/update' (gists_update). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gists_update_comment(self, **kwargs) -> GitHubResponse:
        """Update a gist comment (HTTP PATCH /gists/{gist_id}/comments/{comment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gists_update_comment" in method_map:
                result = method_map["gists_update_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gists/update-comment' (gists_update_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def git_create_blob(self, **kwargs) -> GitHubResponse:
        """Create a blob (HTTP POST /repos/{owner}/{repo}/git/blobs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "git_create_blob" in method_map:
                result = method_map["git_create_blob"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'git/create-blob' (git_create_blob). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def git_create_commit(self, **kwargs) -> GitHubResponse:
        """Create a commit (HTTP POST /repos/{owner}/{repo}/git/commits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "git_create_commit" in method_map:
                result = method_map["git_create_commit"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'git/create-commit' (git_create_commit). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def git_create_ref(self, **kwargs) -> GitHubResponse:
        """Create a reference (HTTP POST /repos/{owner}/{repo}/git/refs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "git_create_ref" in method_map:
                result = method_map["git_create_ref"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'git/create-ref' (git_create_ref). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def git_create_tag(self, **kwargs) -> GitHubResponse:
        """Create a tag object (HTTP POST /repos/{owner}/{repo}/git/tags)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "git_create_tag" in method_map:
                result = method_map["git_create_tag"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'git/create-tag' (git_create_tag). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def git_create_tree(self, **kwargs) -> GitHubResponse:
        """Create a tree (HTTP POST /repos/{owner}/{repo}/git/trees)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "git_create_tree" in method_map:
                result = method_map["git_create_tree"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'git/create-tree' (git_create_tree). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def git_delete_ref(self, **kwargs) -> GitHubResponse:
        """Delete a reference (HTTP DELETE /repos/{owner}/{repo}/git/refs/{ref})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "git_delete_ref" in method_map:
                result = method_map["git_delete_ref"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'git/delete-ref' (git_delete_ref). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def git_get_blob(self, **kwargs) -> GitHubResponse:
        """Get a blob (HTTP GET /repos/{owner}/{repo}/git/blobs/{file_sha})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "git_get_blob" in method_map:
                result = method_map["git_get_blob"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'git/get-blob' (git_get_blob). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def git_get_commit(self, **kwargs) -> GitHubResponse:
        """Get a commit object (HTTP GET /repos/{owner}/{repo}/git/commits/{commit_sha})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "git_get_commit" in method_map:
                result = method_map["git_get_commit"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'git/get-commit' (git_get_commit). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def git_get_ref(self, **kwargs) -> GitHubResponse:
        """Get a reference (HTTP GET /repos/{owner}/{repo}/git/ref/{ref})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "git_get_ref" in method_map:
                result = method_map["git_get_ref"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'git/get-ref' (git_get_ref). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def git_get_tag(self, **kwargs) -> GitHubResponse:
        """Get a tag (HTTP GET /repos/{owner}/{repo}/git/tags/{tag_sha})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "git_get_tag" in method_map:
                result = method_map["git_get_tag"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'git/get-tag' (git_get_tag). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def git_get_tree(self, **kwargs) -> GitHubResponse:
        """Get a tree (HTTP GET /repos/{owner}/{repo}/git/trees/{tree_sha})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "git_get_tree" in method_map:
                result = method_map["git_get_tree"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'git/get-tree' (git_get_tree). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def git_list_matching_refs(self, **kwargs) -> GitHubResponse:
        """List matching references (HTTP GET /repos/{owner}/{repo}/git/matching-refs/{ref})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "git_list_matching_refs" in method_map:
                result = method_map["git_list_matching_refs"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'git/list-matching-refs' (git_list_matching_refs). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def git_update_ref(self, **kwargs) -> GitHubResponse:
        """Update a reference (HTTP PATCH /repos/{owner}/{repo}/git/refs/{ref})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "git_update_ref" in method_map:
                result = method_map["git_update_ref"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'git/update-ref' (git_update_ref). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gitignore_get_all_templates(self, **kwargs) -> GitHubResponse:
        """Get all gitignore templates (HTTP GET /gitignore/templates)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gitignore_get_all_templates" in method_map:
                result = method_map["gitignore_get_all_templates"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gitignore/get-all-templates' (gitignore_get_all_templates). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def gitignore_get_template(self, **kwargs) -> GitHubResponse:
        """Get a gitignore template (HTTP GET /gitignore/templates/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "gitignore_get_template" in method_map:
                result = method_map["gitignore_get_template"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'gitignore/get-template' (gitignore_get_template). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def hosted_compute_create_network_configuration_for_org(self, **kwargs) -> GitHubResponse:
        """Create a hosted compute network configuration for an organization (HTTP POST /orgs/{org}/settings/network-configurations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "hosted_compute_create_network_configuration_for_org" in method_map:
                result = method_map["hosted_compute_create_network_configuration_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'hosted-compute/create-network-configuration-for-org' (hosted_compute_create_network_configuration_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def hosted_compute_delete_network_configuration_from_org(self, **kwargs) -> GitHubResponse:
        """Delete a hosted compute network configuration from an organization (HTTP DELETE /orgs/{org}/settings/network-configurations/{network_configuration_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "hosted_compute_delete_network_configuration_from_org" in method_map:
                result = method_map["hosted_compute_delete_network_configuration_from_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'hosted-compute/delete-network-configuration-from-org' (hosted_compute_delete_network_configuration_from_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def hosted_compute_get_network_configuration_for_org(self, **kwargs) -> GitHubResponse:
        """Get a hosted compute network configuration for an organization (HTTP GET /orgs/{org}/settings/network-configurations/{network_configuration_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "hosted_compute_get_network_configuration_for_org" in method_map:
                result = method_map["hosted_compute_get_network_configuration_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'hosted-compute/get-network-configuration-for-org' (hosted_compute_get_network_configuration_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def hosted_compute_get_network_settings_for_org(self, **kwargs) -> GitHubResponse:
        """Get a hosted compute network settings resource for an organization (HTTP GET /orgs/{org}/settings/network-settings/{network_settings_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "hosted_compute_get_network_settings_for_org" in method_map:
                result = method_map["hosted_compute_get_network_settings_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'hosted-compute/get-network-settings-for-org' (hosted_compute_get_network_settings_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def hosted_compute_list_network_configurations_for_org(self, **kwargs) -> GitHubResponse:
        """List hosted compute network configurations for an organization (HTTP GET /orgs/{org}/settings/network-configurations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "hosted_compute_list_network_configurations_for_org" in method_map:
                result = method_map["hosted_compute_list_network_configurations_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'hosted-compute/list-network-configurations-for-org' (hosted_compute_list_network_configurations_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def hosted_compute_update_network_configuration_for_org(self, **kwargs) -> GitHubResponse:
        """Update a hosted compute network configuration for an organization (HTTP PATCH /orgs/{org}/settings/network-configurations/{network_configuration_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "hosted_compute_update_network_configuration_for_org" in method_map:
                result = method_map["hosted_compute_update_network_configuration_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'hosted-compute/update-network-configuration-for-org' (hosted_compute_update_network_configuration_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def interactions_get_restrictions_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get interaction restrictions for your public repositories (HTTP GET /user/interaction-limits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "interactions_get_restrictions_for_authenticated_user" in method_map:
                result = method_map["interactions_get_restrictions_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'interactions/get-restrictions-for-authenticated-user' (interactions_get_restrictions_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def interactions_get_restrictions_for_org(self, **kwargs) -> GitHubResponse:
        """Get interaction restrictions for an organization (HTTP GET /orgs/{org}/interaction-limits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "interactions_get_restrictions_for_org" in method_map:
                result = method_map["interactions_get_restrictions_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'interactions/get-restrictions-for-org' (interactions_get_restrictions_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def interactions_get_restrictions_for_repo(self, **kwargs) -> GitHubResponse:
        """Get interaction restrictions for a repository (HTTP GET /repos/{owner}/{repo}/interaction-limits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "interactions_get_restrictions_for_repo" in method_map:
                result = method_map["interactions_get_restrictions_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'interactions/get-restrictions-for-repo' (interactions_get_restrictions_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def interactions_remove_restrictions_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Remove interaction restrictions from your public repositories (HTTP DELETE /user/interaction-limits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "interactions_remove_restrictions_for_authenticated_user" in method_map:
                result = method_map["interactions_remove_restrictions_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'interactions/remove-restrictions-for-authenticated-user' (interactions_remove_restrictions_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def interactions_remove_restrictions_for_org(self, **kwargs) -> GitHubResponse:
        """Remove interaction restrictions for an organization (HTTP DELETE /orgs/{org}/interaction-limits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "interactions_remove_restrictions_for_org" in method_map:
                result = method_map["interactions_remove_restrictions_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'interactions/remove-restrictions-for-org' (interactions_remove_restrictions_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def interactions_remove_restrictions_for_repo(self, **kwargs) -> GitHubResponse:
        """Remove interaction restrictions for a repository (HTTP DELETE /repos/{owner}/{repo}/interaction-limits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "interactions_remove_restrictions_for_repo" in method_map:
                result = method_map["interactions_remove_restrictions_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'interactions/remove-restrictions-for-repo' (interactions_remove_restrictions_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def interactions_set_restrictions_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Set interaction restrictions for your public repositories (HTTP PUT /user/interaction-limits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "interactions_set_restrictions_for_authenticated_user" in method_map:
                result = method_map["interactions_set_restrictions_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'interactions/set-restrictions-for-authenticated-user' (interactions_set_restrictions_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def interactions_set_restrictions_for_org(self, **kwargs) -> GitHubResponse:
        """Set interaction restrictions for an organization (HTTP PUT /orgs/{org}/interaction-limits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "interactions_set_restrictions_for_org" in method_map:
                result = method_map["interactions_set_restrictions_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'interactions/set-restrictions-for-org' (interactions_set_restrictions_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def interactions_set_restrictions_for_repo(self, **kwargs) -> GitHubResponse:
        """Set interaction restrictions for a repository (HTTP PUT /repos/{owner}/{repo}/interaction-limits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "interactions_set_restrictions_for_repo" in method_map:
                result = method_map["interactions_set_restrictions_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'interactions/set-restrictions-for-repo' (interactions_set_restrictions_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_add_assignees(self, **kwargs) -> GitHubResponse:
        """Add assignees to an issue (HTTP POST /repos/{owner}/{repo}/issues/{issue_number}/assignees)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_add_assignees" in method_map:
                result = method_map["issues_add_assignees"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/add-assignees' (issues_add_assignees). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_add_blocked_by_dependency(self, **kwargs) -> GitHubResponse:
        """Add a dependency an issue is blocked by (HTTP POST /repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocked_by)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_add_blocked_by_dependency" in method_map:
                result = method_map["issues_add_blocked_by_dependency"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/add-blocked-by-dependency' (issues_add_blocked_by_dependency). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_add_labels(self, **kwargs) -> GitHubResponse:
        """Add labels to an issue (HTTP POST /repos/{owner}/{repo}/issues/{issue_number}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_add_labels" in method_map:
                result = method_map["issues_add_labels"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/add-labels' (issues_add_labels). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_add_sub_issue(self, **kwargs) -> GitHubResponse:
        """Add sub-issue (HTTP POST /repos/{owner}/{repo}/issues/{issue_number}/sub_issues)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_add_sub_issue" in method_map:
                result = method_map["issues_add_sub_issue"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/add-sub-issue' (issues_add_sub_issue). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_check_user_can_be_assigned(self, **kwargs) -> GitHubResponse:
        """Check if a user can be assigned (HTTP GET /repos/{owner}/{repo}/assignees/{assignee})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_check_user_can_be_assigned" in method_map:
                result = method_map["issues_check_user_can_be_assigned"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/check-user-can-be-assigned' (issues_check_user_can_be_assigned). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_check_user_can_be_assigned_to_issue(self, **kwargs) -> GitHubResponse:
        """Check if a user can be assigned to a issue (HTTP GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_check_user_can_be_assigned_to_issue" in method_map:
                result = method_map["issues_check_user_can_be_assigned_to_issue"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/check-user-can-be-assigned-to-issue' (issues_check_user_can_be_assigned_to_issue). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_create(self, **kwargs) -> GitHubResponse:
        """Create an issue (HTTP POST /repos/{owner}/{repo}/issues)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_create" in method_map:
                result = method_map["issues_create"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/create' (issues_create). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_create_comment(self, **kwargs) -> GitHubResponse:
        """Create an issue comment (HTTP POST /repos/{owner}/{repo}/issues/{issue_number}/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_create_comment" in method_map:
                result = method_map["issues_create_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/create-comment' (issues_create_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_create_label(self, **kwargs) -> GitHubResponse:
        """Create a label (HTTP POST /repos/{owner}/{repo}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_create_label" in method_map:
                result = method_map["issues_create_label"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/create-label' (issues_create_label). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_create_milestone(self, **kwargs) -> GitHubResponse:
        """Create a milestone (HTTP POST /repos/{owner}/{repo}/milestones)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_create_milestone" in method_map:
                result = method_map["issues_create_milestone"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/create-milestone' (issues_create_milestone). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_delete_comment(self, **kwargs) -> GitHubResponse:
        """Delete an issue comment (HTTP DELETE /repos/{owner}/{repo}/issues/comments/{comment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_delete_comment" in method_map:
                result = method_map["issues_delete_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/delete-comment' (issues_delete_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_delete_label(self, **kwargs) -> GitHubResponse:
        """Delete a label (HTTP DELETE /repos/{owner}/{repo}/labels/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_delete_label" in method_map:
                result = method_map["issues_delete_label"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/delete-label' (issues_delete_label). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_delete_milestone(self, **kwargs) -> GitHubResponse:
        """Delete a milestone (HTTP DELETE /repos/{owner}/{repo}/milestones/{milestone_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_delete_milestone" in method_map:
                result = method_map["issues_delete_milestone"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/delete-milestone' (issues_delete_milestone). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_get(self, **kwargs) -> GitHubResponse:
        """Get an issue (HTTP GET /repos/{owner}/{repo}/issues/{issue_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_get" in method_map:
                result = method_map["issues_get"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/get' (issues_get). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_get_comment(self, **kwargs) -> GitHubResponse:
        """Get an issue comment (HTTP GET /repos/{owner}/{repo}/issues/comments/{comment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_get_comment" in method_map:
                result = method_map["issues_get_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/get-comment' (issues_get_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_get_event(self, **kwargs) -> GitHubResponse:
        """Get an issue event (HTTP GET /repos/{owner}/{repo}/issues/events/{event_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_get_event" in method_map:
                result = method_map["issues_get_event"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/get-event' (issues_get_event). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_get_label(self, **kwargs) -> GitHubResponse:
        """Get a label (HTTP GET /repos/{owner}/{repo}/labels/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_get_label" in method_map:
                result = method_map["issues_get_label"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/get-label' (issues_get_label). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_get_milestone(self, **kwargs) -> GitHubResponse:
        """Get a milestone (HTTP GET /repos/{owner}/{repo}/milestones/{milestone_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_get_milestone" in method_map:
                result = method_map["issues_get_milestone"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/get-milestone' (issues_get_milestone). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_get_parent(self, **kwargs) -> GitHubResponse:
        """Get parent issue (HTTP GET /repos/{owner}/{repo}/issues/{issue_number}/parent)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_get_parent" in method_map:
                result = method_map["issues_get_parent"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/get-parent' (issues_get_parent). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list(self, **kwargs) -> GitHubResponse:
        """List issues assigned to the authenticated user (HTTP GET /issues)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list" in method_map:
                result = method_map["issues_list"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list' (issues_list). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_assignees(self, **kwargs) -> GitHubResponse:
        """List assignees (HTTP GET /repos/{owner}/{repo}/assignees)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_assignees" in method_map:
                result = method_map["issues_list_assignees"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-assignees' (issues_list_assignees). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_comments(self, **kwargs) -> GitHubResponse:
        """List issue comments (HTTP GET /repos/{owner}/{repo}/issues/{issue_number}/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_comments" in method_map:
                result = method_map["issues_list_comments"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-comments' (issues_list_comments). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_comments_for_repo(self, **kwargs) -> GitHubResponse:
        """List issue comments for a repository (HTTP GET /repos/{owner}/{repo}/issues/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_comments_for_repo" in method_map:
                result = method_map["issues_list_comments_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-comments-for-repo' (issues_list_comments_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_dependencies_blocked_by(self, **kwargs) -> GitHubResponse:
        """List dependencies an issue is blocked by (HTTP GET /repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocked_by)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_dependencies_blocked_by" in method_map:
                result = method_map["issues_list_dependencies_blocked_by"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-dependencies-blocked-by' (issues_list_dependencies_blocked_by). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_dependencies_blocking(self, **kwargs) -> GitHubResponse:
        """List dependencies an issue is blocking (HTTP GET /repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocking)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_dependencies_blocking" in method_map:
                result = method_map["issues_list_dependencies_blocking"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-dependencies-blocking' (issues_list_dependencies_blocking). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_events(self, **kwargs) -> GitHubResponse:
        """List issue events (HTTP GET /repos/{owner}/{repo}/issues/{issue_number}/events)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_events" in method_map:
                result = method_map["issues_list_events"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-events' (issues_list_events). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_events_for_repo(self, **kwargs) -> GitHubResponse:
        """List issue events for a repository (HTTP GET /repos/{owner}/{repo}/issues/events)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_events_for_repo" in method_map:
                result = method_map["issues_list_events_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-events-for-repo' (issues_list_events_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_events_for_timeline(self, **kwargs) -> GitHubResponse:
        """List timeline events for an issue (HTTP GET /repos/{owner}/{repo}/issues/{issue_number}/timeline)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_events_for_timeline" in method_map:
                result = method_map["issues_list_events_for_timeline"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-events-for-timeline' (issues_list_events_for_timeline). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List user account issues assigned to the authenticated user (HTTP GET /user/issues)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_for_authenticated_user" in method_map:
                result = method_map["issues_list_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-for-authenticated-user' (issues_list_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_for_org(self, **kwargs) -> GitHubResponse:
        """List organization issues assigned to the authenticated user (HTTP GET /orgs/{org}/issues)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_for_org" in method_map:
                result = method_map["issues_list_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-for-org' (issues_list_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_for_repo(self, **kwargs) -> GitHubResponse:
        """List repository issues (HTTP GET /repos/{owner}/{repo}/issues)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_for_repo" in method_map:
                result = method_map["issues_list_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-for-repo' (issues_list_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_labels_for_milestone(self, **kwargs) -> GitHubResponse:
        """List labels for issues in a milestone (HTTP GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_labels_for_milestone" in method_map:
                result = method_map["issues_list_labels_for_milestone"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-labels-for-milestone' (issues_list_labels_for_milestone). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_labels_for_repo(self, **kwargs) -> GitHubResponse:
        """List labels for a repository (HTTP GET /repos/{owner}/{repo}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_labels_for_repo" in method_map:
                result = method_map["issues_list_labels_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-labels-for-repo' (issues_list_labels_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_labels_on_issue(self, **kwargs) -> GitHubResponse:
        """List labels for an issue (HTTP GET /repos/{owner}/{repo}/issues/{issue_number}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_labels_on_issue" in method_map:
                result = method_map["issues_list_labels_on_issue"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-labels-on-issue' (issues_list_labels_on_issue). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_milestones(self, **kwargs) -> GitHubResponse:
        """List milestones (HTTP GET /repos/{owner}/{repo}/milestones)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_milestones" in method_map:
                result = method_map["issues_list_milestones"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-milestones' (issues_list_milestones). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_list_sub_issues(self, **kwargs) -> GitHubResponse:
        """List sub-issues (HTTP GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_list_sub_issues" in method_map:
                result = method_map["issues_list_sub_issues"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/list-sub-issues' (issues_list_sub_issues). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_lock(self, **kwargs) -> GitHubResponse:
        """Lock an issue (HTTP PUT /repos/{owner}/{repo}/issues/{issue_number}/lock)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_lock" in method_map:
                result = method_map["issues_lock"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/lock' (issues_lock). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_remove_all_labels(self, **kwargs) -> GitHubResponse:
        """Remove all labels from an issue (HTTP DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_remove_all_labels" in method_map:
                result = method_map["issues_remove_all_labels"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/remove-all-labels' (issues_remove_all_labels). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_remove_assignees(self, **kwargs) -> GitHubResponse:
        """Remove assignees from an issue (HTTP DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_remove_assignees" in method_map:
                result = method_map["issues_remove_assignees"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/remove-assignees' (issues_remove_assignees). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_remove_dependency_blocked_by(self, **kwargs) -> GitHubResponse:
        """Remove dependency an issue is blocked by (HTTP DELETE /repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocked_by/{issue_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_remove_dependency_blocked_by" in method_map:
                result = method_map["issues_remove_dependency_blocked_by"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/remove-dependency-blocked-by' (issues_remove_dependency_blocked_by). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_remove_label(self, **kwargs) -> GitHubResponse:
        """Remove a label from an issue (HTTP DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_remove_label" in method_map:
                result = method_map["issues_remove_label"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/remove-label' (issues_remove_label). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_remove_sub_issue(self, **kwargs) -> GitHubResponse:
        """Remove sub-issue (HTTP DELETE /repos/{owner}/{repo}/issues/{issue_number}/sub_issue)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_remove_sub_issue" in method_map:
                result = method_map["issues_remove_sub_issue"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/remove-sub-issue' (issues_remove_sub_issue). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_reprioritize_sub_issue(self, **kwargs) -> GitHubResponse:
        """Reprioritize sub-issue (HTTP PATCH /repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_reprioritize_sub_issue" in method_map:
                result = method_map["issues_reprioritize_sub_issue"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/reprioritize-sub-issue' (issues_reprioritize_sub_issue). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_set_labels(self, **kwargs) -> GitHubResponse:
        """Set labels for an issue (HTTP PUT /repos/{owner}/{repo}/issues/{issue_number}/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_set_labels" in method_map:
                result = method_map["issues_set_labels"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/set-labels' (issues_set_labels). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_unlock(self, **kwargs) -> GitHubResponse:
        """Unlock an issue (HTTP DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_unlock" in method_map:
                result = method_map["issues_unlock"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/unlock' (issues_unlock). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_update(self, **kwargs) -> GitHubResponse:
        """Update an issue (HTTP PATCH /repos/{owner}/{repo}/issues/{issue_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_update" in method_map:
                result = method_map["issues_update"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/update' (issues_update). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_update_comment(self, **kwargs) -> GitHubResponse:
        """Update an issue comment (HTTP PATCH /repos/{owner}/{repo}/issues/comments/{comment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_update_comment" in method_map:
                result = method_map["issues_update_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/update-comment' (issues_update_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_update_label(self, **kwargs) -> GitHubResponse:
        """Update a label (HTTP PATCH /repos/{owner}/{repo}/labels/{name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_update_label" in method_map:
                result = method_map["issues_update_label"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/update-label' (issues_update_label). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def issues_update_milestone(self, **kwargs) -> GitHubResponse:
        """Update a milestone (HTTP PATCH /repos/{owner}/{repo}/milestones/{milestone_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "issues_update_milestone" in method_map:
                result = method_map["issues_update_milestone"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'issues/update-milestone' (issues_update_milestone). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def licenses_get(self, **kwargs) -> GitHubResponse:
        """Get a license (HTTP GET /licenses/{license})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "licenses_get" in method_map:
                result = method_map["licenses_get"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'licenses/get' (licenses_get). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def licenses_get_all_commonly_used(self, **kwargs) -> GitHubResponse:
        """Get all commonly used licenses (HTTP GET /licenses)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "licenses_get_all_commonly_used" in method_map:
                result = method_map["licenses_get_all_commonly_used"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'licenses/get-all-commonly-used' (licenses_get_all_commonly_used). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def licenses_get_for_repo(self, **kwargs) -> GitHubResponse:
        """Get the license for a repository (HTTP GET /repos/{owner}/{repo}/license)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "licenses_get_for_repo" in method_map:
                result = method_map["licenses_get_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'licenses/get-for-repo' (licenses_get_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def markdown_render(self, **kwargs) -> GitHubResponse:
        """Render a Markdown document (HTTP POST /markdown)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "markdown_render" in method_map:
                result = method_map["markdown_render"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'markdown/render' (markdown_render). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def markdown_render_raw(self, **kwargs) -> GitHubResponse:
        """Render a Markdown document in raw mode (HTTP POST /markdown/raw)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "markdown_render_raw" in method_map:
                result = method_map["markdown_render_raw"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'markdown/render-raw' (markdown_render_raw). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def meta_get(self, **kwargs) -> GitHubResponse:
        """Get GitHub meta information (HTTP GET /meta)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "meta_get" in method_map:
                result = method_map["meta_get"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'meta/get' (meta_get). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def meta_get_all_versions(self, **kwargs) -> GitHubResponse:
        """Get all API versions (HTTP GET /versions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "meta_get_all_versions" in method_map:
                result = method_map["meta_get_all_versions"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'meta/get-all-versions' (meta_get_all_versions). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def meta_get_octocat(self, **kwargs) -> GitHubResponse:
        """Get Octocat (HTTP GET /octocat)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "meta_get_octocat" in method_map:
                result = method_map["meta_get_octocat"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'meta/get-octocat' (meta_get_octocat). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def meta_get_zen(self, **kwargs) -> GitHubResponse:
        """Get the Zen of GitHub (HTTP GET /zen)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "meta_get_zen" in method_map:
                result = method_map["meta_get_zen"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'meta/get-zen' (meta_get_zen). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def meta_root(self, **kwargs) -> GitHubResponse:
        """GitHub API Root (HTTP GET /)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "meta_root" in method_map:
                result = method_map["meta_root"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'meta/root' (meta_root). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_cancel_import(self, **kwargs) -> GitHubResponse:
        """Cancel an import (HTTP DELETE /repos/{owner}/{repo}/import)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_cancel_import" in method_map:
                result = method_map["migrations_cancel_import"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/cancel-import' (migrations_cancel_import). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_delete_archive_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Delete a user migration archive (HTTP DELETE /user/migrations/{migration_id}/archive)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_delete_archive_for_authenticated_user" in method_map:
                result = method_map["migrations_delete_archive_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/delete-archive-for-authenticated-user' (migrations_delete_archive_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_delete_archive_for_org(self, **kwargs) -> GitHubResponse:
        """Delete an organization migration archive (HTTP DELETE /orgs/{org}/migrations/{migration_id}/archive)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_delete_archive_for_org" in method_map:
                result = method_map["migrations_delete_archive_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/delete-archive-for-org' (migrations_delete_archive_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_download_archive_for_org(self, **kwargs) -> GitHubResponse:
        """Download an organization migration archive (HTTP GET /orgs/{org}/migrations/{migration_id}/archive)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_download_archive_for_org" in method_map:
                result = method_map["migrations_download_archive_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/download-archive-for-org' (migrations_download_archive_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_get_archive_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Download a user migration archive (HTTP GET /user/migrations/{migration_id}/archive)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_get_archive_for_authenticated_user" in method_map:
                result = method_map["migrations_get_archive_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/get-archive-for-authenticated-user' (migrations_get_archive_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_get_commit_authors(self, **kwargs) -> GitHubResponse:
        """Get commit authors (HTTP GET /repos/{owner}/{repo}/import/authors)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_get_commit_authors" in method_map:
                result = method_map["migrations_get_commit_authors"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/get-commit-authors' (migrations_get_commit_authors). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_get_import_status(self, **kwargs) -> GitHubResponse:
        """Get an import status (HTTP GET /repos/{owner}/{repo}/import)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_get_import_status" in method_map:
                result = method_map["migrations_get_import_status"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/get-import-status' (migrations_get_import_status). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_get_large_files(self, **kwargs) -> GitHubResponse:
        """Get large files (HTTP GET /repos/{owner}/{repo}/import/large_files)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_get_large_files" in method_map:
                result = method_map["migrations_get_large_files"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/get-large-files' (migrations_get_large_files). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_get_status_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get a user migration status (HTTP GET /user/migrations/{migration_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_get_status_for_authenticated_user" in method_map:
                result = method_map["migrations_get_status_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/get-status-for-authenticated-user' (migrations_get_status_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_get_status_for_org(self, **kwargs) -> GitHubResponse:
        """Get an organization migration status (HTTP GET /orgs/{org}/migrations/{migration_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_get_status_for_org" in method_map:
                result = method_map["migrations_get_status_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/get-status-for-org' (migrations_get_status_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_list_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List user migrations (HTTP GET /user/migrations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_list_for_authenticated_user" in method_map:
                result = method_map["migrations_list_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/list-for-authenticated-user' (migrations_list_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_list_for_org(self, **kwargs) -> GitHubResponse:
        """List organization migrations (HTTP GET /orgs/{org}/migrations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_list_for_org" in method_map:
                result = method_map["migrations_list_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/list-for-org' (migrations_list_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_list_repos_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List repositories for a user migration (HTTP GET /user/migrations/{migration_id}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_list_repos_for_authenticated_user" in method_map:
                result = method_map["migrations_list_repos_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/list-repos-for-authenticated-user' (migrations_list_repos_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_list_repos_for_org(self, **kwargs) -> GitHubResponse:
        """List repositories in an organization migration (HTTP GET /orgs/{org}/migrations/{migration_id}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_list_repos_for_org" in method_map:
                result = method_map["migrations_list_repos_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/list-repos-for-org' (migrations_list_repos_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_map_commit_author(self, **kwargs) -> GitHubResponse:
        """Map a commit author (HTTP PATCH /repos/{owner}/{repo}/import/authors/{author_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_map_commit_author" in method_map:
                result = method_map["migrations_map_commit_author"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/map-commit-author' (migrations_map_commit_author). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_set_lfs_preference(self, **kwargs) -> GitHubResponse:
        """Update Git LFS preference (HTTP PATCH /repos/{owner}/{repo}/import/lfs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_set_lfs_preference" in method_map:
                result = method_map["migrations_set_lfs_preference"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/set-lfs-preference' (migrations_set_lfs_preference). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_start_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Start a user migration (HTTP POST /user/migrations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_start_for_authenticated_user" in method_map:
                result = method_map["migrations_start_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/start-for-authenticated-user' (migrations_start_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_start_for_org(self, **kwargs) -> GitHubResponse:
        """Start an organization migration (HTTP POST /orgs/{org}/migrations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_start_for_org" in method_map:
                result = method_map["migrations_start_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/start-for-org' (migrations_start_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_start_import(self, **kwargs) -> GitHubResponse:
        """Start an import (HTTP PUT /repos/{owner}/{repo}/import)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_start_import" in method_map:
                result = method_map["migrations_start_import"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/start-import' (migrations_start_import). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_unlock_repo_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Unlock a user repository (HTTP DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_unlock_repo_for_authenticated_user" in method_map:
                result = method_map["migrations_unlock_repo_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/unlock-repo-for-authenticated-user' (migrations_unlock_repo_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_unlock_repo_for_org(self, **kwargs) -> GitHubResponse:
        """Unlock an organization repository (HTTP DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_unlock_repo_for_org" in method_map:
                result = method_map["migrations_unlock_repo_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/unlock-repo-for-org' (migrations_unlock_repo_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def migrations_update_import(self, **kwargs) -> GitHubResponse:
        """Update an import (HTTP PATCH /repos/{owner}/{repo}/import)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "migrations_update_import" in method_map:
                result = method_map["migrations_update_import"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'migrations/update-import' (migrations_update_import). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def oidc_get_oidc_custom_sub_template_for_org(self, **kwargs) -> GitHubResponse:
        """Get the customization template for an OIDC subject claim for an organization (HTTP GET /orgs/{org}/actions/oidc/customization/sub)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "oidc_get_oidc_custom_sub_template_for_org" in method_map:
                result = method_map["oidc_get_oidc_custom_sub_template_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'oidc/get-oidc-custom-sub-template-for-org' (oidc_get_oidc_custom_sub_template_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def oidc_update_oidc_custom_sub_template_for_org(self, **kwargs) -> GitHubResponse:
        """Set the customization template for an OIDC subject claim for an organization (HTTP PUT /orgs/{org}/actions/oidc/customization/sub)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "oidc_update_oidc_custom_sub_template_for_org" in method_map:
                result = method_map["oidc_update_oidc_custom_sub_template_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'oidc/update-oidc-custom-sub-template-for-org' (oidc_update_oidc_custom_sub_template_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_add_security_manager_team(self, **kwargs) -> GitHubResponse:
        """Add a security manager team (HTTP PUT /orgs/{org}/security-managers/teams/{team_slug})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_add_security_manager_team" in method_map:
                result = method_map["orgs_add_security_manager_team"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/add-security-manager-team' (orgs_add_security_manager_team). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_assign_team_to_org_role(self, **kwargs) -> GitHubResponse:
        """Assign an organization role to a team (HTTP PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_assign_team_to_org_role" in method_map:
                result = method_map["orgs_assign_team_to_org_role"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/assign-team-to-org-role' (orgs_assign_team_to_org_role). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_assign_user_to_org_role(self, **kwargs) -> GitHubResponse:
        """Assign an organization role to a user (HTTP PUT /orgs/{org}/organization-roles/users/{username}/{role_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_assign_user_to_org_role" in method_map:
                result = method_map["orgs_assign_user_to_org_role"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/assign-user-to-org-role' (orgs_assign_user_to_org_role). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_block_user(self, **kwargs) -> GitHubResponse:
        """Block a user from an organization (HTTP PUT /orgs/{org}/blocks/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_block_user" in method_map:
                result = method_map["orgs_block_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/block-user' (orgs_block_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_cancel_invitation(self, **kwargs) -> GitHubResponse:
        """Cancel an organization invitation (HTTP DELETE /orgs/{org}/invitations/{invitation_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_cancel_invitation" in method_map:
                result = method_map["orgs_cancel_invitation"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/cancel-invitation' (orgs_cancel_invitation). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_check_blocked_user(self, **kwargs) -> GitHubResponse:
        """Check if a user is blocked by an organization (HTTP GET /orgs/{org}/blocks/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_check_blocked_user" in method_map:
                result = method_map["orgs_check_blocked_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/check-blocked-user' (orgs_check_blocked_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_check_membership_for_user(self, **kwargs) -> GitHubResponse:
        """Check organization membership for a user (HTTP GET /orgs/{org}/members/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_check_membership_for_user" in method_map:
                result = method_map["orgs_check_membership_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/check-membership-for-user' (orgs_check_membership_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_check_public_membership_for_user(self, **kwargs) -> GitHubResponse:
        """Check public organization membership for a user (HTTP GET /orgs/{org}/public_members/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_check_public_membership_for_user" in method_map:
                result = method_map["orgs_check_public_membership_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/check-public-membership-for-user' (orgs_check_public_membership_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_convert_member_to_outside_collaborator(self, **kwargs) -> GitHubResponse:
        """Convert an organization member to outside collaborator (HTTP PUT /orgs/{org}/outside_collaborators/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_convert_member_to_outside_collaborator" in method_map:
                result = method_map["orgs_convert_member_to_outside_collaborator"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/convert-member-to-outside-collaborator' (orgs_convert_member_to_outside_collaborator). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_create_artifact_storage_record(self, **kwargs) -> GitHubResponse:
        """Create artifact metadata storage record (HTTP POST /orgs/{org}/artifacts/metadata/storage-record)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_create_artifact_storage_record" in method_map:
                result = method_map["orgs_create_artifact_storage_record"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/create-artifact-storage-record' (orgs_create_artifact_storage_record). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_create_invitation(self, **kwargs) -> GitHubResponse:
        """Create an organization invitation (HTTP POST /orgs/{org}/invitations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_create_invitation" in method_map:
                result = method_map["orgs_create_invitation"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/create-invitation' (orgs_create_invitation). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_create_issue_type(self, **kwargs) -> GitHubResponse:
        """Create issue type for an organization (HTTP POST /orgs/{org}/issue-types)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_create_issue_type" in method_map:
                result = method_map["orgs_create_issue_type"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/create-issue-type' (orgs_create_issue_type). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_create_webhook(self, **kwargs) -> GitHubResponse:
        """Create an organization webhook (HTTP POST /orgs/{org}/hooks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_create_webhook" in method_map:
                result = method_map["orgs_create_webhook"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/create-webhook' (orgs_create_webhook). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_custom_properties_for_repos_create_or_update_organization_definition(self, **kwargs) -> GitHubResponse:
        """Create or update a custom property for an organization (HTTP PUT /orgs/{org}/properties/schema/{custom_property_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_custom_properties_for_repos_create_or_update_organization_definition" in method_map:
                result = method_map["orgs_custom_properties_for_repos_create_or_update_organization_definition"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/custom-properties-for-repos-create-or-update-organization-definition' (orgs_custom_properties_for_repos_create_or_update_organization_definition). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_custom_properties_for_repos_create_or_update_organization_definitions(self, **kwargs) -> GitHubResponse:
        """Create or update custom properties for an organization (HTTP PATCH /orgs/{org}/properties/schema)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_custom_properties_for_repos_create_or_update_organization_definitions" in method_map:
                result = method_map["orgs_custom_properties_for_repos_create_or_update_organization_definitions"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/custom-properties-for-repos-create-or-update-organization-definitions' (orgs_custom_properties_for_repos_create_or_update_organization_definitions). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_custom_properties_for_repos_create_or_update_organization_values(self, **kwargs) -> GitHubResponse:
        """Create or update custom property values for organization repositories (HTTP PATCH /orgs/{org}/properties/values)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_custom_properties_for_repos_create_or_update_organization_values" in method_map:
                result = method_map["orgs_custom_properties_for_repos_create_or_update_organization_values"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/custom-properties-for-repos-create-or-update-organization-values' (orgs_custom_properties_for_repos_create_or_update_organization_values). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_custom_properties_for_repos_delete_organization_definition(self, **kwargs) -> GitHubResponse:
        """Remove a custom property for an organization (HTTP DELETE /orgs/{org}/properties/schema/{custom_property_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_custom_properties_for_repos_delete_organization_definition" in method_map:
                result = method_map["orgs_custom_properties_for_repos_delete_organization_definition"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/custom-properties-for-repos-delete-organization-definition' (orgs_custom_properties_for_repos_delete_organization_definition). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_custom_properties_for_repos_get_organization_definition(self, **kwargs) -> GitHubResponse:
        """Get a custom property for an organization (HTTP GET /orgs/{org}/properties/schema/{custom_property_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_custom_properties_for_repos_get_organization_definition" in method_map:
                result = method_map["orgs_custom_properties_for_repos_get_organization_definition"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/custom-properties-for-repos-get-organization-definition' (orgs_custom_properties_for_repos_get_organization_definition). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_custom_properties_for_repos_get_organization_definitions(self, **kwargs) -> GitHubResponse:
        """Get all custom properties for an organization (HTTP GET /orgs/{org}/properties/schema)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_custom_properties_for_repos_get_organization_definitions" in method_map:
                result = method_map["orgs_custom_properties_for_repos_get_organization_definitions"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/custom-properties-for-repos-get-organization-definitions' (orgs_custom_properties_for_repos_get_organization_definitions). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_custom_properties_for_repos_get_organization_values(self, **kwargs) -> GitHubResponse:
        """List custom property values for organization repositories (HTTP GET /orgs/{org}/properties/values)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_custom_properties_for_repos_get_organization_values" in method_map:
                result = method_map["orgs_custom_properties_for_repos_get_organization_values"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/custom-properties-for-repos-get-organization-values' (orgs_custom_properties_for_repos_get_organization_values). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_delete(self, **kwargs) -> GitHubResponse:
        """Delete an organization (HTTP DELETE /orgs/{org})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_delete" in method_map:
                result = method_map["orgs_delete"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/delete' (orgs_delete). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_delete_attestations_bulk(self, **kwargs) -> GitHubResponse:
        """Delete attestations in bulk (HTTP POST /orgs/{org}/attestations/delete-request)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_delete_attestations_bulk" in method_map:
                result = method_map["orgs_delete_attestations_bulk"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/delete-attestations-bulk' (orgs_delete_attestations_bulk). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_delete_attestations_by_id(self, **kwargs) -> GitHubResponse:
        """Delete attestations by ID (HTTP DELETE /orgs/{org}/attestations/{attestation_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_delete_attestations_by_id" in method_map:
                result = method_map["orgs_delete_attestations_by_id"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/delete-attestations-by-id' (orgs_delete_attestations_by_id). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_delete_attestations_by_subject_digest(self, **kwargs) -> GitHubResponse:
        """Delete attestations by subject digest (HTTP DELETE /orgs/{org}/attestations/digest/{subject_digest})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_delete_attestations_by_subject_digest" in method_map:
                result = method_map["orgs_delete_attestations_by_subject_digest"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/delete-attestations-by-subject-digest' (orgs_delete_attestations_by_subject_digest). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_delete_issue_type(self, **kwargs) -> GitHubResponse:
        """Delete issue type for an organization (HTTP DELETE /orgs/{org}/issue-types/{issue_type_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_delete_issue_type" in method_map:
                result = method_map["orgs_delete_issue_type"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/delete-issue-type' (orgs_delete_issue_type). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_delete_webhook(self, **kwargs) -> GitHubResponse:
        """Delete an organization webhook (HTTP DELETE /orgs/{org}/hooks/{hook_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_delete_webhook" in method_map:
                result = method_map["orgs_delete_webhook"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/delete-webhook' (orgs_delete_webhook). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_enable_or_disable_security_product_on_all_org_repos(self, **kwargs) -> GitHubResponse:
        """Enable or disable a security feature for an organization (HTTP POST /orgs/{org}/{security_product}/{enablement})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_enable_or_disable_security_product_on_all_org_repos" in method_map:
                result = method_map["orgs_enable_or_disable_security_product_on_all_org_repos"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/enable-or-disable-security-product-on-all-org-repos' (orgs_enable_or_disable_security_product_on_all_org_repos). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_get(self, **kwargs) -> GitHubResponse:
        """Get an organization (HTTP GET /orgs/{org})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_get" in method_map:
                result = method_map["orgs_get"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/get' (orgs_get). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_get_membership_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get an organization membership for the authenticated user (HTTP GET /user/memberships/orgs/{org})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_get_membership_for_authenticated_user" in method_map:
                result = method_map["orgs_get_membership_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/get-membership-for-authenticated-user' (orgs_get_membership_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_get_membership_for_user(self, **kwargs) -> GitHubResponse:
        """Get organization membership for a user (HTTP GET /orgs/{org}/memberships/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_get_membership_for_user" in method_map:
                result = method_map["orgs_get_membership_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/get-membership-for-user' (orgs_get_membership_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_get_org_role(self, **kwargs) -> GitHubResponse:
        """Get an organization role (HTTP GET /orgs/{org}/organization-roles/{role_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_get_org_role" in method_map:
                result = method_map["orgs_get_org_role"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/get-org-role' (orgs_get_org_role). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_get_org_ruleset_history(self, **kwargs) -> GitHubResponse:
        """Get organization ruleset history (HTTP GET /orgs/{org}/rulesets/{ruleset_id}/history)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_get_org_ruleset_history" in method_map:
                result = method_map["orgs_get_org_ruleset_history"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/get-org-ruleset-history' (orgs_get_org_ruleset_history). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_get_org_ruleset_version(self, **kwargs) -> GitHubResponse:
        """Get organization ruleset version (HTTP GET /orgs/{org}/rulesets/{ruleset_id}/history/{version_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_get_org_ruleset_version" in method_map:
                result = method_map["orgs_get_org_ruleset_version"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/get-org-ruleset-version' (orgs_get_org_ruleset_version). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_get_webhook(self, **kwargs) -> GitHubResponse:
        """Get an organization webhook (HTTP GET /orgs/{org}/hooks/{hook_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_get_webhook" in method_map:
                result = method_map["orgs_get_webhook"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/get-webhook' (orgs_get_webhook). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_get_webhook_config_for_org(self, **kwargs) -> GitHubResponse:
        """Get a webhook configuration for an organization (HTTP GET /orgs/{org}/hooks/{hook_id}/config)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_get_webhook_config_for_org" in method_map:
                result = method_map["orgs_get_webhook_config_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/get-webhook-config-for-org' (orgs_get_webhook_config_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_get_webhook_delivery(self, **kwargs) -> GitHubResponse:
        """Get a webhook delivery for an organization webhook (HTTP GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_get_webhook_delivery" in method_map:
                result = method_map["orgs_get_webhook_delivery"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/get-webhook-delivery' (orgs_get_webhook_delivery). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list(self, **kwargs) -> GitHubResponse:
        """List organizations (HTTP GET /organizations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list" in method_map:
                result = method_map["orgs_list"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list' (orgs_list). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_app_installations(self, **kwargs) -> GitHubResponse:
        """List app installations for an organization (HTTP GET /orgs/{org}/installations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_app_installations" in method_map:
                result = method_map["orgs_list_app_installations"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-app-installations' (orgs_list_app_installations). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_artifact_storage_records(self, **kwargs) -> GitHubResponse:
        """List artifact storage records (HTTP GET /orgs/{org}/artifacts/{subject_digest}/metadata/storage-records)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_artifact_storage_records" in method_map:
                result = method_map["orgs_list_artifact_storage_records"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-artifact-storage-records' (orgs_list_artifact_storage_records). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_attestations(self, **kwargs) -> GitHubResponse:
        """List attestations (HTTP GET /orgs/{org}/attestations/{subject_digest})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_attestations" in method_map:
                result = method_map["orgs_list_attestations"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-attestations' (orgs_list_attestations). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_attestations_bulk(self, **kwargs) -> GitHubResponse:
        """List attestations by bulk subject digests (HTTP POST /orgs/{org}/attestations/bulk-list)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_attestations_bulk" in method_map:
                result = method_map["orgs_list_attestations_bulk"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-attestations-bulk' (orgs_list_attestations_bulk). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_blocked_users(self, **kwargs) -> GitHubResponse:
        """List users blocked by an organization (HTTP GET /orgs/{org}/blocks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_blocked_users" in method_map:
                result = method_map["orgs_list_blocked_users"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-blocked-users' (orgs_list_blocked_users). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_failed_invitations(self, **kwargs) -> GitHubResponse:
        """List failed organization invitations (HTTP GET /orgs/{org}/failed_invitations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_failed_invitations" in method_map:
                result = method_map["orgs_list_failed_invitations"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-failed-invitations' (orgs_list_failed_invitations). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List organizations for the authenticated user (HTTP GET /user/orgs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_for_authenticated_user" in method_map:
                result = method_map["orgs_list_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-for-authenticated-user' (orgs_list_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_for_user(self, **kwargs) -> GitHubResponse:
        """List organizations for a user (HTTP GET /users/{username}/orgs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_for_user" in method_map:
                result = method_map["orgs_list_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-for-user' (orgs_list_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_invitation_teams(self, **kwargs) -> GitHubResponse:
        """List organization invitation teams (HTTP GET /orgs/{org}/invitations/{invitation_id}/teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_invitation_teams" in method_map:
                result = method_map["orgs_list_invitation_teams"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-invitation-teams' (orgs_list_invitation_teams). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_issue_types(self, **kwargs) -> GitHubResponse:
        """List issue types for an organization (HTTP GET /orgs/{org}/issue-types)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_issue_types" in method_map:
                result = method_map["orgs_list_issue_types"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-issue-types' (orgs_list_issue_types). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_members(self, **kwargs) -> GitHubResponse:
        """List organization members (HTTP GET /orgs/{org}/members)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_members" in method_map:
                result = method_map["orgs_list_members"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-members' (orgs_list_members). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_memberships_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List organization memberships for the authenticated user (HTTP GET /user/memberships/orgs)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_memberships_for_authenticated_user" in method_map:
                result = method_map["orgs_list_memberships_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-memberships-for-authenticated-user' (orgs_list_memberships_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_org_role_teams(self, **kwargs) -> GitHubResponse:
        """List teams that are assigned to an organization role (HTTP GET /orgs/{org}/organization-roles/{role_id}/teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_org_role_teams" in method_map:
                result = method_map["orgs_list_org_role_teams"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-org-role-teams' (orgs_list_org_role_teams). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_org_role_users(self, **kwargs) -> GitHubResponse:
        """List users that are assigned to an organization role (HTTP GET /orgs/{org}/organization-roles/{role_id}/users)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_org_role_users" in method_map:
                result = method_map["orgs_list_org_role_users"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-org-role-users' (orgs_list_org_role_users). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_org_roles(self, **kwargs) -> GitHubResponse:
        """Get all organization roles for an organization (HTTP GET /orgs/{org}/organization-roles)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_org_roles" in method_map:
                result = method_map["orgs_list_org_roles"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-org-roles' (orgs_list_org_roles). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_outside_collaborators(self, **kwargs) -> GitHubResponse:
        """List outside collaborators for an organization (HTTP GET /orgs/{org}/outside_collaborators)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_outside_collaborators" in method_map:
                result = method_map["orgs_list_outside_collaborators"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-outside-collaborators' (orgs_list_outside_collaborators). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_pat_grant_repositories(self, **kwargs) -> GitHubResponse:
        """List repositories a fine-grained personal access token has access to (HTTP GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_pat_grant_repositories" in method_map:
                result = method_map["orgs_list_pat_grant_repositories"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-pat-grant-repositories' (orgs_list_pat_grant_repositories). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_pat_grant_request_repositories(self, **kwargs) -> GitHubResponse:
        """List repositories requested to be accessed by a fine-grained personal access token (HTTP GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_pat_grant_request_repositories" in method_map:
                result = method_map["orgs_list_pat_grant_request_repositories"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-pat-grant-request-repositories' (orgs_list_pat_grant_request_repositories). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_pat_grant_requests(self, **kwargs) -> GitHubResponse:
        """List requests to access organization resources with fine-grained personal access tokens (HTTP GET /orgs/{org}/personal-access-token-requests)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_pat_grant_requests" in method_map:
                result = method_map["orgs_list_pat_grant_requests"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-pat-grant-requests' (orgs_list_pat_grant_requests). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_pat_grants(self, **kwargs) -> GitHubResponse:
        """List fine-grained personal access tokens with access to organization resources (HTTP GET /orgs/{org}/personal-access-tokens)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_pat_grants" in method_map:
                result = method_map["orgs_list_pat_grants"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-pat-grants' (orgs_list_pat_grants). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_pending_invitations(self, **kwargs) -> GitHubResponse:
        """List pending organization invitations (HTTP GET /orgs/{org}/invitations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_pending_invitations" in method_map:
                result = method_map["orgs_list_pending_invitations"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-pending-invitations' (orgs_list_pending_invitations). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_public_members(self, **kwargs) -> GitHubResponse:
        """List public organization members (HTTP GET /orgs/{org}/public_members)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_public_members" in method_map:
                result = method_map["orgs_list_public_members"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-public-members' (orgs_list_public_members). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_security_manager_teams(self, **kwargs) -> GitHubResponse:
        """List security manager teams (HTTP GET /orgs/{org}/security-managers)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_security_manager_teams" in method_map:
                result = method_map["orgs_list_security_manager_teams"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-security-manager-teams' (orgs_list_security_manager_teams). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_webhook_deliveries(self, **kwargs) -> GitHubResponse:
        """List deliveries for an organization webhook (HTTP GET /orgs/{org}/hooks/{hook_id}/deliveries)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_webhook_deliveries" in method_map:
                result = method_map["orgs_list_webhook_deliveries"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-webhook-deliveries' (orgs_list_webhook_deliveries). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_list_webhooks(self, **kwargs) -> GitHubResponse:
        """List organization webhooks (HTTP GET /orgs/{org}/hooks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_list_webhooks" in method_map:
                result = method_map["orgs_list_webhooks"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/list-webhooks' (orgs_list_webhooks). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_ping_webhook(self, **kwargs) -> GitHubResponse:
        """Ping an organization webhook (HTTP POST /orgs/{org}/hooks/{hook_id}/pings)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_ping_webhook" in method_map:
                result = method_map["orgs_ping_webhook"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/ping-webhook' (orgs_ping_webhook). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_redeliver_webhook_delivery(self, **kwargs) -> GitHubResponse:
        """Redeliver a delivery for an organization webhook (HTTP POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_redeliver_webhook_delivery" in method_map:
                result = method_map["orgs_redeliver_webhook_delivery"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/redeliver-webhook-delivery' (orgs_redeliver_webhook_delivery). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_remove_member(self, **kwargs) -> GitHubResponse:
        """Remove an organization member (HTTP DELETE /orgs/{org}/members/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_remove_member" in method_map:
                result = method_map["orgs_remove_member"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/remove-member' (orgs_remove_member). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_remove_membership_for_user(self, **kwargs) -> GitHubResponse:
        """Remove organization membership for a user (HTTP DELETE /orgs/{org}/memberships/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_remove_membership_for_user" in method_map:
                result = method_map["orgs_remove_membership_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/remove-membership-for-user' (orgs_remove_membership_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_remove_outside_collaborator(self, **kwargs) -> GitHubResponse:
        """Remove outside collaborator from an organization (HTTP DELETE /orgs/{org}/outside_collaborators/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_remove_outside_collaborator" in method_map:
                result = method_map["orgs_remove_outside_collaborator"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/remove-outside-collaborator' (orgs_remove_outside_collaborator). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_remove_public_membership_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Remove public organization membership for the authenticated user (HTTP DELETE /orgs/{org}/public_members/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_remove_public_membership_for_authenticated_user" in method_map:
                result = method_map["orgs_remove_public_membership_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/remove-public-membership-for-authenticated-user' (orgs_remove_public_membership_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_remove_security_manager_team(self, **kwargs) -> GitHubResponse:
        """Remove a security manager team (HTTP DELETE /orgs/{org}/security-managers/teams/{team_slug})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_remove_security_manager_team" in method_map:
                result = method_map["orgs_remove_security_manager_team"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/remove-security-manager-team' (orgs_remove_security_manager_team). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_review_pat_grant_request(self, **kwargs) -> GitHubResponse:
        """Review a request to access organization resources with a fine-grained personal access token (HTTP POST /orgs/{org}/personal-access-token-requests/{pat_request_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_review_pat_grant_request" in method_map:
                result = method_map["orgs_review_pat_grant_request"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/review-pat-grant-request' (orgs_review_pat_grant_request). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_review_pat_grant_requests_in_bulk(self, **kwargs) -> GitHubResponse:
        """Review requests to access organization resources with fine-grained personal access tokens (HTTP POST /orgs/{org}/personal-access-token-requests)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_review_pat_grant_requests_in_bulk" in method_map:
                result = method_map["orgs_review_pat_grant_requests_in_bulk"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/review-pat-grant-requests-in-bulk' (orgs_review_pat_grant_requests_in_bulk). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_revoke_all_org_roles_team(self, **kwargs) -> GitHubResponse:
        """Remove all organization roles for a team (HTTP DELETE /orgs/{org}/organization-roles/teams/{team_slug})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_revoke_all_org_roles_team" in method_map:
                result = method_map["orgs_revoke_all_org_roles_team"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/revoke-all-org-roles-team' (orgs_revoke_all_org_roles_team). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_revoke_all_org_roles_user(self, **kwargs) -> GitHubResponse:
        """Remove all organization roles for a user (HTTP DELETE /orgs/{org}/organization-roles/users/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_revoke_all_org_roles_user" in method_map:
                result = method_map["orgs_revoke_all_org_roles_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/revoke-all-org-roles-user' (orgs_revoke_all_org_roles_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_revoke_org_role_team(self, **kwargs) -> GitHubResponse:
        """Remove an organization role from a team (HTTP DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_revoke_org_role_team" in method_map:
                result = method_map["orgs_revoke_org_role_team"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/revoke-org-role-team' (orgs_revoke_org_role_team). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_revoke_org_role_user(self, **kwargs) -> GitHubResponse:
        """Remove an organization role from a user (HTTP DELETE /orgs/{org}/organization-roles/users/{username}/{role_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_revoke_org_role_user" in method_map:
                result = method_map["orgs_revoke_org_role_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/revoke-org-role-user' (orgs_revoke_org_role_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_set_membership_for_user(self, **kwargs) -> GitHubResponse:
        """Set organization membership for a user (HTTP PUT /orgs/{org}/memberships/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_set_membership_for_user" in method_map:
                result = method_map["orgs_set_membership_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/set-membership-for-user' (orgs_set_membership_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_set_public_membership_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Set public organization membership for the authenticated user (HTTP PUT /orgs/{org}/public_members/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_set_public_membership_for_authenticated_user" in method_map:
                result = method_map["orgs_set_public_membership_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/set-public-membership-for-authenticated-user' (orgs_set_public_membership_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_unblock_user(self, **kwargs) -> GitHubResponse:
        """Unblock a user from an organization (HTTP DELETE /orgs/{org}/blocks/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_unblock_user" in method_map:
                result = method_map["orgs_unblock_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/unblock-user' (orgs_unblock_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_update(self, **kwargs) -> GitHubResponse:
        """Update an organization (HTTP PATCH /orgs/{org})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_update" in method_map:
                result = method_map["orgs_update"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/update' (orgs_update). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_update_issue_type(self, **kwargs) -> GitHubResponse:
        """Update issue type for an organization (HTTP PUT /orgs/{org}/issue-types/{issue_type_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_update_issue_type" in method_map:
                result = method_map["orgs_update_issue_type"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/update-issue-type' (orgs_update_issue_type). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_update_membership_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Update an organization membership for the authenticated user (HTTP PATCH /user/memberships/orgs/{org})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_update_membership_for_authenticated_user" in method_map:
                result = method_map["orgs_update_membership_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/update-membership-for-authenticated-user' (orgs_update_membership_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_update_pat_access(self, **kwargs) -> GitHubResponse:
        """Update the access a fine-grained personal access token has to organization resources (HTTP POST /orgs/{org}/personal-access-tokens/{pat_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_update_pat_access" in method_map:
                result = method_map["orgs_update_pat_access"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/update-pat-access' (orgs_update_pat_access). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_update_pat_accesses(self, **kwargs) -> GitHubResponse:
        """Update the access to organization resources via fine-grained personal access tokens (HTTP POST /orgs/{org}/personal-access-tokens)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_update_pat_accesses" in method_map:
                result = method_map["orgs_update_pat_accesses"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/update-pat-accesses' (orgs_update_pat_accesses). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_update_webhook(self, **kwargs) -> GitHubResponse:
        """Update an organization webhook (HTTP PATCH /orgs/{org}/hooks/{hook_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_update_webhook" in method_map:
                result = method_map["orgs_update_webhook"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/update-webhook' (orgs_update_webhook). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def orgs_update_webhook_config_for_org(self, **kwargs) -> GitHubResponse:
        """Update a webhook configuration for an organization (HTTP PATCH /orgs/{org}/hooks/{hook_id}/config)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "orgs_update_webhook_config_for_org" in method_map:
                result = method_map["orgs_update_webhook_config_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'orgs/update-webhook-config-for-org' (orgs_update_webhook_config_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_delete_package_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Delete a package for the authenticated user (HTTP DELETE /user/packages/{package_type}/{package_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_delete_package_for_authenticated_user" in method_map:
                result = method_map["packages_delete_package_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/delete-package-for-authenticated-user' (packages_delete_package_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_delete_package_for_org(self, **kwargs) -> GitHubResponse:
        """Delete a package for an organization (HTTP DELETE /orgs/{org}/packages/{package_type}/{package_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_delete_package_for_org" in method_map:
                result = method_map["packages_delete_package_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/delete-package-for-org' (packages_delete_package_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_delete_package_for_user(self, **kwargs) -> GitHubResponse:
        """Delete a package for a user (HTTP DELETE /users/{username}/packages/{package_type}/{package_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_delete_package_for_user" in method_map:
                result = method_map["packages_delete_package_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/delete-package-for-user' (packages_delete_package_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_delete_package_version_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Delete a package version for the authenticated user (HTTP DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_delete_package_version_for_authenticated_user" in method_map:
                result = method_map["packages_delete_package_version_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/delete-package-version-for-authenticated-user' (packages_delete_package_version_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_delete_package_version_for_org(self, **kwargs) -> GitHubResponse:
        """Delete package version for an organization (HTTP DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_delete_package_version_for_org" in method_map:
                result = method_map["packages_delete_package_version_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/delete-package-version-for-org' (packages_delete_package_version_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_delete_package_version_for_user(self, **kwargs) -> GitHubResponse:
        """Delete package version for a user (HTTP DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_delete_package_version_for_user" in method_map:
                result = method_map["packages_delete_package_version_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/delete-package-version-for-user' (packages_delete_package_version_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_get_all_package_versions_for_package_owned_by_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List package versions for a package owned by the authenticated user (HTTP GET /user/packages/{package_type}/{package_name}/versions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_get_all_package_versions_for_package_owned_by_authenticated_user" in method_map:
                result = method_map["packages_get_all_package_versions_for_package_owned_by_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/get-all-package-versions-for-package-owned-by-authenticated-user' (packages_get_all_package_versions_for_package_owned_by_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_get_all_package_versions_for_package_owned_by_org(self, **kwargs) -> GitHubResponse:
        """List package versions for a package owned by an organization (HTTP GET /orgs/{org}/packages/{package_type}/{package_name}/versions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_get_all_package_versions_for_package_owned_by_org" in method_map:
                result = method_map["packages_get_all_package_versions_for_package_owned_by_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/get-all-package-versions-for-package-owned-by-org' (packages_get_all_package_versions_for_package_owned_by_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_get_all_package_versions_for_package_owned_by_user(self, **kwargs) -> GitHubResponse:
        """List package versions for a package owned by a user (HTTP GET /users/{username}/packages/{package_type}/{package_name}/versions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_get_all_package_versions_for_package_owned_by_user" in method_map:
                result = method_map["packages_get_all_package_versions_for_package_owned_by_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/get-all-package-versions-for-package-owned-by-user' (packages_get_all_package_versions_for_package_owned_by_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_get_package_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get a package for the authenticated user (HTTP GET /user/packages/{package_type}/{package_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_get_package_for_authenticated_user" in method_map:
                result = method_map["packages_get_package_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/get-package-for-authenticated-user' (packages_get_package_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_get_package_for_organization(self, **kwargs) -> GitHubResponse:
        """Get a package for an organization (HTTP GET /orgs/{org}/packages/{package_type}/{package_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_get_package_for_organization" in method_map:
                result = method_map["packages_get_package_for_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/get-package-for-organization' (packages_get_package_for_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_get_package_for_user(self, **kwargs) -> GitHubResponse:
        """Get a package for a user (HTTP GET /users/{username}/packages/{package_type}/{package_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_get_package_for_user" in method_map:
                result = method_map["packages_get_package_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/get-package-for-user' (packages_get_package_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_get_package_version_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get a package version for the authenticated user (HTTP GET /user/packages/{package_type}/{package_name}/versions/{package_version_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_get_package_version_for_authenticated_user" in method_map:
                result = method_map["packages_get_package_version_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/get-package-version-for-authenticated-user' (packages_get_package_version_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_get_package_version_for_organization(self, **kwargs) -> GitHubResponse:
        """Get a package version for an organization (HTTP GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_get_package_version_for_organization" in method_map:
                result = method_map["packages_get_package_version_for_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/get-package-version-for-organization' (packages_get_package_version_for_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_get_package_version_for_user(self, **kwargs) -> GitHubResponse:
        """Get a package version for a user (HTTP GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_get_package_version_for_user" in method_map:
                result = method_map["packages_get_package_version_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/get-package-version-for-user' (packages_get_package_version_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_list_docker_migration_conflicting_packages_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get list of conflicting packages during Docker migration for authenticated-user (HTTP GET /user/docker/conflicts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_list_docker_migration_conflicting_packages_for_authenticated_user" in method_map:
                result = method_map["packages_list_docker_migration_conflicting_packages_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/list-docker-migration-conflicting-packages-for-authenticated-user' (packages_list_docker_migration_conflicting_packages_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_list_docker_migration_conflicting_packages_for_organization(self, **kwargs) -> GitHubResponse:
        """Get list of conflicting packages during Docker migration for organization (HTTP GET /orgs/{org}/docker/conflicts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_list_docker_migration_conflicting_packages_for_organization" in method_map:
                result = method_map["packages_list_docker_migration_conflicting_packages_for_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/list-docker-migration-conflicting-packages-for-organization' (packages_list_docker_migration_conflicting_packages_for_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_list_docker_migration_conflicting_packages_for_user(self, **kwargs) -> GitHubResponse:
        """Get list of conflicting packages during Docker migration for user (HTTP GET /users/{username}/docker/conflicts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_list_docker_migration_conflicting_packages_for_user" in method_map:
                result = method_map["packages_list_docker_migration_conflicting_packages_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/list-docker-migration-conflicting-packages-for-user' (packages_list_docker_migration_conflicting_packages_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_list_packages_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List packages for the authenticated user's namespace (HTTP GET /user/packages)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_list_packages_for_authenticated_user" in method_map:
                result = method_map["packages_list_packages_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/list-packages-for-authenticated-user' (packages_list_packages_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_list_packages_for_organization(self, **kwargs) -> GitHubResponse:
        """List packages for an organization (HTTP GET /orgs/{org}/packages)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_list_packages_for_organization" in method_map:
                result = method_map["packages_list_packages_for_organization"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/list-packages-for-organization' (packages_list_packages_for_organization). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_list_packages_for_user(self, **kwargs) -> GitHubResponse:
        """List packages for a user (HTTP GET /users/{username}/packages)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_list_packages_for_user" in method_map:
                result = method_map["packages_list_packages_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/list-packages-for-user' (packages_list_packages_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_restore_package_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Restore a package for the authenticated user (HTTP POST /user/packages/{package_type}/{package_name}/restore)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_restore_package_for_authenticated_user" in method_map:
                result = method_map["packages_restore_package_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/restore-package-for-authenticated-user' (packages_restore_package_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_restore_package_for_org(self, **kwargs) -> GitHubResponse:
        """Restore a package for an organization (HTTP POST /orgs/{org}/packages/{package_type}/{package_name}/restore)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_restore_package_for_org" in method_map:
                result = method_map["packages_restore_package_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/restore-package-for-org' (packages_restore_package_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_restore_package_for_user(self, **kwargs) -> GitHubResponse:
        """Restore a package for a user (HTTP POST /users/{username}/packages/{package_type}/{package_name}/restore)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_restore_package_for_user" in method_map:
                result = method_map["packages_restore_package_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/restore-package-for-user' (packages_restore_package_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_restore_package_version_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Restore a package version for the authenticated user (HTTP POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_restore_package_version_for_authenticated_user" in method_map:
                result = method_map["packages_restore_package_version_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/restore-package-version-for-authenticated-user' (packages_restore_package_version_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_restore_package_version_for_org(self, **kwargs) -> GitHubResponse:
        """Restore package version for an organization (HTTP POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_restore_package_version_for_org" in method_map:
                result = method_map["packages_restore_package_version_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/restore-package-version-for-org' (packages_restore_package_version_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def packages_restore_package_version_for_user(self, **kwargs) -> GitHubResponse:
        """Restore package version for a user (HTTP POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "packages_restore_package_version_for_user" in method_map:
                result = method_map["packages_restore_package_version_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'packages/restore-package-version-for-user' (packages_restore_package_version_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def private_registries_create_org_private_registry(self, **kwargs) -> GitHubResponse:
        """Create a private registry for an organization (HTTP POST /orgs/{org}/private-registries)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "private_registries_create_org_private_registry" in method_map:
                result = method_map["private_registries_create_org_private_registry"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'private-registries/create-org-private-registry' (private_registries_create_org_private_registry). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def private_registries_delete_org_private_registry(self, **kwargs) -> GitHubResponse:
        """Delete a private registry for an organization (HTTP DELETE /orgs/{org}/private-registries/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "private_registries_delete_org_private_registry" in method_map:
                result = method_map["private_registries_delete_org_private_registry"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'private-registries/delete-org-private-registry' (private_registries_delete_org_private_registry). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def private_registries_get_org_private_registry(self, **kwargs) -> GitHubResponse:
        """Get a private registry for an organization (HTTP GET /orgs/{org}/private-registries/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "private_registries_get_org_private_registry" in method_map:
                result = method_map["private_registries_get_org_private_registry"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'private-registries/get-org-private-registry' (private_registries_get_org_private_registry). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def private_registries_get_org_public_key(self, **kwargs) -> GitHubResponse:
        """Get private registries public key for an organization (HTTP GET /orgs/{org}/private-registries/public-key)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "private_registries_get_org_public_key" in method_map:
                result = method_map["private_registries_get_org_public_key"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'private-registries/get-org-public-key' (private_registries_get_org_public_key). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def private_registries_list_org_private_registries(self, **kwargs) -> GitHubResponse:
        """List private registries for an organization (HTTP GET /orgs/{org}/private-registries)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "private_registries_list_org_private_registries" in method_map:
                result = method_map["private_registries_list_org_private_registries"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'private-registries/list-org-private-registries' (private_registries_list_org_private_registries). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def private_registries_update_org_private_registry(self, **kwargs) -> GitHubResponse:
        """Update a private registry for an organization (HTTP PATCH /orgs/{org}/private-registries/{secret_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "private_registries_update_org_private_registry" in method_map:
                result = method_map["private_registries_update_org_private_registry"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'private-registries/update-org-private-registry' (private_registries_update_org_private_registry). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_add_collaborator(self, **kwargs) -> GitHubResponse:
        """Add project collaborator (HTTP PUT /projects/{project_id}/collaborators/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_add_collaborator" in method_map:
                result = method_map["projects_classic_add_collaborator"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/add-collaborator' (projects_classic_add_collaborator). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_create_column(self, **kwargs) -> GitHubResponse:
        """Create a project column (HTTP POST /projects/{project_id}/columns)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_create_column" in method_map:
                result = method_map["projects_classic_create_column"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/create-column' (projects_classic_create_column). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_create_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Create a user project (HTTP POST /user/projects)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_create_for_authenticated_user" in method_map:
                result = method_map["projects_classic_create_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/create-for-authenticated-user' (projects_classic_create_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_create_for_org(self, **kwargs) -> GitHubResponse:
        """Create an organization project (HTTP POST /orgs/{org}/projects)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_create_for_org" in method_map:
                result = method_map["projects_classic_create_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/create-for-org' (projects_classic_create_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_create_for_repo(self, **kwargs) -> GitHubResponse:
        """Create a repository project (HTTP POST /repos/{owner}/{repo}/projects)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_create_for_repo" in method_map:
                result = method_map["projects_classic_create_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/create-for-repo' (projects_classic_create_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_delete(self, **kwargs) -> GitHubResponse:
        """Delete a project (HTTP DELETE /projects/{project_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_delete" in method_map:
                result = method_map["projects_classic_delete"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/delete' (projects_classic_delete). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_delete_column(self, **kwargs) -> GitHubResponse:
        """Delete a project column (HTTP DELETE /projects/columns/{column_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_delete_column" in method_map:
                result = method_map["projects_classic_delete_column"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/delete-column' (projects_classic_delete_column). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_get(self, **kwargs) -> GitHubResponse:
        """Get a project (HTTP GET /projects/{project_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_get" in method_map:
                result = method_map["projects_classic_get"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/get' (projects_classic_get). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_get_column(self, **kwargs) -> GitHubResponse:
        """Get a project column (HTTP GET /projects/columns/{column_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_get_column" in method_map:
                result = method_map["projects_classic_get_column"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/get-column' (projects_classic_get_column). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_get_permission_for_user(self, **kwargs) -> GitHubResponse:
        """Get project permission for a user (HTTP GET /projects/{project_id}/collaborators/{username}/permission)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_get_permission_for_user" in method_map:
                result = method_map["projects_classic_get_permission_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/get-permission-for-user' (projects_classic_get_permission_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_list_collaborators(self, **kwargs) -> GitHubResponse:
        """List project collaborators (HTTP GET /projects/{project_id}/collaborators)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_list_collaborators" in method_map:
                result = method_map["projects_classic_list_collaborators"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/list-collaborators' (projects_classic_list_collaborators). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_list_columns(self, **kwargs) -> GitHubResponse:
        """List project columns (HTTP GET /projects/{project_id}/columns)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_list_columns" in method_map:
                result = method_map["projects_classic_list_columns"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/list-columns' (projects_classic_list_columns). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_list_for_org(self, **kwargs) -> GitHubResponse:
        """List organization projects (HTTP GET /orgs/{org}/projects)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_list_for_org" in method_map:
                result = method_map["projects_classic_list_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/list-for-org' (projects_classic_list_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_list_for_repo(self, **kwargs) -> GitHubResponse:
        """List repository projects (HTTP GET /repos/{owner}/{repo}/projects)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_list_for_repo" in method_map:
                result = method_map["projects_classic_list_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/list-for-repo' (projects_classic_list_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_list_for_user(self, **kwargs) -> GitHubResponse:
        """List user projects (HTTP GET /users/{username}/projects)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_list_for_user" in method_map:
                result = method_map["projects_classic_list_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/list-for-user' (projects_classic_list_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_move_column(self, **kwargs) -> GitHubResponse:
        """Move a project column (HTTP POST /projects/columns/{column_id}/moves)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_move_column" in method_map:
                result = method_map["projects_classic_move_column"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/move-column' (projects_classic_move_column). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_remove_collaborator(self, **kwargs) -> GitHubResponse:
        """Remove user as a collaborator (HTTP DELETE /projects/{project_id}/collaborators/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_remove_collaborator" in method_map:
                result = method_map["projects_classic_remove_collaborator"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/remove-collaborator' (projects_classic_remove_collaborator). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_update(self, **kwargs) -> GitHubResponse:
        """Update a project (HTTP PATCH /projects/{project_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_update" in method_map:
                result = method_map["projects_classic_update"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/update' (projects_classic_update). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_classic_update_column(self, **kwargs) -> GitHubResponse:
        """Update an existing project column (HTTP PATCH /projects/columns/{column_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_classic_update_column" in method_map:
                result = method_map["projects_classic_update_column"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects-classic/update-column' (projects_classic_update_column). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_add_item_for_org(self, **kwargs) -> GitHubResponse:
        """Add item to organization owned project (HTTP POST /orgs/{org}/projectsV2/{project_number}/items)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_add_item_for_org" in method_map:
                result = method_map["projects_add_item_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/add-item-for-org' (projects_add_item_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_add_item_for_user(self, **kwargs) -> GitHubResponse:
        """Add item to user owned project (HTTP POST /users/{username}/projectsV2/{project_number}/items)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_add_item_for_user" in method_map:
                result = method_map["projects_add_item_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/add-item-for-user' (projects_add_item_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_delete_item_for_org(self, **kwargs) -> GitHubResponse:
        """Delete project item for organization (HTTP DELETE /orgs/{org}/projectsV2/{project_number}/items/{item_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_delete_item_for_org" in method_map:
                result = method_map["projects_delete_item_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/delete-item-for-org' (projects_delete_item_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_delete_item_for_user(self, **kwargs) -> GitHubResponse:
        """Delete project item for user (HTTP DELETE /users/{username}/projectsV2/{project_number}/items/{item_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_delete_item_for_user" in method_map:
                result = method_map["projects_delete_item_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/delete-item-for-user' (projects_delete_item_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_get_field_for_org(self, **kwargs) -> GitHubResponse:
        """Get project field for organization (HTTP GET /orgs/{org}/projectsV2/{project_number}/fields/{field_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_get_field_for_org" in method_map:
                result = method_map["projects_get_field_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/get-field-for-org' (projects_get_field_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_get_field_for_user(self, **kwargs) -> GitHubResponse:
        """Get project field for user (HTTP GET /users/{username}/projectsV2/{project_number}/fields/{field_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_get_field_for_user" in method_map:
                result = method_map["projects_get_field_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/get-field-for-user' (projects_get_field_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_get_for_org(self, **kwargs) -> GitHubResponse:
        """Get project for organization (HTTP GET /orgs/{org}/projectsV2/{project_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_get_for_org" in method_map:
                result = method_map["projects_get_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/get-for-org' (projects_get_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_get_for_user(self, **kwargs) -> GitHubResponse:
        """Get project for user (HTTP GET /users/{username}/projectsV2/{project_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_get_for_user" in method_map:
                result = method_map["projects_get_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/get-for-user' (projects_get_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_get_org_item(self, **kwargs) -> GitHubResponse:
        """Get an item for an organization owned project (HTTP GET /orgs/{org}/projectsV2/{project_number}/items/{item_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_get_org_item" in method_map:
                result = method_map["projects_get_org_item"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/get-org-item' (projects_get_org_item). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_get_user_item(self, **kwargs) -> GitHubResponse:
        """Get an item for a user owned project (HTTP GET /users/{username}/projectsV2/{project_number}/items/{item_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_get_user_item" in method_map:
                result = method_map["projects_get_user_item"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/get-user-item' (projects_get_user_item). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_list_fields_for_org(self, **kwargs) -> GitHubResponse:
        """List project fields for organization (HTTP GET /orgs/{org}/projectsV2/{project_number}/fields)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_list_fields_for_org" in method_map:
                result = method_map["projects_list_fields_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/list-fields-for-org' (projects_list_fields_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_list_fields_for_user(self, **kwargs) -> GitHubResponse:
        """List project fields for user (HTTP GET /users/{username}/projectsV2/{project_number}/fields)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_list_fields_for_user" in method_map:
                result = method_map["projects_list_fields_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/list-fields-for-user' (projects_list_fields_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_list_for_org(self, **kwargs) -> GitHubResponse:
        """List projects for organization (HTTP GET /orgs/{org}/projectsV2)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_list_for_org" in method_map:
                result = method_map["projects_list_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/list-for-org' (projects_list_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_list_for_user(self, **kwargs) -> GitHubResponse:
        """List projects for user (HTTP GET /users/{username}/projectsV2)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_list_for_user" in method_map:
                result = method_map["projects_list_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/list-for-user' (projects_list_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_list_items_for_org(self, **kwargs) -> GitHubResponse:
        """List items for an organization owned project (HTTP GET /orgs/{org}/projectsV2/{project_number}/items)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_list_items_for_org" in method_map:
                result = method_map["projects_list_items_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/list-items-for-org' (projects_list_items_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_list_items_for_user(self, **kwargs) -> GitHubResponse:
        """List items for a user owned project (HTTP GET /users/{username}/projectsV2/{project_number}/items)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_list_items_for_user" in method_map:
                result = method_map["projects_list_items_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/list-items-for-user' (projects_list_items_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_update_item_for_org(self, **kwargs) -> GitHubResponse:
        """Update project item for organization (HTTP PATCH /orgs/{org}/projectsV2/{project_number}/items/{item_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_update_item_for_org" in method_map:
                result = method_map["projects_update_item_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/update-item-for-org' (projects_update_item_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def projects_update_item_for_user(self, **kwargs) -> GitHubResponse:
        """Update project item for user (HTTP PATCH /users/{username}/projectsV2/{project_number}/items/{item_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "projects_update_item_for_user" in method_map:
                result = method_map["projects_update_item_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'projects/update-item-for-user' (projects_update_item_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_check_if_merged(self, **kwargs) -> GitHubResponse:
        """Check if a pull request has been merged (HTTP GET /repos/{owner}/{repo}/pulls/{pull_number}/merge)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_check_if_merged" in method_map:
                result = method_map["pulls_check_if_merged"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/check-if-merged' (pulls_check_if_merged). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_create(self, **kwargs) -> GitHubResponse:
        """Create a pull request (HTTP POST /repos/{owner}/{repo}/pulls)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_create" in method_map:
                result = method_map["pulls_create"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/create' (pulls_create). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_create_reply_for_review_comment(self, **kwargs) -> GitHubResponse:
        """Create a reply for a review comment (HTTP POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_create_reply_for_review_comment" in method_map:
                result = method_map["pulls_create_reply_for_review_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/create-reply-for-review-comment' (pulls_create_reply_for_review_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_create_review(self, **kwargs) -> GitHubResponse:
        """Create a review for a pull request (HTTP POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_create_review" in method_map:
                result = method_map["pulls_create_review"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/create-review' (pulls_create_review). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_create_review_comment(self, **kwargs) -> GitHubResponse:
        """Create a review comment for a pull request (HTTP POST /repos/{owner}/{repo}/pulls/{pull_number}/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_create_review_comment" in method_map:
                result = method_map["pulls_create_review_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/create-review-comment' (pulls_create_review_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_delete_pending_review(self, **kwargs) -> GitHubResponse:
        """Delete a pending review for a pull request (HTTP DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_delete_pending_review" in method_map:
                result = method_map["pulls_delete_pending_review"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/delete-pending-review' (pulls_delete_pending_review). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_delete_review_comment(self, **kwargs) -> GitHubResponse:
        """Delete a review comment for a pull request (HTTP DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_delete_review_comment" in method_map:
                result = method_map["pulls_delete_review_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/delete-review-comment' (pulls_delete_review_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_dismiss_review(self, **kwargs) -> GitHubResponse:
        """Dismiss a review for a pull request (HTTP PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_dismiss_review" in method_map:
                result = method_map["pulls_dismiss_review"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/dismiss-review' (pulls_dismiss_review). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_get(self, **kwargs) -> GitHubResponse:
        """Get a pull request (HTTP GET /repos/{owner}/{repo}/pulls/{pull_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_get" in method_map:
                result = method_map["pulls_get"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/get' (pulls_get). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_get_review(self, **kwargs) -> GitHubResponse:
        """Get a review for a pull request (HTTP GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_get_review" in method_map:
                result = method_map["pulls_get_review"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/get-review' (pulls_get_review). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_get_review_comment(self, **kwargs) -> GitHubResponse:
        """Get a review comment for a pull request (HTTP GET /repos/{owner}/{repo}/pulls/comments/{comment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_get_review_comment" in method_map:
                result = method_map["pulls_get_review_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/get-review-comment' (pulls_get_review_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_list(self, **kwargs) -> GitHubResponse:
        """List pull requests (HTTP GET /repos/{owner}/{repo}/pulls)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_list" in method_map:
                result = method_map["pulls_list"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/list' (pulls_list). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_list_comments_for_review(self, **kwargs) -> GitHubResponse:
        """List comments for a pull request review (HTTP GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_list_comments_for_review" in method_map:
                result = method_map["pulls_list_comments_for_review"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/list-comments-for-review' (pulls_list_comments_for_review). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_list_commits(self, **kwargs) -> GitHubResponse:
        """List commits on a pull request (HTTP GET /repos/{owner}/{repo}/pulls/{pull_number}/commits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_list_commits" in method_map:
                result = method_map["pulls_list_commits"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/list-commits' (pulls_list_commits). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_list_files(self, **kwargs) -> GitHubResponse:
        """List pull requests files (HTTP GET /repos/{owner}/{repo}/pulls/{pull_number}/files)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_list_files" in method_map:
                result = method_map["pulls_list_files"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/list-files' (pulls_list_files). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_list_requested_reviewers(self, **kwargs) -> GitHubResponse:
        """Get all requested reviewers for a pull request (HTTP GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_list_requested_reviewers" in method_map:
                result = method_map["pulls_list_requested_reviewers"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/list-requested-reviewers' (pulls_list_requested_reviewers). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_list_review_comments(self, **kwargs) -> GitHubResponse:
        """List review comments on a pull request (HTTP GET /repos/{owner}/{repo}/pulls/{pull_number}/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_list_review_comments" in method_map:
                result = method_map["pulls_list_review_comments"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/list-review-comments' (pulls_list_review_comments). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_list_review_comments_for_repo(self, **kwargs) -> GitHubResponse:
        """List review comments in a repository (HTTP GET /repos/{owner}/{repo}/pulls/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_list_review_comments_for_repo" in method_map:
                result = method_map["pulls_list_review_comments_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/list-review-comments-for-repo' (pulls_list_review_comments_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_list_reviews(self, **kwargs) -> GitHubResponse:
        """List reviews for a pull request (HTTP GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_list_reviews" in method_map:
                result = method_map["pulls_list_reviews"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/list-reviews' (pulls_list_reviews). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_merge(self, **kwargs) -> GitHubResponse:
        """Merge a pull request (HTTP PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_merge" in method_map:
                result = method_map["pulls_merge"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/merge' (pulls_merge). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_remove_requested_reviewers(self, **kwargs) -> GitHubResponse:
        """Remove requested reviewers from a pull request (HTTP DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_remove_requested_reviewers" in method_map:
                result = method_map["pulls_remove_requested_reviewers"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/remove-requested-reviewers' (pulls_remove_requested_reviewers). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_request_reviewers(self, **kwargs) -> GitHubResponse:
        """Request reviewers for a pull request (HTTP POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_request_reviewers" in method_map:
                result = method_map["pulls_request_reviewers"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/request-reviewers' (pulls_request_reviewers). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_submit_review(self, **kwargs) -> GitHubResponse:
        """Submit a review for a pull request (HTTP POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_submit_review" in method_map:
                result = method_map["pulls_submit_review"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/submit-review' (pulls_submit_review). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_update(self, **kwargs) -> GitHubResponse:
        """Update a pull request (HTTP PATCH /repos/{owner}/{repo}/pulls/{pull_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_update" in method_map:
                result = method_map["pulls_update"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/update' (pulls_update). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_update_branch(self, **kwargs) -> GitHubResponse:
        """Update a pull request branch (HTTP PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_update_branch" in method_map:
                result = method_map["pulls_update_branch"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/update-branch' (pulls_update_branch). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_update_review(self, **kwargs) -> GitHubResponse:
        """Update a review for a pull request (HTTP PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_update_review" in method_map:
                result = method_map["pulls_update_review"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/update-review' (pulls_update_review). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def pulls_update_review_comment(self, **kwargs) -> GitHubResponse:
        """Update a review comment for a pull request (HTTP PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "pulls_update_review_comment" in method_map:
                result = method_map["pulls_update_review_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'pulls/update-review-comment' (pulls_update_review_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def rate_limit_get(self, **kwargs) -> GitHubResponse:
        """Get rate limit status for the authenticated user (HTTP GET /rate_limit)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "rate_limit_get" in method_map:
                result = method_map["rate_limit_get"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'rate-limit/get' (rate_limit_get). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_create_for_commit_comment(self, **kwargs) -> GitHubResponse:
        """Create reaction for a commit comment (HTTP POST /repos/{owner}/{repo}/comments/{comment_id}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_create_for_commit_comment" in method_map:
                result = method_map["reactions_create_for_commit_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/create-for-commit-comment' (reactions_create_for_commit_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_create_for_issue(self, **kwargs) -> GitHubResponse:
        """Create reaction for an issue (HTTP POST /repos/{owner}/{repo}/issues/{issue_number}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_create_for_issue" in method_map:
                result = method_map["reactions_create_for_issue"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/create-for-issue' (reactions_create_for_issue). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_create_for_issue_comment(self, **kwargs) -> GitHubResponse:
        """Create reaction for an issue comment (HTTP POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_create_for_issue_comment" in method_map:
                result = method_map["reactions_create_for_issue_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/create-for-issue-comment' (reactions_create_for_issue_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_create_for_pull_request_review_comment(self, **kwargs) -> GitHubResponse:
        """Create reaction for a pull request review comment (HTTP POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_create_for_pull_request_review_comment" in method_map:
                result = method_map["reactions_create_for_pull_request_review_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/create-for-pull-request-review-comment' (reactions_create_for_pull_request_review_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_create_for_release(self, **kwargs) -> GitHubResponse:
        """Create reaction for a release (HTTP POST /repos/{owner}/{repo}/releases/{release_id}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_create_for_release" in method_map:
                result = method_map["reactions_create_for_release"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/create-for-release' (reactions_create_for_release). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_create_for_team_discussion_comment_in_org(self, **kwargs) -> GitHubResponse:
        """Create reaction for a team discussion comment (HTTP POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_create_for_team_discussion_comment_in_org" in method_map:
                result = method_map["reactions_create_for_team_discussion_comment_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/create-for-team-discussion-comment-in-org' (reactions_create_for_team_discussion_comment_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_create_for_team_discussion_comment_legacy(self, **kwargs) -> GitHubResponse:
        """Create reaction for a team discussion comment (Legacy) (HTTP POST /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_create_for_team_discussion_comment_legacy" in method_map:
                result = method_map["reactions_create_for_team_discussion_comment_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/create-for-team-discussion-comment-legacy' (reactions_create_for_team_discussion_comment_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_create_for_team_discussion_in_org(self, **kwargs) -> GitHubResponse:
        """Create reaction for a team discussion (HTTP POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_create_for_team_discussion_in_org" in method_map:
                result = method_map["reactions_create_for_team_discussion_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/create-for-team-discussion-in-org' (reactions_create_for_team_discussion_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_create_for_team_discussion_legacy(self, **kwargs) -> GitHubResponse:
        """Create reaction for a team discussion (Legacy) (HTTP POST /teams/{team_id}/discussions/{discussion_number}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_create_for_team_discussion_legacy" in method_map:
                result = method_map["reactions_create_for_team_discussion_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/create-for-team-discussion-legacy' (reactions_create_for_team_discussion_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_delete_for_commit_comment(self, **kwargs) -> GitHubResponse:
        """Delete a commit comment reaction (HTTP DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_delete_for_commit_comment" in method_map:
                result = method_map["reactions_delete_for_commit_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/delete-for-commit-comment' (reactions_delete_for_commit_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_delete_for_issue(self, **kwargs) -> GitHubResponse:
        """Delete an issue reaction (HTTP DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_delete_for_issue" in method_map:
                result = method_map["reactions_delete_for_issue"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/delete-for-issue' (reactions_delete_for_issue). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_delete_for_issue_comment(self, **kwargs) -> GitHubResponse:
        """Delete an issue comment reaction (HTTP DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_delete_for_issue_comment" in method_map:
                result = method_map["reactions_delete_for_issue_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/delete-for-issue-comment' (reactions_delete_for_issue_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_delete_for_pull_request_comment(self, **kwargs) -> GitHubResponse:
        """Delete a pull request comment reaction (HTTP DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_delete_for_pull_request_comment" in method_map:
                result = method_map["reactions_delete_for_pull_request_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/delete-for-pull-request-comment' (reactions_delete_for_pull_request_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_delete_for_release(self, **kwargs) -> GitHubResponse:
        """Delete a release reaction (HTTP DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_delete_for_release" in method_map:
                result = method_map["reactions_delete_for_release"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/delete-for-release' (reactions_delete_for_release). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_delete_for_team_discussion(self, **kwargs) -> GitHubResponse:
        """Delete team discussion reaction (HTTP DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_delete_for_team_discussion" in method_map:
                result = method_map["reactions_delete_for_team_discussion"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/delete-for-team-discussion' (reactions_delete_for_team_discussion). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_delete_for_team_discussion_comment(self, **kwargs) -> GitHubResponse:
        """Delete team discussion comment reaction (HTTP DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_delete_for_team_discussion_comment" in method_map:
                result = method_map["reactions_delete_for_team_discussion_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/delete-for-team-discussion-comment' (reactions_delete_for_team_discussion_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_list_for_commit_comment(self, **kwargs) -> GitHubResponse:
        """List reactions for a commit comment (HTTP GET /repos/{owner}/{repo}/comments/{comment_id}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_list_for_commit_comment" in method_map:
                result = method_map["reactions_list_for_commit_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/list-for-commit-comment' (reactions_list_for_commit_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_list_for_issue(self, **kwargs) -> GitHubResponse:
        """List reactions for an issue (HTTP GET /repos/{owner}/{repo}/issues/{issue_number}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_list_for_issue" in method_map:
                result = method_map["reactions_list_for_issue"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/list-for-issue' (reactions_list_for_issue). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_list_for_issue_comment(self, **kwargs) -> GitHubResponse:
        """List reactions for an issue comment (HTTP GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_list_for_issue_comment" in method_map:
                result = method_map["reactions_list_for_issue_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/list-for-issue-comment' (reactions_list_for_issue_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_list_for_pull_request_review_comment(self, **kwargs) -> GitHubResponse:
        """List reactions for a pull request review comment (HTTP GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_list_for_pull_request_review_comment" in method_map:
                result = method_map["reactions_list_for_pull_request_review_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/list-for-pull-request-review-comment' (reactions_list_for_pull_request_review_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_list_for_release(self, **kwargs) -> GitHubResponse:
        """List reactions for a release (HTTP GET /repos/{owner}/{repo}/releases/{release_id}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_list_for_release" in method_map:
                result = method_map["reactions_list_for_release"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/list-for-release' (reactions_list_for_release). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_list_for_team_discussion_comment_in_org(self, **kwargs) -> GitHubResponse:
        """List reactions for a team discussion comment (HTTP GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_list_for_team_discussion_comment_in_org" in method_map:
                result = method_map["reactions_list_for_team_discussion_comment_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/list-for-team-discussion-comment-in-org' (reactions_list_for_team_discussion_comment_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_list_for_team_discussion_comment_legacy(self, **kwargs) -> GitHubResponse:
        """List reactions for a team discussion comment (Legacy) (HTTP GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_list_for_team_discussion_comment_legacy" in method_map:
                result = method_map["reactions_list_for_team_discussion_comment_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/list-for-team-discussion-comment-legacy' (reactions_list_for_team_discussion_comment_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_list_for_team_discussion_in_org(self, **kwargs) -> GitHubResponse:
        """List reactions for a team discussion (HTTP GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_list_for_team_discussion_in_org" in method_map:
                result = method_map["reactions_list_for_team_discussion_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/list-for-team-discussion-in-org' (reactions_list_for_team_discussion_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def reactions_list_for_team_discussion_legacy(self, **kwargs) -> GitHubResponse:
        """List reactions for a team discussion (Legacy) (HTTP GET /teams/{team_id}/discussions/{discussion_number}/reactions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "reactions_list_for_team_discussion_legacy" in method_map:
                result = method_map["reactions_list_for_team_discussion_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'reactions/list-for-team-discussion-legacy' (reactions_list_for_team_discussion_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_accept_invitation_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Accept a repository invitation (HTTP PATCH /user/repository_invitations/{invitation_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_accept_invitation_for_authenticated_user" in method_map:
                result = method_map["repos_accept_invitation_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/accept-invitation-for-authenticated-user' (repos_accept_invitation_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_add_app_access_restrictions(self, **kwargs) -> GitHubResponse:
        """Add app access restrictions (HTTP POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_add_app_access_restrictions" in method_map:
                result = method_map["repos_add_app_access_restrictions"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/add-app-access-restrictions' (repos_add_app_access_restrictions). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_add_collaborator(self, **kwargs) -> GitHubResponse:
        """Add a repository collaborator (HTTP PUT /repos/{owner}/{repo}/collaborators/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_add_collaborator" in method_map:
                result = method_map["repos_add_collaborator"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/add-collaborator' (repos_add_collaborator). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_add_status_check_contexts(self, **kwargs) -> GitHubResponse:
        """Add status check contexts (HTTP POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_add_status_check_contexts" in method_map:
                result = method_map["repos_add_status_check_contexts"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/add-status-check-contexts' (repos_add_status_check_contexts). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_add_team_access_restrictions(self, **kwargs) -> GitHubResponse:
        """Add team access restrictions (HTTP POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_add_team_access_restrictions" in method_map:
                result = method_map["repos_add_team_access_restrictions"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/add-team-access-restrictions' (repos_add_team_access_restrictions). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_add_user_access_restrictions(self, **kwargs) -> GitHubResponse:
        """Add user access restrictions (HTTP POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_add_user_access_restrictions" in method_map:
                result = method_map["repos_add_user_access_restrictions"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/add-user-access-restrictions' (repos_add_user_access_restrictions). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_cancel_pages_deployment(self, **kwargs) -> GitHubResponse:
        """Cancel a GitHub Pages deployment (HTTP POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_cancel_pages_deployment" in method_map:
                result = method_map["repos_cancel_pages_deployment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/cancel-pages-deployment' (repos_cancel_pages_deployment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_check_automated_security_fixes(self, **kwargs) -> GitHubResponse:
        """Check if Dependabot security updates are enabled for a repository (HTTP GET /repos/{owner}/{repo}/automated-security-fixes)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_check_automated_security_fixes" in method_map:
                result = method_map["repos_check_automated_security_fixes"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/check-automated-security-fixes' (repos_check_automated_security_fixes). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_check_collaborator(self, **kwargs) -> GitHubResponse:
        """Check if a user is a repository collaborator (HTTP GET /repos/{owner}/{repo}/collaborators/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_check_collaborator" in method_map:
                result = method_map["repos_check_collaborator"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/check-collaborator' (repos_check_collaborator). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_check_private_vulnerability_reporting(self, **kwargs) -> GitHubResponse:
        """Check if private vulnerability reporting is enabled for a repository (HTTP GET /repos/{owner}/{repo}/private-vulnerability-reporting)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_check_private_vulnerability_reporting" in method_map:
                result = method_map["repos_check_private_vulnerability_reporting"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/check-private-vulnerability-reporting' (repos_check_private_vulnerability_reporting). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_check_vulnerability_alerts(self, **kwargs) -> GitHubResponse:
        """Check if vulnerability alerts are enabled for a repository (HTTP GET /repos/{owner}/{repo}/vulnerability-alerts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_check_vulnerability_alerts" in method_map:
                result = method_map["repos_check_vulnerability_alerts"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/check-vulnerability-alerts' (repos_check_vulnerability_alerts). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_codeowners_errors(self, **kwargs) -> GitHubResponse:
        """List CODEOWNERS errors (HTTP GET /repos/{owner}/{repo}/codeowners/errors)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_codeowners_errors" in method_map:
                result = method_map["repos_codeowners_errors"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/codeowners-errors' (repos_codeowners_errors). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_compare_commits(self, **kwargs) -> GitHubResponse:
        """Compare two commits (HTTP GET /repos/{owner}/{repo}/compare/{basehead})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_compare_commits" in method_map:
                result = method_map["repos_compare_commits"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/compare-commits' (repos_compare_commits). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_attestation(self, **kwargs) -> GitHubResponse:
        """Create an attestation (HTTP POST /repos/{owner}/{repo}/attestations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_attestation" in method_map:
                result = method_map["repos_create_attestation"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-attestation' (repos_create_attestation). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_autolink(self, **kwargs) -> GitHubResponse:
        """Create an autolink reference for a repository (HTTP POST /repos/{owner}/{repo}/autolinks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_autolink" in method_map:
                result = method_map["repos_create_autolink"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-autolink' (repos_create_autolink). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_commit_comment(self, **kwargs) -> GitHubResponse:
        """Create a commit comment (HTTP POST /repos/{owner}/{repo}/commits/{commit_sha}/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_commit_comment" in method_map:
                result = method_map["repos_create_commit_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-commit-comment' (repos_create_commit_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_commit_signature_protection(self, **kwargs) -> GitHubResponse:
        """Create commit signature protection (HTTP POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_commit_signature_protection" in method_map:
                result = method_map["repos_create_commit_signature_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-commit-signature-protection' (repos_create_commit_signature_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_commit_status(self, **kwargs) -> GitHubResponse:
        """Create a commit status (HTTP POST /repos/{owner}/{repo}/statuses/{sha})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_commit_status" in method_map:
                result = method_map["repos_create_commit_status"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-commit-status' (repos_create_commit_status). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_deploy_key(self, **kwargs) -> GitHubResponse:
        """Create a deploy key (HTTP POST /repos/{owner}/{repo}/keys)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_deploy_key" in method_map:
                result = method_map["repos_create_deploy_key"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-deploy-key' (repos_create_deploy_key). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_deployment(self, **kwargs) -> GitHubResponse:
        """Create a deployment (HTTP POST /repos/{owner}/{repo}/deployments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_deployment" in method_map:
                result = method_map["repos_create_deployment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-deployment' (repos_create_deployment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_deployment_branch_policy(self, **kwargs) -> GitHubResponse:
        """Create a deployment branch policy (HTTP POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_deployment_branch_policy" in method_map:
                result = method_map["repos_create_deployment_branch_policy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-deployment-branch-policy' (repos_create_deployment_branch_policy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_deployment_protection_rule(self, **kwargs) -> GitHubResponse:
        """Create a custom deployment protection rule on an environment (HTTP POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_deployment_protection_rule" in method_map:
                result = method_map["repos_create_deployment_protection_rule"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-deployment-protection-rule' (repos_create_deployment_protection_rule). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_deployment_status(self, **kwargs) -> GitHubResponse:
        """Create a deployment status (HTTP POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_deployment_status" in method_map:
                result = method_map["repos_create_deployment_status"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-deployment-status' (repos_create_deployment_status). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_dispatch_event(self, **kwargs) -> GitHubResponse:
        """Create a repository dispatch event (HTTP POST /repos/{owner}/{repo}/dispatches)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_dispatch_event" in method_map:
                result = method_map["repos_create_dispatch_event"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-dispatch-event' (repos_create_dispatch_event). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Create a repository for the authenticated user (HTTP POST /user/repos)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_for_authenticated_user" in method_map:
                result = method_map["repos_create_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-for-authenticated-user' (repos_create_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_fork(self, **kwargs) -> GitHubResponse:
        """Create a fork (HTTP POST /repos/{owner}/{repo}/forks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_fork" in method_map:
                result = method_map["repos_create_fork"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-fork' (repos_create_fork). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_in_org(self, **kwargs) -> GitHubResponse:
        """Create an organization repository (HTTP POST /orgs/{org}/repos)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_in_org" in method_map:
                result = method_map["repos_create_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-in-org' (repos_create_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_or_update_environment(self, **kwargs) -> GitHubResponse:
        """Create or update an environment (HTTP PUT /repos/{owner}/{repo}/environments/{environment_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_or_update_environment" in method_map:
                result = method_map["repos_create_or_update_environment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-or-update-environment' (repos_create_or_update_environment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_or_update_file_contents(self, **kwargs) -> GitHubResponse:
        """Create or update file contents (HTTP PUT /repos/{owner}/{repo}/contents/{path})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_or_update_file_contents" in method_map:
                result = method_map["repos_create_or_update_file_contents"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-or-update-file-contents' (repos_create_or_update_file_contents). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_org_ruleset(self, **kwargs) -> GitHubResponse:
        """Create an organization repository ruleset (HTTP POST /orgs/{org}/rulesets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_org_ruleset" in method_map:
                result = method_map["repos_create_org_ruleset"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-org-ruleset' (repos_create_org_ruleset). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_pages_deployment(self, **kwargs) -> GitHubResponse:
        """Create a GitHub Pages deployment (HTTP POST /repos/{owner}/{repo}/pages/deployments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_pages_deployment" in method_map:
                result = method_map["repos_create_pages_deployment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-pages-deployment' (repos_create_pages_deployment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_pages_site(self, **kwargs) -> GitHubResponse:
        """Create a GitHub Pages site (HTTP POST /repos/{owner}/{repo}/pages)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_pages_site" in method_map:
                result = method_map["repos_create_pages_site"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-pages-site' (repos_create_pages_site). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_release(self, **kwargs) -> GitHubResponse:
        """Create a release (HTTP POST /repos/{owner}/{repo}/releases)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_release" in method_map:
                result = method_map["repos_create_release"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-release' (repos_create_release). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_repo_ruleset(self, **kwargs) -> GitHubResponse:
        """Create a repository ruleset (HTTP POST /repos/{owner}/{repo}/rulesets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_repo_ruleset" in method_map:
                result = method_map["repos_create_repo_ruleset"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-repo-ruleset' (repos_create_repo_ruleset). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_tag_protection(self, **kwargs) -> GitHubResponse:
        """Closing down - Create a tag protection state for a repository (HTTP POST /repos/{owner}/{repo}/tags/protection)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_tag_protection" in method_map:
                result = method_map["repos_create_tag_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-tag-protection' (repos_create_tag_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_using_template(self, **kwargs) -> GitHubResponse:
        """Create a repository using a template (HTTP POST /repos/{template_owner}/{template_repo}/generate)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_using_template" in method_map:
                result = method_map["repos_create_using_template"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-using-template' (repos_create_using_template). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_create_webhook(self, **kwargs) -> GitHubResponse:
        """Create a repository webhook (HTTP POST /repos/{owner}/{repo}/hooks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_create_webhook" in method_map:
                result = method_map["repos_create_webhook"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/create-webhook' (repos_create_webhook). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_custom_properties_for_repos_create_or_update_repository_values(self, **kwargs) -> GitHubResponse:
        """Create or update custom property values for a repository (HTTP PATCH /repos/{owner}/{repo}/properties/values)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_custom_properties_for_repos_create_or_update_repository_values" in method_map:
                result = method_map["repos_custom_properties_for_repos_create_or_update_repository_values"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/custom-properties-for-repos-create-or-update-repository-values' (repos_custom_properties_for_repos_create_or_update_repository_values). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_custom_properties_for_repos_get_repository_values(self, **kwargs) -> GitHubResponse:
        """Get all custom property values for a repository (HTTP GET /repos/{owner}/{repo}/properties/values)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_custom_properties_for_repos_get_repository_values" in method_map:
                result = method_map["repos_custom_properties_for_repos_get_repository_values"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/custom-properties-for-repos-get-repository-values' (repos_custom_properties_for_repos_get_repository_values). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_decline_invitation_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Decline a repository invitation (HTTP DELETE /user/repository_invitations/{invitation_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_decline_invitation_for_authenticated_user" in method_map:
                result = method_map["repos_decline_invitation_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/decline-invitation-for-authenticated-user' (repos_decline_invitation_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete(self, **kwargs) -> GitHubResponse:
        """Delete a repository (HTTP DELETE /repos/{owner}/{repo})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete" in method_map:
                result = method_map["repos_delete"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete' (repos_delete). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_access_restrictions(self, **kwargs) -> GitHubResponse:
        """Delete access restrictions (HTTP DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_access_restrictions" in method_map:
                result = method_map["repos_delete_access_restrictions"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-access-restrictions' (repos_delete_access_restrictions). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_admin_branch_protection(self, **kwargs) -> GitHubResponse:
        """Delete admin branch protection (HTTP DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_admin_branch_protection" in method_map:
                result = method_map["repos_delete_admin_branch_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-admin-branch-protection' (repos_delete_admin_branch_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_an_environment(self, **kwargs) -> GitHubResponse:
        """Delete an environment (HTTP DELETE /repos/{owner}/{repo}/environments/{environment_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_an_environment" in method_map:
                result = method_map["repos_delete_an_environment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-an-environment' (repos_delete_an_environment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_autolink(self, **kwargs) -> GitHubResponse:
        """Delete an autolink reference from a repository (HTTP DELETE /repos/{owner}/{repo}/autolinks/{autolink_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_autolink" in method_map:
                result = method_map["repos_delete_autolink"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-autolink' (repos_delete_autolink). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_branch_protection(self, **kwargs) -> GitHubResponse:
        """Delete branch protection (HTTP DELETE /repos/{owner}/{repo}/branches/{branch}/protection)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_branch_protection" in method_map:
                result = method_map["repos_delete_branch_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-branch-protection' (repos_delete_branch_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_commit_comment(self, **kwargs) -> GitHubResponse:
        """Delete a commit comment (HTTP DELETE /repos/{owner}/{repo}/comments/{comment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_commit_comment" in method_map:
                result = method_map["repos_delete_commit_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-commit-comment' (repos_delete_commit_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_commit_signature_protection(self, **kwargs) -> GitHubResponse:
        """Delete commit signature protection (HTTP DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_commit_signature_protection" in method_map:
                result = method_map["repos_delete_commit_signature_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-commit-signature-protection' (repos_delete_commit_signature_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_deploy_key(self, **kwargs) -> GitHubResponse:
        """Delete a deploy key (HTTP DELETE /repos/{owner}/{repo}/keys/{key_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_deploy_key" in method_map:
                result = method_map["repos_delete_deploy_key"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-deploy-key' (repos_delete_deploy_key). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_deployment(self, **kwargs) -> GitHubResponse:
        """Delete a deployment (HTTP DELETE /repos/{owner}/{repo}/deployments/{deployment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_deployment" in method_map:
                result = method_map["repos_delete_deployment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-deployment' (repos_delete_deployment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_deployment_branch_policy(self, **kwargs) -> GitHubResponse:
        """Delete a deployment branch policy (HTTP DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_deployment_branch_policy" in method_map:
                result = method_map["repos_delete_deployment_branch_policy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-deployment-branch-policy' (repos_delete_deployment_branch_policy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_file(self, **kwargs) -> GitHubResponse:
        """Delete a file (HTTP DELETE /repos/{owner}/{repo}/contents/{path})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_file" in method_map:
                result = method_map["repos_delete_file"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-file' (repos_delete_file). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_invitation(self, **kwargs) -> GitHubResponse:
        """Delete a repository invitation (HTTP DELETE /repos/{owner}/{repo}/invitations/{invitation_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_invitation" in method_map:
                result = method_map["repos_delete_invitation"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-invitation' (repos_delete_invitation). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_org_ruleset(self, **kwargs) -> GitHubResponse:
        """Delete an organization repository ruleset (HTTP DELETE /orgs/{org}/rulesets/{ruleset_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_org_ruleset" in method_map:
                result = method_map["repos_delete_org_ruleset"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-org-ruleset' (repos_delete_org_ruleset). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_pages_site(self, **kwargs) -> GitHubResponse:
        """Delete a GitHub Pages site (HTTP DELETE /repos/{owner}/{repo}/pages)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_pages_site" in method_map:
                result = method_map["repos_delete_pages_site"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-pages-site' (repos_delete_pages_site). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_pull_request_review_protection(self, **kwargs) -> GitHubResponse:
        """Delete pull request review protection (HTTP DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_pull_request_review_protection" in method_map:
                result = method_map["repos_delete_pull_request_review_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-pull-request-review-protection' (repos_delete_pull_request_review_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_release(self, **kwargs) -> GitHubResponse:
        """Delete a release (HTTP DELETE /repos/{owner}/{repo}/releases/{release_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_release" in method_map:
                result = method_map["repos_delete_release"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-release' (repos_delete_release). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_release_asset(self, **kwargs) -> GitHubResponse:
        """Delete a release asset (HTTP DELETE /repos/{owner}/{repo}/releases/assets/{asset_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_release_asset" in method_map:
                result = method_map["repos_delete_release_asset"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-release-asset' (repos_delete_release_asset). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_repo_ruleset(self, **kwargs) -> GitHubResponse:
        """Delete a repository ruleset (HTTP DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_repo_ruleset" in method_map:
                result = method_map["repos_delete_repo_ruleset"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-repo-ruleset' (repos_delete_repo_ruleset). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_tag_protection(self, **kwargs) -> GitHubResponse:
        """Closing down - Delete a tag protection state for a repository (HTTP DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_tag_protection" in method_map:
                result = method_map["repos_delete_tag_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-tag-protection' (repos_delete_tag_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_delete_webhook(self, **kwargs) -> GitHubResponse:
        """Delete a repository webhook (HTTP DELETE /repos/{owner}/{repo}/hooks/{hook_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_delete_webhook" in method_map:
                result = method_map["repos_delete_webhook"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/delete-webhook' (repos_delete_webhook). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_disable_automated_security_fixes(self, **kwargs) -> GitHubResponse:
        """Disable Dependabot security updates (HTTP DELETE /repos/{owner}/{repo}/automated-security-fixes)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_disable_automated_security_fixes" in method_map:
                result = method_map["repos_disable_automated_security_fixes"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/disable-automated-security-fixes' (repos_disable_automated_security_fixes). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_disable_deployment_protection_rule(self, **kwargs) -> GitHubResponse:
        """Disable a custom protection rule for an environment (HTTP DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_disable_deployment_protection_rule" in method_map:
                result = method_map["repos_disable_deployment_protection_rule"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/disable-deployment-protection-rule' (repos_disable_deployment_protection_rule). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_disable_private_vulnerability_reporting(self, **kwargs) -> GitHubResponse:
        """Disable private vulnerability reporting for a repository (HTTP DELETE /repos/{owner}/{repo}/private-vulnerability-reporting)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_disable_private_vulnerability_reporting" in method_map:
                result = method_map["repos_disable_private_vulnerability_reporting"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/disable-private-vulnerability-reporting' (repos_disable_private_vulnerability_reporting). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_disable_vulnerability_alerts(self, **kwargs) -> GitHubResponse:
        """Disable vulnerability alerts (HTTP DELETE /repos/{owner}/{repo}/vulnerability-alerts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_disable_vulnerability_alerts" in method_map:
                result = method_map["repos_disable_vulnerability_alerts"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/disable-vulnerability-alerts' (repos_disable_vulnerability_alerts). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_download_tarball_archive(self, **kwargs) -> GitHubResponse:
        """Download a repository archive (tar) (HTTP GET /repos/{owner}/{repo}/tarball/{ref})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_download_tarball_archive" in method_map:
                result = method_map["repos_download_tarball_archive"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/download-tarball-archive' (repos_download_tarball_archive). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_download_zipball_archive(self, **kwargs) -> GitHubResponse:
        """Download a repository archive (zip) (HTTP GET /repos/{owner}/{repo}/zipball/{ref})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_download_zipball_archive" in method_map:
                result = method_map["repos_download_zipball_archive"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/download-zipball-archive' (repos_download_zipball_archive). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_enable_automated_security_fixes(self, **kwargs) -> GitHubResponse:
        """Enable Dependabot security updates (HTTP PUT /repos/{owner}/{repo}/automated-security-fixes)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_enable_automated_security_fixes" in method_map:
                result = method_map["repos_enable_automated_security_fixes"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/enable-automated-security-fixes' (repos_enable_automated_security_fixes). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_enable_private_vulnerability_reporting(self, **kwargs) -> GitHubResponse:
        """Enable private vulnerability reporting for a repository (HTTP PUT /repos/{owner}/{repo}/private-vulnerability-reporting)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_enable_private_vulnerability_reporting" in method_map:
                result = method_map["repos_enable_private_vulnerability_reporting"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/enable-private-vulnerability-reporting' (repos_enable_private_vulnerability_reporting). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_enable_vulnerability_alerts(self, **kwargs) -> GitHubResponse:
        """Enable vulnerability alerts (HTTP PUT /repos/{owner}/{repo}/vulnerability-alerts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_enable_vulnerability_alerts" in method_map:
                result = method_map["repos_enable_vulnerability_alerts"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/enable-vulnerability-alerts' (repos_enable_vulnerability_alerts). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_generate_release_notes(self, **kwargs) -> GitHubResponse:
        """Generate release notes content for a release (HTTP POST /repos/{owner}/{repo}/releases/generate-notes)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_generate_release_notes" in method_map:
                result = method_map["repos_generate_release_notes"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/generate-release-notes' (repos_generate_release_notes). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get(self, **kwargs) -> GitHubResponse:
        """Get a repository (HTTP GET /repos/{owner}/{repo})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get" in method_map:
                result = method_map["repos_get"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get' (repos_get). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_access_restrictions(self, **kwargs) -> GitHubResponse:
        """Get access restrictions (HTTP GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_access_restrictions" in method_map:
                result = method_map["repos_get_access_restrictions"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-access-restrictions' (repos_get_access_restrictions). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_admin_branch_protection(self, **kwargs) -> GitHubResponse:
        """Get admin branch protection (HTTP GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_admin_branch_protection" in method_map:
                result = method_map["repos_get_admin_branch_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-admin-branch-protection' (repos_get_admin_branch_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_all_deployment_protection_rules(self, **kwargs) -> GitHubResponse:
        """Get all deployment protection rules for an environment (HTTP GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_all_deployment_protection_rules" in method_map:
                result = method_map["repos_get_all_deployment_protection_rules"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-all-deployment-protection-rules' (repos_get_all_deployment_protection_rules). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_all_environments(self, **kwargs) -> GitHubResponse:
        """List environments (HTTP GET /repos/{owner}/{repo}/environments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_all_environments" in method_map:
                result = method_map["repos_get_all_environments"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-all-environments' (repos_get_all_environments). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_all_status_check_contexts(self, **kwargs) -> GitHubResponse:
        """Get all status check contexts (HTTP GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_all_status_check_contexts" in method_map:
                result = method_map["repos_get_all_status_check_contexts"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-all-status-check-contexts' (repos_get_all_status_check_contexts). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_all_topics(self, **kwargs) -> GitHubResponse:
        """Get all repository topics (HTTP GET /repos/{owner}/{repo}/topics)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_all_topics" in method_map:
                result = method_map["repos_get_all_topics"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-all-topics' (repos_get_all_topics). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_apps_with_access_to_protected_branch(self, **kwargs) -> GitHubResponse:
        """Get apps with access to the protected branch (HTTP GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_apps_with_access_to_protected_branch" in method_map:
                result = method_map["repos_get_apps_with_access_to_protected_branch"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-apps-with-access-to-protected-branch' (repos_get_apps_with_access_to_protected_branch). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_autolink(self, **kwargs) -> GitHubResponse:
        """Get an autolink reference of a repository (HTTP GET /repos/{owner}/{repo}/autolinks/{autolink_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_autolink" in method_map:
                result = method_map["repos_get_autolink"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-autolink' (repos_get_autolink). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_branch(self, **kwargs) -> GitHubResponse:
        """Get a branch (HTTP GET /repos/{owner}/{repo}/branches/{branch})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_branch" in method_map:
                result = method_map["repos_get_branch"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-branch' (repos_get_branch). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_branch_protection(self, **kwargs) -> GitHubResponse:
        """Get branch protection (HTTP GET /repos/{owner}/{repo}/branches/{branch}/protection)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_branch_protection" in method_map:
                result = method_map["repos_get_branch_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-branch-protection' (repos_get_branch_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_branch_rules(self, **kwargs) -> GitHubResponse:
        """Get rules for a branch (HTTP GET /repos/{owner}/{repo}/rules/branches/{branch})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_branch_rules" in method_map:
                result = method_map["repos_get_branch_rules"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-branch-rules' (repos_get_branch_rules). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_clones(self, **kwargs) -> GitHubResponse:
        """Get repository clones (HTTP GET /repos/{owner}/{repo}/traffic/clones)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_clones" in method_map:
                result = method_map["repos_get_clones"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-clones' (repos_get_clones). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_code_frequency_stats(self, **kwargs) -> GitHubResponse:
        """Get the weekly commit activity (HTTP GET /repos/{owner}/{repo}/stats/code_frequency)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_code_frequency_stats" in method_map:
                result = method_map["repos_get_code_frequency_stats"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-code-frequency-stats' (repos_get_code_frequency_stats). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_collaborator_permission_level(self, **kwargs) -> GitHubResponse:
        """Get repository permissions for a user (HTTP GET /repos/{owner}/{repo}/collaborators/{username}/permission)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_collaborator_permission_level" in method_map:
                result = method_map["repos_get_collaborator_permission_level"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-collaborator-permission-level' (repos_get_collaborator_permission_level). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_combined_status_for_ref(self, **kwargs) -> GitHubResponse:
        """Get the combined status for a specific reference (HTTP GET /repos/{owner}/{repo}/commits/{ref}/status)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_combined_status_for_ref" in method_map:
                result = method_map["repos_get_combined_status_for_ref"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-combined-status-for-ref' (repos_get_combined_status_for_ref). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_commit(self, **kwargs) -> GitHubResponse:
        """Get a commit (HTTP GET /repos/{owner}/{repo}/commits/{ref})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_commit" in method_map:
                result = method_map["repos_get_commit"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-commit' (repos_get_commit). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_commit_activity_stats(self, **kwargs) -> GitHubResponse:
        """Get the last year of commit activity (HTTP GET /repos/{owner}/{repo}/stats/commit_activity)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_commit_activity_stats" in method_map:
                result = method_map["repos_get_commit_activity_stats"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-commit-activity-stats' (repos_get_commit_activity_stats). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_commit_comment(self, **kwargs) -> GitHubResponse:
        """Get a commit comment (HTTP GET /repos/{owner}/{repo}/comments/{comment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_commit_comment" in method_map:
                result = method_map["repos_get_commit_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-commit-comment' (repos_get_commit_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_commit_signature_protection(self, **kwargs) -> GitHubResponse:
        """Get commit signature protection (HTTP GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_commit_signature_protection" in method_map:
                result = method_map["repos_get_commit_signature_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-commit-signature-protection' (repos_get_commit_signature_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_community_profile_metrics(self, **kwargs) -> GitHubResponse:
        """Get community profile metrics (HTTP GET /repos/{owner}/{repo}/community/profile)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_community_profile_metrics" in method_map:
                result = method_map["repos_get_community_profile_metrics"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-community-profile-metrics' (repos_get_community_profile_metrics). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_content(self, **kwargs) -> GitHubResponse:
        """Get repository content (HTTP GET /repos/{owner}/{repo}/contents/{path})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_content" in method_map:
                result = method_map["repos_get_content"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-content' (repos_get_content). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_contributors_stats(self, **kwargs) -> GitHubResponse:
        """Get all contributor commit activity (HTTP GET /repos/{owner}/{repo}/stats/contributors)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_contributors_stats" in method_map:
                result = method_map["repos_get_contributors_stats"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-contributors-stats' (repos_get_contributors_stats). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_custom_deployment_protection_rule(self, **kwargs) -> GitHubResponse:
        """Get a custom deployment protection rule (HTTP GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_custom_deployment_protection_rule" in method_map:
                result = method_map["repos_get_custom_deployment_protection_rule"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-custom-deployment-protection-rule' (repos_get_custom_deployment_protection_rule). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_deploy_key(self, **kwargs) -> GitHubResponse:
        """Get a deploy key (HTTP GET /repos/{owner}/{repo}/keys/{key_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_deploy_key" in method_map:
                result = method_map["repos_get_deploy_key"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-deploy-key' (repos_get_deploy_key). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_deployment(self, **kwargs) -> GitHubResponse:
        """Get a deployment (HTTP GET /repos/{owner}/{repo}/deployments/{deployment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_deployment" in method_map:
                result = method_map["repos_get_deployment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-deployment' (repos_get_deployment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_deployment_branch_policy(self, **kwargs) -> GitHubResponse:
        """Get a deployment branch policy (HTTP GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_deployment_branch_policy" in method_map:
                result = method_map["repos_get_deployment_branch_policy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-deployment-branch-policy' (repos_get_deployment_branch_policy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_deployment_status(self, **kwargs) -> GitHubResponse:
        """Get a deployment status (HTTP GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_deployment_status" in method_map:
                result = method_map["repos_get_deployment_status"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-deployment-status' (repos_get_deployment_status). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_environment(self, **kwargs) -> GitHubResponse:
        """Get an environment (HTTP GET /repos/{owner}/{repo}/environments/{environment_name})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_environment" in method_map:
                result = method_map["repos_get_environment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-environment' (repos_get_environment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_latest_pages_build(self, **kwargs) -> GitHubResponse:
        """Get latest Pages build (HTTP GET /repos/{owner}/{repo}/pages/builds/latest)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_latest_pages_build" in method_map:
                result = method_map["repos_get_latest_pages_build"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-latest-pages-build' (repos_get_latest_pages_build). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_latest_release(self, **kwargs) -> GitHubResponse:
        """Get the latest release (HTTP GET /repos/{owner}/{repo}/releases/latest)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_latest_release" in method_map:
                result = method_map["repos_get_latest_release"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-latest-release' (repos_get_latest_release). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_org_rule_suite(self, **kwargs) -> GitHubResponse:
        """Get an organization rule suite (HTTP GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_org_rule_suite" in method_map:
                result = method_map["repos_get_org_rule_suite"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-org-rule-suite' (repos_get_org_rule_suite). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_org_rule_suites(self, **kwargs) -> GitHubResponse:
        """List organization rule suites (HTTP GET /orgs/{org}/rulesets/rule-suites)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_org_rule_suites" in method_map:
                result = method_map["repos_get_org_rule_suites"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-org-rule-suites' (repos_get_org_rule_suites). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_org_ruleset(self, **kwargs) -> GitHubResponse:
        """Get an organization repository ruleset (HTTP GET /orgs/{org}/rulesets/{ruleset_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_org_ruleset" in method_map:
                result = method_map["repos_get_org_ruleset"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-org-ruleset' (repos_get_org_ruleset). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_org_rulesets(self, **kwargs) -> GitHubResponse:
        """Get all organization repository rulesets (HTTP GET /orgs/{org}/rulesets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_org_rulesets" in method_map:
                result = method_map["repos_get_org_rulesets"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-org-rulesets' (repos_get_org_rulesets). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_pages(self, **kwargs) -> GitHubResponse:
        """Get a GitHub Pages site (HTTP GET /repos/{owner}/{repo}/pages)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_pages" in method_map:
                result = method_map["repos_get_pages"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-pages' (repos_get_pages). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_pages_build(self, **kwargs) -> GitHubResponse:
        """Get GitHub Pages build (HTTP GET /repos/{owner}/{repo}/pages/builds/{build_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_pages_build" in method_map:
                result = method_map["repos_get_pages_build"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-pages-build' (repos_get_pages_build). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_pages_deployment(self, **kwargs) -> GitHubResponse:
        """Get the status of a GitHub Pages deployment (HTTP GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_pages_deployment" in method_map:
                result = method_map["repos_get_pages_deployment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-pages-deployment' (repos_get_pages_deployment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_pages_health_check(self, **kwargs) -> GitHubResponse:
        """Get a DNS health check for GitHub Pages (HTTP GET /repos/{owner}/{repo}/pages/health)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_pages_health_check" in method_map:
                result = method_map["repos_get_pages_health_check"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-pages-health-check' (repos_get_pages_health_check). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_participation_stats(self, **kwargs) -> GitHubResponse:
        """Get the weekly commit count (HTTP GET /repos/{owner}/{repo}/stats/participation)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_participation_stats" in method_map:
                result = method_map["repos_get_participation_stats"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-participation-stats' (repos_get_participation_stats). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_pull_request_review_protection(self, **kwargs) -> GitHubResponse:
        """Get pull request review protection (HTTP GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_pull_request_review_protection" in method_map:
                result = method_map["repos_get_pull_request_review_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-pull-request-review-protection' (repos_get_pull_request_review_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_punch_card_stats(self, **kwargs) -> GitHubResponse:
        """Get the hourly commit count for each day (HTTP GET /repos/{owner}/{repo}/stats/punch_card)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_punch_card_stats" in method_map:
                result = method_map["repos_get_punch_card_stats"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-punch-card-stats' (repos_get_punch_card_stats). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_readme(self, **kwargs) -> GitHubResponse:
        """Get a repository README (HTTP GET /repos/{owner}/{repo}/readme)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_readme" in method_map:
                result = method_map["repos_get_readme"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-readme' (repos_get_readme). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_readme_in_directory(self, **kwargs) -> GitHubResponse:
        """Get a repository README for a directory (HTTP GET /repos/{owner}/{repo}/readme/{dir})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_readme_in_directory" in method_map:
                result = method_map["repos_get_readme_in_directory"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-readme-in-directory' (repos_get_readme_in_directory). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_release(self, **kwargs) -> GitHubResponse:
        """Get a release (HTTP GET /repos/{owner}/{repo}/releases/{release_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_release" in method_map:
                result = method_map["repos_get_release"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-release' (repos_get_release). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_release_asset(self, **kwargs) -> GitHubResponse:
        """Get a release asset (HTTP GET /repos/{owner}/{repo}/releases/assets/{asset_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_release_asset" in method_map:
                result = method_map["repos_get_release_asset"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-release-asset' (repos_get_release_asset). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_release_by_tag(self, **kwargs) -> GitHubResponse:
        """Get a release by tag name (HTTP GET /repos/{owner}/{repo}/releases/tags/{tag})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_release_by_tag" in method_map:
                result = method_map["repos_get_release_by_tag"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-release-by-tag' (repos_get_release_by_tag). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_repo_rule_suite(self, **kwargs) -> GitHubResponse:
        """Get a repository rule suite (HTTP GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_repo_rule_suite" in method_map:
                result = method_map["repos_get_repo_rule_suite"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-repo-rule-suite' (repos_get_repo_rule_suite). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_repo_rule_suites(self, **kwargs) -> GitHubResponse:
        """List repository rule suites (HTTP GET /repos/{owner}/{repo}/rulesets/rule-suites)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_repo_rule_suites" in method_map:
                result = method_map["repos_get_repo_rule_suites"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-repo-rule-suites' (repos_get_repo_rule_suites). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_repo_ruleset(self, **kwargs) -> GitHubResponse:
        """Get a repository ruleset (HTTP GET /repos/{owner}/{repo}/rulesets/{ruleset_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_repo_ruleset" in method_map:
                result = method_map["repos_get_repo_ruleset"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-repo-ruleset' (repos_get_repo_ruleset). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_repo_ruleset_history(self, **kwargs) -> GitHubResponse:
        """Get repository ruleset history (HTTP GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_repo_ruleset_history" in method_map:
                result = method_map["repos_get_repo_ruleset_history"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-repo-ruleset-history' (repos_get_repo_ruleset_history). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_repo_ruleset_version(self, **kwargs) -> GitHubResponse:
        """Get repository ruleset version (HTTP GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_repo_ruleset_version" in method_map:
                result = method_map["repos_get_repo_ruleset_version"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-repo-ruleset-version' (repos_get_repo_ruleset_version). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_repo_rulesets(self, **kwargs) -> GitHubResponse:
        """Get all repository rulesets (HTTP GET /repos/{owner}/{repo}/rulesets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_repo_rulesets" in method_map:
                result = method_map["repos_get_repo_rulesets"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-repo-rulesets' (repos_get_repo_rulesets). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_status_checks_protection(self, **kwargs) -> GitHubResponse:
        """Get status checks protection (HTTP GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_status_checks_protection" in method_map:
                result = method_map["repos_get_status_checks_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-status-checks-protection' (repos_get_status_checks_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_teams_with_access_to_protected_branch(self, **kwargs) -> GitHubResponse:
        """Get teams with access to the protected branch (HTTP GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_teams_with_access_to_protected_branch" in method_map:
                result = method_map["repos_get_teams_with_access_to_protected_branch"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-teams-with-access-to-protected-branch' (repos_get_teams_with_access_to_protected_branch). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_top_paths(self, **kwargs) -> GitHubResponse:
        """Get top referral paths (HTTP GET /repos/{owner}/{repo}/traffic/popular/paths)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_top_paths" in method_map:
                result = method_map["repos_get_top_paths"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-top-paths' (repos_get_top_paths). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_top_referrers(self, **kwargs) -> GitHubResponse:
        """Get top referral sources (HTTP GET /repos/{owner}/{repo}/traffic/popular/referrers)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_top_referrers" in method_map:
                result = method_map["repos_get_top_referrers"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-top-referrers' (repos_get_top_referrers). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_users_with_access_to_protected_branch(self, **kwargs) -> GitHubResponse:
        """Get users with access to the protected branch (HTTP GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_users_with_access_to_protected_branch" in method_map:
                result = method_map["repos_get_users_with_access_to_protected_branch"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-users-with-access-to-protected-branch' (repos_get_users_with_access_to_protected_branch). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_views(self, **kwargs) -> GitHubResponse:
        """Get page views (HTTP GET /repos/{owner}/{repo}/traffic/views)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_views" in method_map:
                result = method_map["repos_get_views"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-views' (repos_get_views). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_webhook(self, **kwargs) -> GitHubResponse:
        """Get a repository webhook (HTTP GET /repos/{owner}/{repo}/hooks/{hook_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_webhook" in method_map:
                result = method_map["repos_get_webhook"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-webhook' (repos_get_webhook). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_webhook_config_for_repo(self, **kwargs) -> GitHubResponse:
        """Get a webhook configuration for a repository (HTTP GET /repos/{owner}/{repo}/hooks/{hook_id}/config)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_webhook_config_for_repo" in method_map:
                result = method_map["repos_get_webhook_config_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-webhook-config-for-repo' (repos_get_webhook_config_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_get_webhook_delivery(self, **kwargs) -> GitHubResponse:
        """Get a delivery for a repository webhook (HTTP GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_get_webhook_delivery" in method_map:
                result = method_map["repos_get_webhook_delivery"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/get-webhook-delivery' (repos_get_webhook_delivery). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_activities(self, **kwargs) -> GitHubResponse:
        """List repository activities (HTTP GET /repos/{owner}/{repo}/activity)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_activities" in method_map:
                result = method_map["repos_list_activities"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-activities' (repos_list_activities). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_attestations(self, **kwargs) -> GitHubResponse:
        """List attestations (HTTP GET /repos/{owner}/{repo}/attestations/{subject_digest})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_attestations" in method_map:
                result = method_map["repos_list_attestations"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-attestations' (repos_list_attestations). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_autolinks(self, **kwargs) -> GitHubResponse:
        """Get all autolinks of a repository (HTTP GET /repos/{owner}/{repo}/autolinks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_autolinks" in method_map:
                result = method_map["repos_list_autolinks"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-autolinks' (repos_list_autolinks). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_branches(self, **kwargs) -> GitHubResponse:
        """List branches (HTTP GET /repos/{owner}/{repo}/branches)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_branches" in method_map:
                result = method_map["repos_list_branches"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-branches' (repos_list_branches). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_branches_for_head_commit(self, **kwargs) -> GitHubResponse:
        """List branches for HEAD commit (HTTP GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_branches_for_head_commit" in method_map:
                result = method_map["repos_list_branches_for_head_commit"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-branches-for-head-commit' (repos_list_branches_for_head_commit). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_collaborators(self, **kwargs) -> GitHubResponse:
        """List repository collaborators (HTTP GET /repos/{owner}/{repo}/collaborators)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_collaborators" in method_map:
                result = method_map["repos_list_collaborators"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-collaborators' (repos_list_collaborators). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_comments_for_commit(self, **kwargs) -> GitHubResponse:
        """List commit comments (HTTP GET /repos/{owner}/{repo}/commits/{commit_sha}/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_comments_for_commit" in method_map:
                result = method_map["repos_list_comments_for_commit"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-comments-for-commit' (repos_list_comments_for_commit). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_commit_comments_for_repo(self, **kwargs) -> GitHubResponse:
        """List commit comments for a repository (HTTP GET /repos/{owner}/{repo}/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_commit_comments_for_repo" in method_map:
                result = method_map["repos_list_commit_comments_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-commit-comments-for-repo' (repos_list_commit_comments_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_commit_statuses_for_ref(self, **kwargs) -> GitHubResponse:
        """List commit statuses for a reference (HTTP GET /repos/{owner}/{repo}/commits/{ref}/statuses)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_commit_statuses_for_ref" in method_map:
                result = method_map["repos_list_commit_statuses_for_ref"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-commit-statuses-for-ref' (repos_list_commit_statuses_for_ref). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_commits(self, **kwargs) -> GitHubResponse:
        """List commits (HTTP GET /repos/{owner}/{repo}/commits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_commits" in method_map:
                result = method_map["repos_list_commits"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-commits' (repos_list_commits). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_contributors(self, **kwargs) -> GitHubResponse:
        """List repository contributors (HTTP GET /repos/{owner}/{repo}/contributors)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_contributors" in method_map:
                result = method_map["repos_list_contributors"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-contributors' (repos_list_contributors). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_custom_deployment_rule_integrations(self, **kwargs) -> GitHubResponse:
        """List custom deployment rule integrations available for an environment (HTTP GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_custom_deployment_rule_integrations" in method_map:
                result = method_map["repos_list_custom_deployment_rule_integrations"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-custom-deployment-rule-integrations' (repos_list_custom_deployment_rule_integrations). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_deploy_keys(self, **kwargs) -> GitHubResponse:
        """List deploy keys (HTTP GET /repos/{owner}/{repo}/keys)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_deploy_keys" in method_map:
                result = method_map["repos_list_deploy_keys"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-deploy-keys' (repos_list_deploy_keys). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_deployment_branch_policies(self, **kwargs) -> GitHubResponse:
        """List deployment branch policies (HTTP GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_deployment_branch_policies" in method_map:
                result = method_map["repos_list_deployment_branch_policies"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-deployment-branch-policies' (repos_list_deployment_branch_policies). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_deployment_statuses(self, **kwargs) -> GitHubResponse:
        """List deployment statuses (HTTP GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_deployment_statuses" in method_map:
                result = method_map["repos_list_deployment_statuses"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-deployment-statuses' (repos_list_deployment_statuses). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_deployments(self, **kwargs) -> GitHubResponse:
        """List deployments (HTTP GET /repos/{owner}/{repo}/deployments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_deployments" in method_map:
                result = method_map["repos_list_deployments"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-deployments' (repos_list_deployments). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List repositories for the authenticated user (HTTP GET /user/repos)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_for_authenticated_user" in method_map:
                result = method_map["repos_list_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-for-authenticated-user' (repos_list_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_for_org(self, **kwargs) -> GitHubResponse:
        """List organization repositories (HTTP GET /orgs/{org}/repos)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_for_org" in method_map:
                result = method_map["repos_list_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-for-org' (repos_list_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_for_user(self, **kwargs) -> GitHubResponse:
        """List repositories for a user (HTTP GET /users/{username}/repos)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_for_user" in method_map:
                result = method_map["repos_list_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-for-user' (repos_list_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_forks(self, **kwargs) -> GitHubResponse:
        """List forks (HTTP GET /repos/{owner}/{repo}/forks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_forks" in method_map:
                result = method_map["repos_list_forks"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-forks' (repos_list_forks). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_invitations(self, **kwargs) -> GitHubResponse:
        """List repository invitations (HTTP GET /repos/{owner}/{repo}/invitations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_invitations" in method_map:
                result = method_map["repos_list_invitations"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-invitations' (repos_list_invitations). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_invitations_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List repository invitations for the authenticated user (HTTP GET /user/repository_invitations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_invitations_for_authenticated_user" in method_map:
                result = method_map["repos_list_invitations_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-invitations-for-authenticated-user' (repos_list_invitations_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_languages(self, **kwargs) -> GitHubResponse:
        """List repository languages (HTTP GET /repos/{owner}/{repo}/languages)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_languages" in method_map:
                result = method_map["repos_list_languages"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-languages' (repos_list_languages). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_pages_builds(self, **kwargs) -> GitHubResponse:
        """List GitHub Pages builds (HTTP GET /repos/{owner}/{repo}/pages/builds)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_pages_builds" in method_map:
                result = method_map["repos_list_pages_builds"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-pages-builds' (repos_list_pages_builds). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_public(self, **kwargs) -> GitHubResponse:
        """List public repositories (HTTP GET /repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_public" in method_map:
                result = method_map["repos_list_public"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-public' (repos_list_public). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_pull_requests_associated_with_commit(self, **kwargs) -> GitHubResponse:
        """List pull requests associated with a commit (HTTP GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_pull_requests_associated_with_commit" in method_map:
                result = method_map["repos_list_pull_requests_associated_with_commit"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-pull-requests-associated-with-commit' (repos_list_pull_requests_associated_with_commit). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_release_assets(self, **kwargs) -> GitHubResponse:
        """List release assets (HTTP GET /repos/{owner}/{repo}/releases/{release_id}/assets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_release_assets" in method_map:
                result = method_map["repos_list_release_assets"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-release-assets' (repos_list_release_assets). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_releases(self, **kwargs) -> GitHubResponse:
        """List releases (HTTP GET /repos/{owner}/{repo}/releases)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_releases" in method_map:
                result = method_map["repos_list_releases"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-releases' (repos_list_releases). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_tag_protection(self, **kwargs) -> GitHubResponse:
        """Closing down - List tag protection states for a repository (HTTP GET /repos/{owner}/{repo}/tags/protection)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_tag_protection" in method_map:
                result = method_map["repos_list_tag_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-tag-protection' (repos_list_tag_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_tags(self, **kwargs) -> GitHubResponse:
        """List repository tags (HTTP GET /repos/{owner}/{repo}/tags)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_tags" in method_map:
                result = method_map["repos_list_tags"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-tags' (repos_list_tags). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_teams(self, **kwargs) -> GitHubResponse:
        """List repository teams (HTTP GET /repos/{owner}/{repo}/teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_teams" in method_map:
                result = method_map["repos_list_teams"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-teams' (repos_list_teams). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_webhook_deliveries(self, **kwargs) -> GitHubResponse:
        """List deliveries for a repository webhook (HTTP GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_webhook_deliveries" in method_map:
                result = method_map["repos_list_webhook_deliveries"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-webhook-deliveries' (repos_list_webhook_deliveries). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_list_webhooks(self, **kwargs) -> GitHubResponse:
        """List repository webhooks (HTTP GET /repos/{owner}/{repo}/hooks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_list_webhooks" in method_map:
                result = method_map["repos_list_webhooks"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/list-webhooks' (repos_list_webhooks). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_merge(self, **kwargs) -> GitHubResponse:
        """Merge a branch (HTTP POST /repos/{owner}/{repo}/merges)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_merge" in method_map:
                result = method_map["repos_merge"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/merge' (repos_merge). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_merge_upstream(self, **kwargs) -> GitHubResponse:
        """Sync a fork branch with the upstream repository (HTTP POST /repos/{owner}/{repo}/merge-upstream)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_merge_upstream" in method_map:
                result = method_map["repos_merge_upstream"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/merge-upstream' (repos_merge_upstream). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_ping_webhook(self, **kwargs) -> GitHubResponse:
        """Ping a repository webhook (HTTP POST /repos/{owner}/{repo}/hooks/{hook_id}/pings)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_ping_webhook" in method_map:
                result = method_map["repos_ping_webhook"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/ping-webhook' (repos_ping_webhook). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_redeliver_webhook_delivery(self, **kwargs) -> GitHubResponse:
        """Redeliver a delivery for a repository webhook (HTTP POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_redeliver_webhook_delivery" in method_map:
                result = method_map["repos_redeliver_webhook_delivery"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/redeliver-webhook-delivery' (repos_redeliver_webhook_delivery). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_remove_app_access_restrictions(self, **kwargs) -> GitHubResponse:
        """Remove app access restrictions (HTTP DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_remove_app_access_restrictions" in method_map:
                result = method_map["repos_remove_app_access_restrictions"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/remove-app-access-restrictions' (repos_remove_app_access_restrictions). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_remove_collaborator(self, **kwargs) -> GitHubResponse:
        """Remove a repository collaborator (HTTP DELETE /repos/{owner}/{repo}/collaborators/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_remove_collaborator" in method_map:
                result = method_map["repos_remove_collaborator"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/remove-collaborator' (repos_remove_collaborator). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_remove_status_check_contexts(self, **kwargs) -> GitHubResponse:
        """Remove status check contexts (HTTP DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_remove_status_check_contexts" in method_map:
                result = method_map["repos_remove_status_check_contexts"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/remove-status-check-contexts' (repos_remove_status_check_contexts). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_remove_status_check_protection(self, **kwargs) -> GitHubResponse:
        """Remove status check protection (HTTP DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_remove_status_check_protection" in method_map:
                result = method_map["repos_remove_status_check_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/remove-status-check-protection' (repos_remove_status_check_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_remove_team_access_restrictions(self, **kwargs) -> GitHubResponse:
        """Remove team access restrictions (HTTP DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_remove_team_access_restrictions" in method_map:
                result = method_map["repos_remove_team_access_restrictions"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/remove-team-access-restrictions' (repos_remove_team_access_restrictions). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_remove_user_access_restrictions(self, **kwargs) -> GitHubResponse:
        """Remove user access restrictions (HTTP DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_remove_user_access_restrictions" in method_map:
                result = method_map["repos_remove_user_access_restrictions"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/remove-user-access-restrictions' (repos_remove_user_access_restrictions). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_rename_branch(self, **kwargs) -> GitHubResponse:
        """Rename a branch (HTTP POST /repos/{owner}/{repo}/branches/{branch}/rename)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_rename_branch" in method_map:
                result = method_map["repos_rename_branch"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/rename-branch' (repos_rename_branch). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_replace_all_topics(self, **kwargs) -> GitHubResponse:
        """Replace all repository topics (HTTP PUT /repos/{owner}/{repo}/topics)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_replace_all_topics" in method_map:
                result = method_map["repos_replace_all_topics"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/replace-all-topics' (repos_replace_all_topics). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_request_pages_build(self, **kwargs) -> GitHubResponse:
        """Request a GitHub Pages build (HTTP POST /repos/{owner}/{repo}/pages/builds)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_request_pages_build" in method_map:
                result = method_map["repos_request_pages_build"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/request-pages-build' (repos_request_pages_build). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_set_admin_branch_protection(self, **kwargs) -> GitHubResponse:
        """Set admin branch protection (HTTP POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_set_admin_branch_protection" in method_map:
                result = method_map["repos_set_admin_branch_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/set-admin-branch-protection' (repos_set_admin_branch_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_set_app_access_restrictions(self, **kwargs) -> GitHubResponse:
        """Set app access restrictions (HTTP PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_set_app_access_restrictions" in method_map:
                result = method_map["repos_set_app_access_restrictions"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/set-app-access-restrictions' (repos_set_app_access_restrictions). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_set_status_check_contexts(self, **kwargs) -> GitHubResponse:
        """Set status check contexts (HTTP PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_set_status_check_contexts" in method_map:
                result = method_map["repos_set_status_check_contexts"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/set-status-check-contexts' (repos_set_status_check_contexts). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_set_team_access_restrictions(self, **kwargs) -> GitHubResponse:
        """Set team access restrictions (HTTP PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_set_team_access_restrictions" in method_map:
                result = method_map["repos_set_team_access_restrictions"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/set-team-access-restrictions' (repos_set_team_access_restrictions). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_set_user_access_restrictions(self, **kwargs) -> GitHubResponse:
        """Set user access restrictions (HTTP PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_set_user_access_restrictions" in method_map:
                result = method_map["repos_set_user_access_restrictions"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/set-user-access-restrictions' (repos_set_user_access_restrictions). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_test_push_webhook(self, **kwargs) -> GitHubResponse:
        """Test the push repository webhook (HTTP POST /repos/{owner}/{repo}/hooks/{hook_id}/tests)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_test_push_webhook" in method_map:
                result = method_map["repos_test_push_webhook"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/test-push-webhook' (repos_test_push_webhook). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_transfer(self, **kwargs) -> GitHubResponse:
        """Transfer a repository (HTTP POST /repos/{owner}/{repo}/transfer)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_transfer" in method_map:
                result = method_map["repos_transfer"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/transfer' (repos_transfer). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_update(self, **kwargs) -> GitHubResponse:
        """Update a repository (HTTP PATCH /repos/{owner}/{repo})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_update" in method_map:
                result = method_map["repos_update"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/update' (repos_update). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_update_branch_protection(self, **kwargs) -> GitHubResponse:
        """Update branch protection (HTTP PUT /repos/{owner}/{repo}/branches/{branch}/protection)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_update_branch_protection" in method_map:
                result = method_map["repos_update_branch_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/update-branch-protection' (repos_update_branch_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_update_commit_comment(self, **kwargs) -> GitHubResponse:
        """Update a commit comment (HTTP PATCH /repos/{owner}/{repo}/comments/{comment_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_update_commit_comment" in method_map:
                result = method_map["repos_update_commit_comment"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/update-commit-comment' (repos_update_commit_comment). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_update_deployment_branch_policy(self, **kwargs) -> GitHubResponse:
        """Update a deployment branch policy (HTTP PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_update_deployment_branch_policy" in method_map:
                result = method_map["repos_update_deployment_branch_policy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/update-deployment-branch-policy' (repos_update_deployment_branch_policy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_update_information_about_pages_site(self, **kwargs) -> GitHubResponse:
        """Update information about a GitHub Pages site (HTTP PUT /repos/{owner}/{repo}/pages)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_update_information_about_pages_site" in method_map:
                result = method_map["repos_update_information_about_pages_site"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/update-information-about-pages-site' (repos_update_information_about_pages_site). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_update_invitation(self, **kwargs) -> GitHubResponse:
        """Update a repository invitation (HTTP PATCH /repos/{owner}/{repo}/invitations/{invitation_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_update_invitation" in method_map:
                result = method_map["repos_update_invitation"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/update-invitation' (repos_update_invitation). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_update_org_ruleset(self, **kwargs) -> GitHubResponse:
        """Update an organization repository ruleset (HTTP PUT /orgs/{org}/rulesets/{ruleset_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_update_org_ruleset" in method_map:
                result = method_map["repos_update_org_ruleset"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/update-org-ruleset' (repos_update_org_ruleset). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_update_pull_request_review_protection(self, **kwargs) -> GitHubResponse:
        """Update pull request review protection (HTTP PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_update_pull_request_review_protection" in method_map:
                result = method_map["repos_update_pull_request_review_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/update-pull-request-review-protection' (repos_update_pull_request_review_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_update_release(self, **kwargs) -> GitHubResponse:
        """Update a release (HTTP PATCH /repos/{owner}/{repo}/releases/{release_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_update_release" in method_map:
                result = method_map["repos_update_release"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/update-release' (repos_update_release). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_update_release_asset(self, **kwargs) -> GitHubResponse:
        """Update a release asset (HTTP PATCH /repos/{owner}/{repo}/releases/assets/{asset_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_update_release_asset" in method_map:
                result = method_map["repos_update_release_asset"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/update-release-asset' (repos_update_release_asset). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_update_repo_ruleset(self, **kwargs) -> GitHubResponse:
        """Update a repository ruleset (HTTP PUT /repos/{owner}/{repo}/rulesets/{ruleset_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_update_repo_ruleset" in method_map:
                result = method_map["repos_update_repo_ruleset"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/update-repo-ruleset' (repos_update_repo_ruleset). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_update_status_check_protection(self, **kwargs) -> GitHubResponse:
        """Update status check protection (HTTP PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_update_status_check_protection" in method_map:
                result = method_map["repos_update_status_check_protection"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/update-status-check-protection' (repos_update_status_check_protection). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_update_webhook(self, **kwargs) -> GitHubResponse:
        """Update a repository webhook (HTTP PATCH /repos/{owner}/{repo}/hooks/{hook_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_update_webhook" in method_map:
                result = method_map["repos_update_webhook"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/update-webhook' (repos_update_webhook). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_update_webhook_config_for_repo(self, **kwargs) -> GitHubResponse:
        """Update a webhook configuration for a repository (HTTP PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_update_webhook_config_for_repo" in method_map:
                result = method_map["repos_update_webhook_config_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/update-webhook-config-for-repo' (repos_update_webhook_config_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def repos_upload_release_asset(self, **kwargs) -> GitHubResponse:
        """Upload a release asset (HTTP POST /repos/{owner}/{repo}/releases/{release_id}/assets)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "repos_upload_release_asset" in method_map:
                result = method_map["repos_upload_release_asset"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'repos/upload-release-asset' (repos_upload_release_asset). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def search_code(self, **kwargs) -> GitHubResponse:
        """Search code (HTTP GET /search/code)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "search_code" in method_map:
                result = method_map["search_code"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'search/code' (search_code). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def search_commits(self, **kwargs) -> GitHubResponse:
        """Search commits (HTTP GET /search/commits)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "search_commits" in method_map:
                result = method_map["search_commits"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'search/commits' (search_commits). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def search_issues_and_pull_requests(self, **kwargs) -> GitHubResponse:
        """Search issues and pull requests (HTTP GET /search/issues)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "search_issues_and_pull_requests" in method_map:
                result = method_map["search_issues_and_pull_requests"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'search/issues-and-pull-requests' (search_issues_and_pull_requests). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def search_labels(self, **kwargs) -> GitHubResponse:
        """Search labels (HTTP GET /search/labels)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "search_labels" in method_map:
                result = method_map["search_labels"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'search/labels' (search_labels). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def search_repos(self, **kwargs) -> GitHubResponse:
        """Search repositories (HTTP GET /search/repositories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "search_repos" in method_map:
                result = method_map["search_repos"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'search/repos' (search_repos). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def search_topics(self, **kwargs) -> GitHubResponse:
        """Search topics (HTTP GET /search/topics)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "search_topics" in method_map:
                result = method_map["search_topics"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'search/topics' (search_topics). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def search_users(self, **kwargs) -> GitHubResponse:
        """Search users (HTTP GET /search/users)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "search_users" in method_map:
                result = method_map["search_users"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'search/users' (search_users). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def secret_scanning_create_push_protection_bypass(self, **kwargs) -> GitHubResponse:
        """Create a push protection bypass (HTTP POST /repos/{owner}/{repo}/secret-scanning/push-protection-bypasses)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "secret_scanning_create_push_protection_bypass" in method_map:
                result = method_map["secret_scanning_create_push_protection_bypass"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'secret-scanning/create-push-protection-bypass' (secret_scanning_create_push_protection_bypass). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def secret_scanning_get_alert(self, **kwargs) -> GitHubResponse:
        """Get a secret scanning alert (HTTP GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "secret_scanning_get_alert" in method_map:
                result = method_map["secret_scanning_get_alert"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'secret-scanning/get-alert' (secret_scanning_get_alert). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def secret_scanning_get_scan_history(self, **kwargs) -> GitHubResponse:
        """Get secret scanning scan history for a repository (HTTP GET /repos/{owner}/{repo}/secret-scanning/scan-history)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "secret_scanning_get_scan_history" in method_map:
                result = method_map["secret_scanning_get_scan_history"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'secret-scanning/get-scan-history' (secret_scanning_get_scan_history). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def secret_scanning_list_alerts_for_enterprise(self, **kwargs) -> GitHubResponse:
        """List secret scanning alerts for an enterprise (HTTP GET /enterprises/{enterprise}/secret-scanning/alerts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "secret_scanning_list_alerts_for_enterprise" in method_map:
                result = method_map["secret_scanning_list_alerts_for_enterprise"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'secret-scanning/list-alerts-for-enterprise' (secret_scanning_list_alerts_for_enterprise). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def secret_scanning_list_alerts_for_org(self, **kwargs) -> GitHubResponse:
        """List secret scanning alerts for an organization (HTTP GET /orgs/{org}/secret-scanning/alerts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "secret_scanning_list_alerts_for_org" in method_map:
                result = method_map["secret_scanning_list_alerts_for_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'secret-scanning/list-alerts-for-org' (secret_scanning_list_alerts_for_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def secret_scanning_list_alerts_for_repo(self, **kwargs) -> GitHubResponse:
        """List secret scanning alerts for a repository (HTTP GET /repos/{owner}/{repo}/secret-scanning/alerts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "secret_scanning_list_alerts_for_repo" in method_map:
                result = method_map["secret_scanning_list_alerts_for_repo"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'secret-scanning/list-alerts-for-repo' (secret_scanning_list_alerts_for_repo). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def secret_scanning_list_locations_for_alert(self, **kwargs) -> GitHubResponse:
        """List locations for a secret scanning alert (HTTP GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "secret_scanning_list_locations_for_alert" in method_map:
                result = method_map["secret_scanning_list_locations_for_alert"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'secret-scanning/list-locations-for-alert' (secret_scanning_list_locations_for_alert). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def secret_scanning_list_org_pattern_configs(self, **kwargs) -> GitHubResponse:
        """List organization pattern configurations (HTTP GET /orgs/{org}/secret-scanning/pattern-configurations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "secret_scanning_list_org_pattern_configs" in method_map:
                result = method_map["secret_scanning_list_org_pattern_configs"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'secret-scanning/list-org-pattern-configs' (secret_scanning_list_org_pattern_configs). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def secret_scanning_update_alert(self, **kwargs) -> GitHubResponse:
        """Update a secret scanning alert (HTTP PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "secret_scanning_update_alert" in method_map:
                result = method_map["secret_scanning_update_alert"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'secret-scanning/update-alert' (secret_scanning_update_alert). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def secret_scanning_update_org_pattern_configs(self, **kwargs) -> GitHubResponse:
        """Update organization pattern configurations (HTTP PATCH /orgs/{org}/secret-scanning/pattern-configurations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "secret_scanning_update_org_pattern_configs" in method_map:
                result = method_map["secret_scanning_update_org_pattern_configs"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'secret-scanning/update-org-pattern-configs' (secret_scanning_update_org_pattern_configs). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def security_advisories_create_fork(self, **kwargs) -> GitHubResponse:
        """Create a temporary private fork (HTTP POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "security_advisories_create_fork" in method_map:
                result = method_map["security_advisories_create_fork"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'security-advisories/create-fork' (security_advisories_create_fork). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def security_advisories_create_private_vulnerability_report(self, **kwargs) -> GitHubResponse:
        """Privately report a security vulnerability (HTTP POST /repos/{owner}/{repo}/security-advisories/reports)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "security_advisories_create_private_vulnerability_report" in method_map:
                result = method_map["security_advisories_create_private_vulnerability_report"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'security-advisories/create-private-vulnerability-report' (security_advisories_create_private_vulnerability_report). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def security_advisories_create_repository_advisory(self, **kwargs) -> GitHubResponse:
        """Create a repository security advisory (HTTP POST /repos/{owner}/{repo}/security-advisories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "security_advisories_create_repository_advisory" in method_map:
                result = method_map["security_advisories_create_repository_advisory"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'security-advisories/create-repository-advisory' (security_advisories_create_repository_advisory). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def security_advisories_create_repository_advisory_cve_request(self, **kwargs) -> GitHubResponse:
        """Request a CVE for a repository security advisory (HTTP POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "security_advisories_create_repository_advisory_cve_request" in method_map:
                result = method_map["security_advisories_create_repository_advisory_cve_request"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'security-advisories/create-repository-advisory-cve-request' (security_advisories_create_repository_advisory_cve_request). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def security_advisories_get_global_advisory(self, **kwargs) -> GitHubResponse:
        """Get a global security advisory (HTTP GET /advisories/{ghsa_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "security_advisories_get_global_advisory" in method_map:
                result = method_map["security_advisories_get_global_advisory"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'security-advisories/get-global-advisory' (security_advisories_get_global_advisory). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def security_advisories_get_repository_advisory(self, **kwargs) -> GitHubResponse:
        """Get a repository security advisory (HTTP GET /repos/{owner}/{repo}/security-advisories/{ghsa_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "security_advisories_get_repository_advisory" in method_map:
                result = method_map["security_advisories_get_repository_advisory"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'security-advisories/get-repository-advisory' (security_advisories_get_repository_advisory). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def security_advisories_list_global_advisories(self, **kwargs) -> GitHubResponse:
        """List global security advisories (HTTP GET /advisories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "security_advisories_list_global_advisories" in method_map:
                result = method_map["security_advisories_list_global_advisories"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'security-advisories/list-global-advisories' (security_advisories_list_global_advisories). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def security_advisories_list_org_repository_advisories(self, **kwargs) -> GitHubResponse:
        """List repository security advisories for an organization (HTTP GET /orgs/{org}/security-advisories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "security_advisories_list_org_repository_advisories" in method_map:
                result = method_map["security_advisories_list_org_repository_advisories"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'security-advisories/list-org-repository-advisories' (security_advisories_list_org_repository_advisories). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def security_advisories_list_repository_advisories(self, **kwargs) -> GitHubResponse:
        """List repository security advisories (HTTP GET /repos/{owner}/{repo}/security-advisories)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "security_advisories_list_repository_advisories" in method_map:
                result = method_map["security_advisories_list_repository_advisories"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'security-advisories/list-repository-advisories' (security_advisories_list_repository_advisories). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def security_advisories_update_repository_advisory(self, **kwargs) -> GitHubResponse:
        """Update a repository security advisory (HTTP PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "security_advisories_update_repository_advisory" in method_map:
                result = method_map["security_advisories_update_repository_advisory"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'security-advisories/update-repository-advisory' (security_advisories_update_repository_advisory). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_add_member_legacy(self, **kwargs) -> GitHubResponse:
        """Add team member (Legacy) (HTTP PUT /teams/{team_id}/members/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_add_member_legacy" in method_map:
                result = method_map["teams_add_member_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/add-member-legacy' (teams_add_member_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_add_or_update_membership_for_user_in_org(self, **kwargs) -> GitHubResponse:
        """Add or update team membership for a user (HTTP PUT /orgs/{org}/teams/{team_slug}/memberships/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_add_or_update_membership_for_user_in_org" in method_map:
                result = method_map["teams_add_or_update_membership_for_user_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/add-or-update-membership-for-user-in-org' (teams_add_or_update_membership_for_user_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_add_or_update_membership_for_user_legacy(self, **kwargs) -> GitHubResponse:
        """Add or update team membership for a user (Legacy) (HTTP PUT /teams/{team_id}/memberships/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_add_or_update_membership_for_user_legacy" in method_map:
                result = method_map["teams_add_or_update_membership_for_user_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/add-or-update-membership-for-user-legacy' (teams_add_or_update_membership_for_user_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_add_or_update_project_permissions_in_org(self, **kwargs) -> GitHubResponse:
        """Add or update team project permissions (HTTP PUT /orgs/{org}/teams/{team_slug}/projects/{project_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_add_or_update_project_permissions_in_org" in method_map:
                result = method_map["teams_add_or_update_project_permissions_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/add-or-update-project-permissions-in-org' (teams_add_or_update_project_permissions_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_add_or_update_project_permissions_legacy(self, **kwargs) -> GitHubResponse:
        """Add or update team project permissions (Legacy) (HTTP PUT /teams/{team_id}/projects/{project_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_add_or_update_project_permissions_legacy" in method_map:
                result = method_map["teams_add_or_update_project_permissions_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/add-or-update-project-permissions-legacy' (teams_add_or_update_project_permissions_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_add_or_update_repo_permissions_in_org(self, **kwargs) -> GitHubResponse:
        """Add or update team repository permissions (HTTP PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_add_or_update_repo_permissions_in_org" in method_map:
                result = method_map["teams_add_or_update_repo_permissions_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/add-or-update-repo-permissions-in-org' (teams_add_or_update_repo_permissions_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_add_or_update_repo_permissions_legacy(self, **kwargs) -> GitHubResponse:
        """Add or update team repository permissions (Legacy) (HTTP PUT /teams/{team_id}/repos/{owner}/{repo})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_add_or_update_repo_permissions_legacy" in method_map:
                result = method_map["teams_add_or_update_repo_permissions_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/add-or-update-repo-permissions-legacy' (teams_add_or_update_repo_permissions_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_check_permissions_for_project_in_org(self, **kwargs) -> GitHubResponse:
        """Check team permissions for a project (HTTP GET /orgs/{org}/teams/{team_slug}/projects/{project_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_check_permissions_for_project_in_org" in method_map:
                result = method_map["teams_check_permissions_for_project_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/check-permissions-for-project-in-org' (teams_check_permissions_for_project_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_check_permissions_for_project_legacy(self, **kwargs) -> GitHubResponse:
        """Check team permissions for a project (Legacy) (HTTP GET /teams/{team_id}/projects/{project_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_check_permissions_for_project_legacy" in method_map:
                result = method_map["teams_check_permissions_for_project_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/check-permissions-for-project-legacy' (teams_check_permissions_for_project_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_check_permissions_for_repo_in_org(self, **kwargs) -> GitHubResponse:
        """Check team permissions for a repository (HTTP GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_check_permissions_for_repo_in_org" in method_map:
                result = method_map["teams_check_permissions_for_repo_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/check-permissions-for-repo-in-org' (teams_check_permissions_for_repo_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_check_permissions_for_repo_legacy(self, **kwargs) -> GitHubResponse:
        """Check team permissions for a repository (Legacy) (HTTP GET /teams/{team_id}/repos/{owner}/{repo})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_check_permissions_for_repo_legacy" in method_map:
                result = method_map["teams_check_permissions_for_repo_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/check-permissions-for-repo-legacy' (teams_check_permissions_for_repo_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_create(self, **kwargs) -> GitHubResponse:
        """Create a team (HTTP POST /orgs/{org}/teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_create" in method_map:
                result = method_map["teams_create"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/create' (teams_create). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_create_discussion_comment_in_org(self, **kwargs) -> GitHubResponse:
        """Create a discussion comment (HTTP POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_create_discussion_comment_in_org" in method_map:
                result = method_map["teams_create_discussion_comment_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/create-discussion-comment-in-org' (teams_create_discussion_comment_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_create_discussion_comment_legacy(self, **kwargs) -> GitHubResponse:
        """Create a discussion comment (Legacy) (HTTP POST /teams/{team_id}/discussions/{discussion_number}/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_create_discussion_comment_legacy" in method_map:
                result = method_map["teams_create_discussion_comment_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/create-discussion-comment-legacy' (teams_create_discussion_comment_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_create_discussion_in_org(self, **kwargs) -> GitHubResponse:
        """Create a discussion (HTTP POST /orgs/{org}/teams/{team_slug}/discussions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_create_discussion_in_org" in method_map:
                result = method_map["teams_create_discussion_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/create-discussion-in-org' (teams_create_discussion_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_create_discussion_legacy(self, **kwargs) -> GitHubResponse:
        """Create a discussion (Legacy) (HTTP POST /teams/{team_id}/discussions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_create_discussion_legacy" in method_map:
                result = method_map["teams_create_discussion_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/create-discussion-legacy' (teams_create_discussion_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_delete_discussion_comment_in_org(self, **kwargs) -> GitHubResponse:
        """Delete a discussion comment (HTTP DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_delete_discussion_comment_in_org" in method_map:
                result = method_map["teams_delete_discussion_comment_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/delete-discussion-comment-in-org' (teams_delete_discussion_comment_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_delete_discussion_comment_legacy(self, **kwargs) -> GitHubResponse:
        """Delete a discussion comment (Legacy) (HTTP DELETE /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_delete_discussion_comment_legacy" in method_map:
                result = method_map["teams_delete_discussion_comment_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/delete-discussion-comment-legacy' (teams_delete_discussion_comment_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_delete_discussion_in_org(self, **kwargs) -> GitHubResponse:
        """Delete a discussion (HTTP DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_delete_discussion_in_org" in method_map:
                result = method_map["teams_delete_discussion_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/delete-discussion-in-org' (teams_delete_discussion_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_delete_discussion_legacy(self, **kwargs) -> GitHubResponse:
        """Delete a discussion (Legacy) (HTTP DELETE /teams/{team_id}/discussions/{discussion_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_delete_discussion_legacy" in method_map:
                result = method_map["teams_delete_discussion_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/delete-discussion-legacy' (teams_delete_discussion_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_delete_in_org(self, **kwargs) -> GitHubResponse:
        """Delete a team (HTTP DELETE /orgs/{org}/teams/{team_slug})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_delete_in_org" in method_map:
                result = method_map["teams_delete_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/delete-in-org' (teams_delete_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_delete_legacy(self, **kwargs) -> GitHubResponse:
        """Delete a team (Legacy) (HTTP DELETE /teams/{team_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_delete_legacy" in method_map:
                result = method_map["teams_delete_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/delete-legacy' (teams_delete_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_get_by_name(self, **kwargs) -> GitHubResponse:
        """Get a team by name (HTTP GET /orgs/{org}/teams/{team_slug})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_get_by_name" in method_map:
                result = method_map["teams_get_by_name"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/get-by-name' (teams_get_by_name). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_get_discussion_comment_in_org(self, **kwargs) -> GitHubResponse:
        """Get a discussion comment (HTTP GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_get_discussion_comment_in_org" in method_map:
                result = method_map["teams_get_discussion_comment_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/get-discussion-comment-in-org' (teams_get_discussion_comment_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_get_discussion_comment_legacy(self, **kwargs) -> GitHubResponse:
        """Get a discussion comment (Legacy) (HTTP GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_get_discussion_comment_legacy" in method_map:
                result = method_map["teams_get_discussion_comment_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/get-discussion-comment-legacy' (teams_get_discussion_comment_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_get_discussion_in_org(self, **kwargs) -> GitHubResponse:
        """Get a discussion (HTTP GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_get_discussion_in_org" in method_map:
                result = method_map["teams_get_discussion_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/get-discussion-in-org' (teams_get_discussion_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_get_discussion_legacy(self, **kwargs) -> GitHubResponse:
        """Get a discussion (Legacy) (HTTP GET /teams/{team_id}/discussions/{discussion_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_get_discussion_legacy" in method_map:
                result = method_map["teams_get_discussion_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/get-discussion-legacy' (teams_get_discussion_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_get_legacy(self, **kwargs) -> GitHubResponse:
        """Get a team (Legacy) (HTTP GET /teams/{team_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_get_legacy" in method_map:
                result = method_map["teams_get_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/get-legacy' (teams_get_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_get_member_legacy(self, **kwargs) -> GitHubResponse:
        """Get team member (Legacy) (HTTP GET /teams/{team_id}/members/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_get_member_legacy" in method_map:
                result = method_map["teams_get_member_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/get-member-legacy' (teams_get_member_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_get_membership_for_user_in_org(self, **kwargs) -> GitHubResponse:
        """Get team membership for a user (HTTP GET /orgs/{org}/teams/{team_slug}/memberships/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_get_membership_for_user_in_org" in method_map:
                result = method_map["teams_get_membership_for_user_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/get-membership-for-user-in-org' (teams_get_membership_for_user_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_get_membership_for_user_legacy(self, **kwargs) -> GitHubResponse:
        """Get team membership for a user (Legacy) (HTTP GET /teams/{team_id}/memberships/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_get_membership_for_user_legacy" in method_map:
                result = method_map["teams_get_membership_for_user_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/get-membership-for-user-legacy' (teams_get_membership_for_user_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list(self, **kwargs) -> GitHubResponse:
        """List teams (HTTP GET /orgs/{org}/teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list" in method_map:
                result = method_map["teams_list"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list' (teams_list). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_child_in_org(self, **kwargs) -> GitHubResponse:
        """List child teams (HTTP GET /orgs/{org}/teams/{team_slug}/teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_child_in_org" in method_map:
                result = method_map["teams_list_child_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-child-in-org' (teams_list_child_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_child_legacy(self, **kwargs) -> GitHubResponse:
        """List child teams (Legacy) (HTTP GET /teams/{team_id}/teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_child_legacy" in method_map:
                result = method_map["teams_list_child_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-child-legacy' (teams_list_child_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_discussion_comments_in_org(self, **kwargs) -> GitHubResponse:
        """List discussion comments (HTTP GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_discussion_comments_in_org" in method_map:
                result = method_map["teams_list_discussion_comments_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-discussion-comments-in-org' (teams_list_discussion_comments_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_discussion_comments_legacy(self, **kwargs) -> GitHubResponse:
        """List discussion comments (Legacy) (HTTP GET /teams/{team_id}/discussions/{discussion_number}/comments)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_discussion_comments_legacy" in method_map:
                result = method_map["teams_list_discussion_comments_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-discussion-comments-legacy' (teams_list_discussion_comments_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_discussions_in_org(self, **kwargs) -> GitHubResponse:
        """List discussions (HTTP GET /orgs/{org}/teams/{team_slug}/discussions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_discussions_in_org" in method_map:
                result = method_map["teams_list_discussions_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-discussions-in-org' (teams_list_discussions_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_discussions_legacy(self, **kwargs) -> GitHubResponse:
        """List discussions (Legacy) (HTTP GET /teams/{team_id}/discussions)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_discussions_legacy" in method_map:
                result = method_map["teams_list_discussions_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-discussions-legacy' (teams_list_discussions_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List teams for the authenticated user (HTTP GET /user/teams)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_for_authenticated_user" in method_map:
                result = method_map["teams_list_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-for-authenticated-user' (teams_list_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_members_in_org(self, **kwargs) -> GitHubResponse:
        """List team members (HTTP GET /orgs/{org}/teams/{team_slug}/members)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_members_in_org" in method_map:
                result = method_map["teams_list_members_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-members-in-org' (teams_list_members_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_members_legacy(self, **kwargs) -> GitHubResponse:
        """List team members (Legacy) (HTTP GET /teams/{team_id}/members)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_members_legacy" in method_map:
                result = method_map["teams_list_members_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-members-legacy' (teams_list_members_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_pending_invitations_in_org(self, **kwargs) -> GitHubResponse:
        """List pending team invitations (HTTP GET /orgs/{org}/teams/{team_slug}/invitations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_pending_invitations_in_org" in method_map:
                result = method_map["teams_list_pending_invitations_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-pending-invitations-in-org' (teams_list_pending_invitations_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_pending_invitations_legacy(self, **kwargs) -> GitHubResponse:
        """List pending team invitations (Legacy) (HTTP GET /teams/{team_id}/invitations)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_pending_invitations_legacy" in method_map:
                result = method_map["teams_list_pending_invitations_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-pending-invitations-legacy' (teams_list_pending_invitations_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_projects_in_org(self, **kwargs) -> GitHubResponse:
        """List team projects (HTTP GET /orgs/{org}/teams/{team_slug}/projects)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_projects_in_org" in method_map:
                result = method_map["teams_list_projects_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-projects-in-org' (teams_list_projects_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_projects_legacy(self, **kwargs) -> GitHubResponse:
        """List team projects (Legacy) (HTTP GET /teams/{team_id}/projects)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_projects_legacy" in method_map:
                result = method_map["teams_list_projects_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-projects-legacy' (teams_list_projects_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_repos_in_org(self, **kwargs) -> GitHubResponse:
        """List team repositories (HTTP GET /orgs/{org}/teams/{team_slug}/repos)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_repos_in_org" in method_map:
                result = method_map["teams_list_repos_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-repos-in-org' (teams_list_repos_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_list_repos_legacy(self, **kwargs) -> GitHubResponse:
        """List team repositories (Legacy) (HTTP GET /teams/{team_id}/repos)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_list_repos_legacy" in method_map:
                result = method_map["teams_list_repos_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/list-repos-legacy' (teams_list_repos_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_remove_member_legacy(self, **kwargs) -> GitHubResponse:
        """Remove team member (Legacy) (HTTP DELETE /teams/{team_id}/members/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_remove_member_legacy" in method_map:
                result = method_map["teams_remove_member_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/remove-member-legacy' (teams_remove_member_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_remove_membership_for_user_in_org(self, **kwargs) -> GitHubResponse:
        """Remove team membership for a user (HTTP DELETE /orgs/{org}/teams/{team_slug}/memberships/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_remove_membership_for_user_in_org" in method_map:
                result = method_map["teams_remove_membership_for_user_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/remove-membership-for-user-in-org' (teams_remove_membership_for_user_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_remove_membership_for_user_legacy(self, **kwargs) -> GitHubResponse:
        """Remove team membership for a user (Legacy) (HTTP DELETE /teams/{team_id}/memberships/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_remove_membership_for_user_legacy" in method_map:
                result = method_map["teams_remove_membership_for_user_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/remove-membership-for-user-legacy' (teams_remove_membership_for_user_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_remove_project_in_org(self, **kwargs) -> GitHubResponse:
        """Remove a project from a team (HTTP DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_remove_project_in_org" in method_map:
                result = method_map["teams_remove_project_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/remove-project-in-org' (teams_remove_project_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_remove_project_legacy(self, **kwargs) -> GitHubResponse:
        """Remove a project from a team (Legacy) (HTTP DELETE /teams/{team_id}/projects/{project_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_remove_project_legacy" in method_map:
                result = method_map["teams_remove_project_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/remove-project-legacy' (teams_remove_project_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_remove_repo_in_org(self, **kwargs) -> GitHubResponse:
        """Remove a repository from a team (HTTP DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_remove_repo_in_org" in method_map:
                result = method_map["teams_remove_repo_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/remove-repo-in-org' (teams_remove_repo_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_remove_repo_legacy(self, **kwargs) -> GitHubResponse:
        """Remove a repository from a team (Legacy) (HTTP DELETE /teams/{team_id}/repos/{owner}/{repo})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_remove_repo_legacy" in method_map:
                result = method_map["teams_remove_repo_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/remove-repo-legacy' (teams_remove_repo_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_update_discussion_comment_in_org(self, **kwargs) -> GitHubResponse:
        """Update a discussion comment (HTTP PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_update_discussion_comment_in_org" in method_map:
                result = method_map["teams_update_discussion_comment_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/update-discussion-comment-in-org' (teams_update_discussion_comment_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_update_discussion_comment_legacy(self, **kwargs) -> GitHubResponse:
        """Update a discussion comment (Legacy) (HTTP PATCH /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_update_discussion_comment_legacy" in method_map:
                result = method_map["teams_update_discussion_comment_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/update-discussion-comment-legacy' (teams_update_discussion_comment_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_update_discussion_in_org(self, **kwargs) -> GitHubResponse:
        """Update a discussion (HTTP PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_update_discussion_in_org" in method_map:
                result = method_map["teams_update_discussion_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/update-discussion-in-org' (teams_update_discussion_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_update_discussion_legacy(self, **kwargs) -> GitHubResponse:
        """Update a discussion (Legacy) (HTTP PATCH /teams/{team_id}/discussions/{discussion_number})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_update_discussion_legacy" in method_map:
                result = method_map["teams_update_discussion_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/update-discussion-legacy' (teams_update_discussion_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_update_in_org(self, **kwargs) -> GitHubResponse:
        """Update a team (HTTP PATCH /orgs/{org}/teams/{team_slug})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_update_in_org" in method_map:
                result = method_map["teams_update_in_org"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/update-in-org' (teams_update_in_org). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def teams_update_legacy(self, **kwargs) -> GitHubResponse:
        """Update a team (Legacy) (HTTP PATCH /teams/{team_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "teams_update_legacy" in method_map:
                result = method_map["teams_update_legacy"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'teams/update-legacy' (teams_update_legacy). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_add_email_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Add an email address for the authenticated user (HTTP POST /user/emails)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_add_email_for_authenticated_user" in method_map:
                result = method_map["users_add_email_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/add-email-for-authenticated-user' (users_add_email_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_add_social_account_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Add social accounts for the authenticated user (HTTP POST /user/social_accounts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_add_social_account_for_authenticated_user" in method_map:
                result = method_map["users_add_social_account_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/add-social-account-for-authenticated-user' (users_add_social_account_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_block(self, **kwargs) -> GitHubResponse:
        """Block a user (HTTP PUT /user/blocks/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_block" in method_map:
                result = method_map["users_block"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/block' (users_block). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_check_blocked(self, **kwargs) -> GitHubResponse:
        """Check if a user is blocked by the authenticated user (HTTP GET /user/blocks/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_check_blocked" in method_map:
                result = method_map["users_check_blocked"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/check-blocked' (users_check_blocked). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_check_following_for_user(self, **kwargs) -> GitHubResponse:
        """Check if a user follows another user (HTTP GET /users/{username}/following/{target_user})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_check_following_for_user" in method_map:
                result = method_map["users_check_following_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/check-following-for-user' (users_check_following_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_check_person_is_followed_by_authenticated(self, **kwargs) -> GitHubResponse:
        """Check if a person is followed by the authenticated user (HTTP GET /user/following/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_check_person_is_followed_by_authenticated" in method_map:
                result = method_map["users_check_person_is_followed_by_authenticated"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/check-person-is-followed-by-authenticated' (users_check_person_is_followed_by_authenticated). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_create_gpg_key_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Create a GPG key for the authenticated user (HTTP POST /user/gpg_keys)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_create_gpg_key_for_authenticated_user" in method_map:
                result = method_map["users_create_gpg_key_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/create-gpg-key-for-authenticated-user' (users_create_gpg_key_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_create_public_ssh_key_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Create a public SSH key for the authenticated user (HTTP POST /user/keys)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_create_public_ssh_key_for_authenticated_user" in method_map:
                result = method_map["users_create_public_ssh_key_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/create-public-ssh-key-for-authenticated-user' (users_create_public_ssh_key_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_create_ssh_signing_key_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Create a SSH signing key for the authenticated user (HTTP POST /user/ssh_signing_keys)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_create_ssh_signing_key_for_authenticated_user" in method_map:
                result = method_map["users_create_ssh_signing_key_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/create-ssh-signing-key-for-authenticated-user' (users_create_ssh_signing_key_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_delete_attestations_bulk(self, **kwargs) -> GitHubResponse:
        """Delete attestations in bulk (HTTP POST /users/{username}/attestations/delete-request)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_delete_attestations_bulk" in method_map:
                result = method_map["users_delete_attestations_bulk"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/delete-attestations-bulk' (users_delete_attestations_bulk). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_delete_attestations_by_id(self, **kwargs) -> GitHubResponse:
        """Delete attestations by ID (HTTP DELETE /users/{username}/attestations/{attestation_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_delete_attestations_by_id" in method_map:
                result = method_map["users_delete_attestations_by_id"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/delete-attestations-by-id' (users_delete_attestations_by_id). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_delete_attestations_by_subject_digest(self, **kwargs) -> GitHubResponse:
        """Delete attestations by subject digest (HTTP DELETE /users/{username}/attestations/digest/{subject_digest})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_delete_attestations_by_subject_digest" in method_map:
                result = method_map["users_delete_attestations_by_subject_digest"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/delete-attestations-by-subject-digest' (users_delete_attestations_by_subject_digest). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_delete_email_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Delete an email address for the authenticated user (HTTP DELETE /user/emails)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_delete_email_for_authenticated_user" in method_map:
                result = method_map["users_delete_email_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/delete-email-for-authenticated-user' (users_delete_email_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_delete_gpg_key_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Delete a GPG key for the authenticated user (HTTP DELETE /user/gpg_keys/{gpg_key_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_delete_gpg_key_for_authenticated_user" in method_map:
                result = method_map["users_delete_gpg_key_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/delete-gpg-key-for-authenticated-user' (users_delete_gpg_key_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_delete_public_ssh_key_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Delete a public SSH key for the authenticated user (HTTP DELETE /user/keys/{key_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_delete_public_ssh_key_for_authenticated_user" in method_map:
                result = method_map["users_delete_public_ssh_key_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/delete-public-ssh-key-for-authenticated-user' (users_delete_public_ssh_key_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_delete_social_account_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Delete social accounts for the authenticated user (HTTP DELETE /user/social_accounts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_delete_social_account_for_authenticated_user" in method_map:
                result = method_map["users_delete_social_account_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/delete-social-account-for-authenticated-user' (users_delete_social_account_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_delete_ssh_signing_key_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Delete an SSH signing key for the authenticated user (HTTP DELETE /user/ssh_signing_keys/{ssh_signing_key_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_delete_ssh_signing_key_for_authenticated_user" in method_map:
                result = method_map["users_delete_ssh_signing_key_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/delete-ssh-signing-key-for-authenticated-user' (users_delete_ssh_signing_key_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_follow(self, **kwargs) -> GitHubResponse:
        """Follow a user (HTTP PUT /user/following/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_follow" in method_map:
                result = method_map["users_follow"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/follow' (users_follow). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_get_authenticated(self, **kwargs) -> GitHubResponse:
        """Get the authenticated user (HTTP GET /user)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_get_authenticated" in method_map:
                result = method_map["users_get_authenticated"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/get-authenticated' (users_get_authenticated). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_get_by_id(self, **kwargs) -> GitHubResponse:
        """Get a user using their ID (HTTP GET /user/{account_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_get_by_id" in method_map:
                result = method_map["users_get_by_id"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/get-by-id' (users_get_by_id). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_get_by_username(self, **kwargs) -> GitHubResponse:
        """Get a user (HTTP GET /users/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_get_by_username" in method_map:
                result = method_map["users_get_by_username"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/get-by-username' (users_get_by_username). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_get_context_for_user(self, **kwargs) -> GitHubResponse:
        """Get contextual information for a user (HTTP GET /users/{username}/hovercard)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_get_context_for_user" in method_map:
                result = method_map["users_get_context_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/get-context-for-user' (users_get_context_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_get_gpg_key_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get a GPG key for the authenticated user (HTTP GET /user/gpg_keys/{gpg_key_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_get_gpg_key_for_authenticated_user" in method_map:
                result = method_map["users_get_gpg_key_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/get-gpg-key-for-authenticated-user' (users_get_gpg_key_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_get_public_ssh_key_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get a public SSH key for the authenticated user (HTTP GET /user/keys/{key_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_get_public_ssh_key_for_authenticated_user" in method_map:
                result = method_map["users_get_public_ssh_key_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/get-public-ssh-key-for-authenticated-user' (users_get_public_ssh_key_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_get_ssh_signing_key_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Get an SSH signing key for the authenticated user (HTTP GET /user/ssh_signing_keys/{ssh_signing_key_id})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_get_ssh_signing_key_for_authenticated_user" in method_map:
                result = method_map["users_get_ssh_signing_key_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/get-ssh-signing-key-for-authenticated-user' (users_get_ssh_signing_key_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list(self, **kwargs) -> GitHubResponse:
        """List users (HTTP GET /users)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list" in method_map:
                result = method_map["users_list"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list' (users_list). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_attestations(self, **kwargs) -> GitHubResponse:
        """List attestations (HTTP GET /users/{username}/attestations/{subject_digest})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_attestations" in method_map:
                result = method_map["users_list_attestations"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-attestations' (users_list_attestations). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_attestations_bulk(self, **kwargs) -> GitHubResponse:
        """List attestations by bulk subject digests (HTTP POST /users/{username}/attestations/bulk-list)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_attestations_bulk" in method_map:
                result = method_map["users_list_attestations_bulk"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-attestations-bulk' (users_list_attestations_bulk). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_blocked_by_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List users blocked by the authenticated user (HTTP GET /user/blocks)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_blocked_by_authenticated_user" in method_map:
                result = method_map["users_list_blocked_by_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-blocked-by-authenticated-user' (users_list_blocked_by_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_emails_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List email addresses for the authenticated user (HTTP GET /user/emails)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_emails_for_authenticated_user" in method_map:
                result = method_map["users_list_emails_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-emails-for-authenticated-user' (users_list_emails_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_followed_by_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List the people the authenticated user follows (HTTP GET /user/following)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_followed_by_authenticated_user" in method_map:
                result = method_map["users_list_followed_by_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-followed-by-authenticated-user' (users_list_followed_by_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_followers_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List followers of the authenticated user (HTTP GET /user/followers)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_followers_for_authenticated_user" in method_map:
                result = method_map["users_list_followers_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-followers-for-authenticated-user' (users_list_followers_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_followers_for_user(self, **kwargs) -> GitHubResponse:
        """List followers of a user (HTTP GET /users/{username}/followers)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_followers_for_user" in method_map:
                result = method_map["users_list_followers_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-followers-for-user' (users_list_followers_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_following_for_user(self, **kwargs) -> GitHubResponse:
        """List the people a user follows (HTTP GET /users/{username}/following)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_following_for_user" in method_map:
                result = method_map["users_list_following_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-following-for-user' (users_list_following_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_gpg_keys_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List GPG keys for the authenticated user (HTTP GET /user/gpg_keys)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_gpg_keys_for_authenticated_user" in method_map:
                result = method_map["users_list_gpg_keys_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-gpg-keys-for-authenticated-user' (users_list_gpg_keys_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_gpg_keys_for_user(self, **kwargs) -> GitHubResponse:
        """List GPG keys for a user (HTTP GET /users/{username}/gpg_keys)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_gpg_keys_for_user" in method_map:
                result = method_map["users_list_gpg_keys_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-gpg-keys-for-user' (users_list_gpg_keys_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_public_emails_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List public email addresses for the authenticated user (HTTP GET /user/public_emails)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_public_emails_for_authenticated_user" in method_map:
                result = method_map["users_list_public_emails_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-public-emails-for-authenticated-user' (users_list_public_emails_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_public_keys_for_user(self, **kwargs) -> GitHubResponse:
        """List public keys for a user (HTTP GET /users/{username}/keys)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_public_keys_for_user" in method_map:
                result = method_map["users_list_public_keys_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-public-keys-for-user' (users_list_public_keys_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_public_ssh_keys_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List public SSH keys for the authenticated user (HTTP GET /user/keys)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_public_ssh_keys_for_authenticated_user" in method_map:
                result = method_map["users_list_public_ssh_keys_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-public-ssh-keys-for-authenticated-user' (users_list_public_ssh_keys_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_social_accounts_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List social accounts for the authenticated user (HTTP GET /user/social_accounts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_social_accounts_for_authenticated_user" in method_map:
                result = method_map["users_list_social_accounts_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-social-accounts-for-authenticated-user' (users_list_social_accounts_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_social_accounts_for_user(self, **kwargs) -> GitHubResponse:
        """List social accounts for a user (HTTP GET /users/{username}/social_accounts)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_social_accounts_for_user" in method_map:
                result = method_map["users_list_social_accounts_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-social-accounts-for-user' (users_list_social_accounts_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_ssh_signing_keys_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """List SSH signing keys for the authenticated user (HTTP GET /user/ssh_signing_keys)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_ssh_signing_keys_for_authenticated_user" in method_map:
                result = method_map["users_list_ssh_signing_keys_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-ssh-signing-keys-for-authenticated-user' (users_list_ssh_signing_keys_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_list_ssh_signing_keys_for_user(self, **kwargs) -> GitHubResponse:
        """List SSH signing keys for a user (HTTP GET /users/{username}/ssh_signing_keys)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_list_ssh_signing_keys_for_user" in method_map:
                result = method_map["users_list_ssh_signing_keys_for_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/list-ssh-signing-keys-for-user' (users_list_ssh_signing_keys_for_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_set_primary_email_visibility_for_authenticated_user(self, **kwargs) -> GitHubResponse:
        """Set primary email visibility for the authenticated user (HTTP PATCH /user/email/visibility)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_set_primary_email_visibility_for_authenticated_user" in method_map:
                result = method_map["users_set_primary_email_visibility_for_authenticated_user"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/set-primary-email-visibility-for-authenticated-user' (users_set_primary_email_visibility_for_authenticated_user). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_unblock(self, **kwargs) -> GitHubResponse:
        """Unblock a user (HTTP DELETE /user/blocks/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_unblock" in method_map:
                result = method_map["users_unblock"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/unblock' (users_unblock). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_unfollow(self, **kwargs) -> GitHubResponse:
        """Unfollow a user (HTTP DELETE /user/following/{username})"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_unfollow" in method_map:
                result = method_map["users_unfollow"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/unfollow' (users_unfollow). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

    async def users_update_authenticated(self, **kwargs) -> GitHubResponse:
        """Update the authenticated user (HTTP PATCH /user)"""
        try:
            # Get the actual PyGithub instance
            github_sdk = self.client.get_sdk()
            # Map GitHub API operation IDs to PyGithub method names
            method_map = {
                "users_get_authenticated": lambda sdk, **kw: sdk.get_user(),
                "users_get_by_username": lambda sdk, **kw: sdk.get_user(kw.get("username")),
                "repos_get": lambda sdk, **kw: sdk.get_repo(f"{kw.get('owner')}/{kw.get('repo')}"),
                "repos_list_for_authenticated_user": lambda sdk, **kw: sdk.get_user().get_repos(),
                "orgs_get": lambda sdk, **kw: sdk.get_organization(kw.get("org")),
                # Add more mappings as needed
            }
            if "users_update_authenticated" in method_map:
                result = method_map["users_update_authenticated"](github_sdk, **kwargs)
                # Convert PyGithub objects to dict for serialization
                if hasattr(result, "_rawData"):
                    # Force PyGithub to load the data by accessing a property
                    if hasattr(result, "login"):
                        _ = result.login  # This triggers data loading for User objects
                    elif hasattr(result, "name"):
                        _ = result.name   # This triggers data loading for other objects
                    data = result._rawData
                elif hasattr(result, "__iter__") and not isinstance(result, (str, dict)):
                    # Handle paginated results (PaginatedList)
                    try:
                        # Convert to list and extract raw data
                        items = list(result)
                        data = []
                        for item in items:
                            if hasattr(item, "_rawData"):
                                if hasattr(item, "name"):
                                    _ = item.name  # Trigger data loading
                                data.append(item._rawData)
                            else:
                                data.append(str(item))
                    except Exception as list_error:
                        data = f"Error processing paginated result: {list_error}"
                else:
                    data = str(result)
                return GitHubResponse(success=True, data=data)
            # Fallback: try to find method on SDK
            available = [attr for attr in dir(github_sdk) if not attr.startswith("_") and callable(getattr(github_sdk, attr))]
            return GitHubResponse(success=False, error=f"No mapping for 'users/update-authenticated' (users_update_authenticated). Available SDK methods: {', '.join(available[:10])}...")
        except Exception as e:
            return GitHubResponse(success=False, error=str(e))

__all__ = ["GitHubDataSource", "GitHubResponse"]
