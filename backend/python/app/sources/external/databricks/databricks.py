# ruff: noqa
"""
Databricks DataSource — Auto-generated SDK wrapper

Generated by introspecting databricks-sdk v0.85.0 WorkspaceClient.
Covers 121 services and 814 methods.

All methods return DatabricksResponse for consistent handling.
SDK dataclass objects are automatically serialized to dicts.
Iterator results are materialized to lists.

DO NOT EDIT — regenerate with:
    python code-generator/databricks.py
"""

import logging
from typing import Any, Dict, Iterator, List, Optional, Union

from app.sources.client.databricks.databricks import DatabricksClient, DatabricksResponse

logger = logging.getLogger(__name__)


def _serialize(obj: Any) -> Any:
    """Serialize SDK objects to JSON-compatible Python types."""
    if obj is None:
        return None
    if isinstance(obj, (str, int, float, bool)):
        return obj
    if isinstance(obj, (list, tuple)):
        return [_serialize(item) for item in obj]
    if isinstance(obj, dict):
        return {str(k): _serialize(v) for k, v in obj.items()}
    if hasattr(obj, "as_dict"):
        return obj.as_dict()
    if hasattr(obj, "__dict__"):
        return {k: _serialize(v) for k, v in obj.__dict__.items() if not k.startswith("_")}
    return str(obj)


class DatabricksDataSource:
    """Databricks SDK DataSource — auto-generated wrapper.

    Wraps the official databricks-sdk WorkspaceClient, providing typed async
    methods for all 121 workspace API services (814 methods).

    Each method:
    - Accepts explicit, typed parameters (no **kwargs)
    - Delegates to the corresponding SDK service method
    - Returns DatabricksResponse with serialized data or error info
    - Automatically serializes SDK dataclass objects to dicts
    - Materializes iterators to lists

    Usage::

        client = DatabricksClient.build_from_services(logger, config_service)
        ds = DatabricksDataSource(client)
        resp = await ds.clusters_list()
        if resp.success:
            for cluster in resp.data:
                print(cluster["cluster_name"])
    """

    def __init__(self, client: DatabricksClient) -> None:
        """Initialize with DatabricksClient.

        Args:
            client: DatabricksClient instance (IClient) with configured authentication
        """
        self._client = client
        sdk_client = client.get_client()
        self._ws = sdk_client.get_workspace_client()

    def get_data_source(self) -> "DatabricksDataSource":
        """Return the data source instance."""
        return self

    def get_client(self) -> DatabricksClient:
        """Return the underlying DatabricksClient."""
        return self._client

    # ============================================================================
    # ACCESS CONTROL (AccessControlAPI) — 1 methods
    # ============================================================================

    async def access_control_check_policy(
        self,
        actor: Dict[str, Any],
        permission: str,
        resource: str,
        consistency_token: Dict[str, Any],
        authz_identity: Dict[str, Any],
        resource_info: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Check access policy to a resource."""
        kwargs: Dict[str, Any] = {}
        kwargs['actor'] = actor
        kwargs['permission'] = permission
        kwargs['resource'] = resource
        kwargs['consistency_token'] = consistency_token
        kwargs['authz_identity'] = authz_identity
        if resource_info is not None:
            kwargs['resource_info'] = resource_info
        try:
            result = self._ws.access_control.check_policy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # ACCOUNT ACCESS CONTROL PROXY (AccountAccessControlProxyAPI) — 3 methods
    # ============================================================================

    async def account_access_control_proxy_get_assignable_roles_for_resource(self, resource: str) -> DatabricksResponse:
        """Gets all the roles that can be granted on an account level resource. A role is grantable if the rule set on the resource can contain an access rule of the role."""
        kwargs: Dict[str, Any] = {}
        kwargs['resource'] = resource
        try:
            result = self._ws.account_access_control_proxy.get_assignable_roles_for_resource(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def account_access_control_proxy_get_rule_set(self, name: str, etag: str) -> DatabricksResponse:
        """Get a rule set by its name. A rule set is always attached to a resource and contains a list of access rules on the said resource. Currently only a default rule set for each resource is supported."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['etag'] = etag
        try:
            result = self._ws.account_access_control_proxy.get_rule_set(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def account_access_control_proxy_update_rule_set(self, name: str, rule_set: Dict[str, Any]) -> DatabricksResponse:
        """Replace the rules of a rule set. First, use get to read the current version of the rule set before modifying it. This pattern helps prevent conflicts between concurrent updates."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['rule_set'] = rule_set
        try:
            result = self._ws.account_access_control_proxy.update_rule_set(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # AGENT BRICKS (AgentBricksAPI) — 6 methods
    # ============================================================================

    async def agent_bricks_cancel_optimize(self, id: str) -> DatabricksResponse:
        """Cancel a Custom LLM Optimization Run."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.agent_bricks.cancel_optimize(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def agent_bricks_create_custom_llm(
        self,
        name: str,
        instructions: str,
        agent_artifact_path: Optional[str] = None,
        datasets: Optional[List[Dict[str, Any]]] = None,
        guidelines: Optional[List[str]] = None,
    ) -> DatabricksResponse:
        """Create a Custom LLM."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['instructions'] = instructions
        if agent_artifact_path is not None:
            kwargs['agent_artifact_path'] = agent_artifact_path
        if datasets is not None:
            kwargs['datasets'] = datasets
        if guidelines is not None:
            kwargs['guidelines'] = guidelines
        try:
            result = self._ws.agent_bricks.create_custom_llm(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def agent_bricks_delete_custom_llm(self, id: str) -> DatabricksResponse:
        """Delete a Custom LLM."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.agent_bricks.delete_custom_llm(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def agent_bricks_get_custom_llm(self, id: str) -> DatabricksResponse:
        """Get a Custom LLM."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.agent_bricks.get_custom_llm(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def agent_bricks_start_optimize(self, id: str) -> DatabricksResponse:
        """Start a Custom LLM Optimization Run."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.agent_bricks.start_optimize(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def agent_bricks_update_custom_llm(
        self,
        id: str,
        custom_llm: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Update a Custom LLM."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        kwargs['custom_llm'] = custom_llm
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.agent_bricks.update_custom_llm(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # ALERTS (AlertsAPI) — 5 methods
    # ============================================================================

    async def alerts_create(
        self,
        alert: Optional[Dict[str, Any]] = None,
        auto_resolve_display_name: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Creates an alert."""
        kwargs: Dict[str, Any] = {}
        if alert is not None:
            kwargs['alert'] = alert
        if auto_resolve_display_name is not None:
            kwargs['auto_resolve_display_name'] = auto_resolve_display_name
        try:
            result = self._ws.alerts.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def alerts_delete(self, id: str) -> DatabricksResponse:
        """Moves an alert to the trash. Trashed alerts immediately disappear from searches and list views, and can no longer trigger. You can restore a trashed alert through the UI. A trashed alert is permane..."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.alerts.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def alerts_get(self, id: str) -> DatabricksResponse:
        """Gets an alert."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.alerts.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def alerts_list(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Gets a list of alerts accessible to the user, ordered by creation time. **Warning:** Calling this API concurrently 10 or more times could result in throttling, service degradation, or a temporary ban."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.alerts.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def alerts_update(
        self,
        id: str,
        update_mask: str,
        alert: Optional[Dict[str, Any]] = None,
        auto_resolve_display_name: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Updates an alert."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        kwargs['update_mask'] = update_mask
        if alert is not None:
            kwargs['alert'] = alert
        if auto_resolve_display_name is not None:
            kwargs['auto_resolve_display_name'] = auto_resolve_display_name
        try:
            result = self._ws.alerts.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # ALERTS V2 (AlertsV2API) — 5 methods
    # ============================================================================

    async def alerts_v2_create_alert(self, alert: Dict[str, Any]) -> DatabricksResponse:
        """Create Alert"""
        kwargs: Dict[str, Any] = {}
        kwargs['alert'] = alert
        try:
            result = self._ws.alerts_v2.create_alert(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def alerts_v2_get_alert(self, id: str) -> DatabricksResponse:
        """Gets an alert."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.alerts_v2.get_alert(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def alerts_v2_list_alerts(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Gets a list of alerts accessible to the user, ordered by creation time."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.alerts_v2.list_alerts(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def alerts_v2_trash_alert(self, id: str, purge: Optional[bool] = None) -> DatabricksResponse:
        """Moves an alert to the trash. Trashed alerts immediately disappear from list views, and can no longer trigger. You can restore a trashed alert through the UI. A trashed alert is permanently deleted ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if purge is not None:
            kwargs['purge'] = purge
        try:
            result = self._ws.alerts_v2.trash_alert(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def alerts_v2_update_alert(
        self,
        id: str,
        alert: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Update alert"""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        kwargs['alert'] = alert
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.alerts_v2.update_alert(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # APPS (AppsAPI) — 16 methods
    # ============================================================================

    async def apps_create(self, app: Dict[str, Any], no_compute: Optional[bool] = None) -> DatabricksResponse:
        """Creates a new app."""
        kwargs: Dict[str, Any] = {}
        kwargs['app'] = app
        if no_compute is not None:
            kwargs['no_compute'] = no_compute
        try:
            result = self._ws.apps.create(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_create_update(
        self,
        app_name: str,
        update_mask: str,
        app: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Creates an app update and starts the update process. The update process is asynchronous and the status of the update can be checked with the GetAppUpdate method."""
        kwargs: Dict[str, Any] = {}
        kwargs['app_name'] = app_name
        kwargs['update_mask'] = update_mask
        if app is not None:
            kwargs['app'] = app
        try:
            result = self._ws.apps.create_update(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_delete(self, name: str) -> DatabricksResponse:
        """Deletes an app."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.apps.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_deploy(self, app_name: str, app_deployment: Dict[str, Any]) -> DatabricksResponse:
        """Creates an app deployment for the app with the supplied name."""
        kwargs: Dict[str, Any] = {}
        kwargs['app_name'] = app_name
        kwargs['app_deployment'] = app_deployment
        try:
            result = self._ws.apps.deploy(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_get(self, name: str) -> DatabricksResponse:
        """Retrieves information for the app with the supplied name."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.apps.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_get_deployment(self, app_name: str, deployment_id: str) -> DatabricksResponse:
        """Retrieves information for the app deployment with the supplied name and deployment id."""
        kwargs: Dict[str, Any] = {}
        kwargs['app_name'] = app_name
        kwargs['deployment_id'] = deployment_id
        try:
            result = self._ws.apps.get_deployment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_get_permission_levels(self, app_name: str) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        kwargs['app_name'] = app_name
        try:
            result = self._ws.apps.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_get_permissions(self, app_name: str) -> DatabricksResponse:
        """Gets the permissions of an app. Apps can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['app_name'] = app_name
        try:
            result = self._ws.apps.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_get_update(self, app_name: str) -> DatabricksResponse:
        """Gets the status of an app update."""
        kwargs: Dict[str, Any] = {}
        kwargs['app_name'] = app_name
        try:
            result = self._ws.apps.get_update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_list(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Lists all apps in the workspace."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.apps.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_list_deployments(
        self,
        app_name: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Lists all app deployments for the app with the supplied name."""
        kwargs: Dict[str, Any] = {}
        kwargs['app_name'] = app_name
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.apps.list_deployments(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_set_permissions(
        self,
        app_name: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['app_name'] = app_name
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.apps.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_start(self, name: str) -> DatabricksResponse:
        """Start the last active deployment of the app in the workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.apps.start(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_stop(self, name: str) -> DatabricksResponse:
        """Stops the active deployment of the app in the workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.apps.stop(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_update(self, name: str, app: Dict[str, Any]) -> DatabricksResponse:
        """Updates the app with the supplied name."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['app'] = app
        try:
            result = self._ws.apps.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_update_permissions(
        self,
        app_name: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on an app. Apps can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['app_name'] = app_name
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.apps.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # APPS SETTINGS (AppsSettingsAPI) — 5 methods
    # ============================================================================

    async def apps_settings_create_custom_template(self, template: Dict[str, Any]) -> DatabricksResponse:
        """Creates a custom template."""
        kwargs: Dict[str, Any] = {}
        kwargs['template'] = template
        try:
            result = self._ws.apps_settings.create_custom_template(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_settings_delete_custom_template(self, name: str) -> DatabricksResponse:
        """Deletes the custom template with the specified name."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.apps_settings.delete_custom_template(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_settings_get_custom_template(self, name: str) -> DatabricksResponse:
        """Gets the custom template with the specified name."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.apps_settings.get_custom_template(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_settings_list_custom_templates(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Lists all custom templates in the workspace."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.apps_settings.list_custom_templates(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def apps_settings_update_custom_template(self, name: str, template: Dict[str, Any]) -> DatabricksResponse:
        """Updates the custom template with the specified name. Note that the template name cannot be updated."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['template'] = template
        try:
            result = self._ws.apps_settings.update_custom_template(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # ARTIFACT ALLOWLISTS (ArtifactAllowlistsAPI) — 2 methods
    # ============================================================================

    async def artifact_allowlists_get(self, artifact_type: Dict[str, Any]) -> DatabricksResponse:
        """Get the artifact allowlist of a certain artifact type. The caller must be a metastore admin or have the **MANAGE ALLOWLIST** privilege on the metastore."""
        kwargs: Dict[str, Any] = {}
        kwargs['artifact_type'] = artifact_type
        try:
            result = self._ws.artifact_allowlists.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def artifact_allowlists_update(
        self,
        artifact_type: Dict[str, Any],
        artifact_matchers: List[Dict[str, Any]],
        created_at: Optional[int] = None,
        created_by: Optional[str] = None,
        metastore_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Set the artifact allowlist of a certain artifact type. The whole artifact allowlist is replaced with the new allowlist. The caller must be a metastore admin or have the **MANAGE ALLOWLIST** privile..."""
        kwargs: Dict[str, Any] = {}
        kwargs['artifact_type'] = artifact_type
        kwargs['artifact_matchers'] = artifact_matchers
        if created_at is not None:
            kwargs['created_at'] = created_at
        if created_by is not None:
            kwargs['created_by'] = created_by
        if metastore_id is not None:
            kwargs['metastore_id'] = metastore_id
        try:
            result = self._ws.artifact_allowlists.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CATALOGS (CatalogsAPI) — 5 methods
    # ============================================================================

    async def catalogs_create(
        self,
        name: str,
        comment: Optional[str] = None,
        connection_name: Optional[str] = None,
        options: Optional[Dict[str, str]] = None,
        properties: Optional[Dict[str, str]] = None,
        provider_name: Optional[str] = None,
        share_name: Optional[str] = None,
        storage_root: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new catalog instance in the parent metastore if the caller is a metastore admin or has the **CREATE_CATALOG** privilege."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if comment is not None:
            kwargs['comment'] = comment
        if connection_name is not None:
            kwargs['connection_name'] = connection_name
        if options is not None:
            kwargs['options'] = options
        if properties is not None:
            kwargs['properties'] = properties
        if provider_name is not None:
            kwargs['provider_name'] = provider_name
        if share_name is not None:
            kwargs['share_name'] = share_name
        if storage_root is not None:
            kwargs['storage_root'] = storage_root
        try:
            result = self._ws.catalogs.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def catalogs_delete(self, name: str, force: Optional[bool] = None) -> DatabricksResponse:
        """Deletes the catalog that matches the supplied name. The caller must be a metastore admin or the owner of the catalog."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if force is not None:
            kwargs['force'] = force
        try:
            result = self._ws.catalogs.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def catalogs_get(self, name: str, include_browse: Optional[bool] = None) -> DatabricksResponse:
        """Gets the specified catalog in a metastore. The caller must be a metastore admin, the owner of the catalog, or a user that has the **USE_CATALOG** privilege set for their account."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        try:
            result = self._ws.catalogs.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def catalogs_list(
        self,
        include_browse: Optional[bool] = None,
        include_unbound: Optional[bool] = None,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets an array of catalogs in the metastore. If the caller is the metastore admin, all catalogs will be retrieved. Otherwise, only catalogs owned by the caller (or for which the caller has the **USE..."""
        kwargs: Dict[str, Any] = {}
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        if include_unbound is not None:
            kwargs['include_unbound'] = include_unbound
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.catalogs.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def catalogs_update(
        self,
        name: str,
        comment: Optional[str] = None,
        enable_predictive_optimization: Optional[Dict[str, Any]] = None,
        isolation_mode: Optional[Dict[str, Any]] = None,
        new_name: Optional[str] = None,
        options: Optional[Dict[str, str]] = None,
        owner: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> DatabricksResponse:
        """Updates the catalog that matches the supplied name. The caller must be either the owner of the catalog, or a metastore admin (when changing the owner field of the catalog)."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if comment is not None:
            kwargs['comment'] = comment
        if enable_predictive_optimization is not None:
            kwargs['enable_predictive_optimization'] = enable_predictive_optimization
        if isolation_mode is not None:
            kwargs['isolation_mode'] = isolation_mode
        if new_name is not None:
            kwargs['new_name'] = new_name
        if options is not None:
            kwargs['options'] = options
        if owner is not None:
            kwargs['owner'] = owner
        if properties is not None:
            kwargs['properties'] = properties
        try:
            result = self._ws.catalogs.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CLEAN ROOM ASSET REVISIONS (CleanRoomAssetRevisionsAPI) — 2 methods
    # ============================================================================

    async def clean_room_asset_revisions_get(
        self,
        clean_room_name: str,
        asset_type: Dict[str, Any],
        name: str,
        etag: str,
    ) -> DatabricksResponse:
        """Get a specific revision of an asset"""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        kwargs['asset_type'] = asset_type
        kwargs['name'] = name
        kwargs['etag'] = etag
        try:
            result = self._ws.clean_room_asset_revisions.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_room_asset_revisions_list(
        self,
        clean_room_name: str,
        asset_type: Dict[str, Any],
        name: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List revisions for an asset"""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        kwargs['asset_type'] = asset_type
        kwargs['name'] = name
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.clean_room_asset_revisions.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CLEAN ROOM ASSETS (CleanRoomAssetsAPI) — 6 methods
    # ============================================================================

    async def clean_room_assets_create(self, clean_room_name: str, asset: Dict[str, Any]) -> DatabricksResponse:
        """Create a clean room asset —share an asset like a notebook or table into the clean room. For each UC asset that is added through this method, the clean room owner must also have enough privilege on ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        kwargs['asset'] = asset
        try:
            result = self._ws.clean_room_assets.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_room_assets_create_clean_room_asset_review(
        self,
        clean_room_name: str,
        asset_type: Dict[str, Any],
        name: str,
        notebook_review: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Submit an asset review"""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        kwargs['asset_type'] = asset_type
        kwargs['name'] = name
        if notebook_review is not None:
            kwargs['notebook_review'] = notebook_review
        try:
            result = self._ws.clean_room_assets.create_clean_room_asset_review(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_room_assets_delete(
        self,
        clean_room_name: str,
        asset_type: Dict[str, Any],
        name: str,
    ) -> DatabricksResponse:
        """Delete a clean room asset - unshare/remove the asset from the clean room"""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        kwargs['asset_type'] = asset_type
        kwargs['name'] = name
        try:
            result = self._ws.clean_room_assets.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_room_assets_get(
        self,
        clean_room_name: str,
        asset_type: Dict[str, Any],
        name: str,
    ) -> DatabricksResponse:
        """Get the details of a clean room asset by its type and full name."""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        kwargs['asset_type'] = asset_type
        kwargs['name'] = name
        try:
            result = self._ws.clean_room_assets.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_room_assets_list(self, clean_room_name: str, page_token: Optional[str] = None) -> DatabricksResponse:
        """List assets."""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.clean_room_assets.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_room_assets_update(
        self,
        clean_room_name: str,
        asset_type: Dict[str, Any],
        name: str,
        asset: Dict[str, Any],
    ) -> DatabricksResponse:
        """Update a clean room asset. For example, updating the content of a notebook; changing the shared partitions of a table; etc."""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        kwargs['asset_type'] = asset_type
        kwargs['name'] = name
        kwargs['asset'] = asset
        try:
            result = self._ws.clean_room_assets.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CLEAN ROOM AUTO APPROVAL RULES (CleanRoomAutoApprovalRulesAPI) — 5 methods
    # ============================================================================

    async def clean_room_auto_approval_rules_create(self, clean_room_name: str, auto_approval_rule: Dict[str, Any]) -> DatabricksResponse:
        """Create an auto-approval rule"""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        kwargs['auto_approval_rule'] = auto_approval_rule
        try:
            result = self._ws.clean_room_auto_approval_rules.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_room_auto_approval_rules_delete(self, clean_room_name: str, rule_id: str) -> DatabricksResponse:
        """Delete a auto-approval rule by rule ID"""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        kwargs['rule_id'] = rule_id
        try:
            result = self._ws.clean_room_auto_approval_rules.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_room_auto_approval_rules_get(self, clean_room_name: str, rule_id: str) -> DatabricksResponse:
        """Get a auto-approval rule by rule ID"""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        kwargs['rule_id'] = rule_id
        try:
            result = self._ws.clean_room_auto_approval_rules.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_room_auto_approval_rules_list(
        self,
        clean_room_name: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List all auto-approval rules for the caller"""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.clean_room_auto_approval_rules.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_room_auto_approval_rules_update(
        self,
        clean_room_name: str,
        rule_id: str,
        auto_approval_rule: Dict[str, Any],
    ) -> DatabricksResponse:
        """Update a auto-approval rule by rule ID"""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        kwargs['rule_id'] = rule_id
        kwargs['auto_approval_rule'] = auto_approval_rule
        try:
            result = self._ws.clean_room_auto_approval_rules.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CLEAN ROOM TASK RUNS (CleanRoomTaskRunsAPI) — 1 methods
    # ============================================================================

    async def clean_room_task_runs_list(
        self,
        clean_room_name: str,
        notebook_name: Optional[str] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List all the historical notebook task runs in a clean room."""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        if notebook_name is not None:
            kwargs['notebook_name'] = notebook_name
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.clean_room_task_runs.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CLEAN ROOMS (CleanRoomsAPI) — 6 methods
    # ============================================================================

    async def clean_rooms_create(self, clean_room: Dict[str, Any]) -> DatabricksResponse:
        """Create a new clean room with the specified collaborators. This method is asynchronous; the returned name field inside the clean_room field can be used to poll the clean room status, using the :meth..."""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room'] = clean_room
        try:
            result = self._ws.clean_rooms.create(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_rooms_create_output_catalog(self, clean_room_name: str, output_catalog: Dict[str, Any]) -> DatabricksResponse:
        """Create the output catalog of the clean room."""
        kwargs: Dict[str, Any] = {}
        kwargs['clean_room_name'] = clean_room_name
        kwargs['output_catalog'] = output_catalog
        try:
            result = self._ws.clean_rooms.create_output_catalog(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_rooms_delete(self, name: str) -> DatabricksResponse:
        """Delete a clean room. After deletion, the clean room will be removed from the metastore. If the other collaborators have not deleted the clean room, they will still have the clean room in their meta..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.clean_rooms.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_rooms_get(self, name: str) -> DatabricksResponse:
        """Get the details of a clean room given its name."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.clean_rooms.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_rooms_list(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Get a list of all clean rooms of the metastore. Only clean rooms the caller has access to are returned."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.clean_rooms.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clean_rooms_update(
        self,
        name: str,
        clean_room: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Update a clean room. The caller must be the owner of the clean room, have **MODIFY_CLEAN_ROOM** privilege, or be metastore admin."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if clean_room is not None:
            kwargs['clean_room'] = clean_room
        try:
            result = self._ws.clean_rooms.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CLUSTER POLICIES (ClusterPoliciesAPI) — 9 methods
    # ============================================================================

    async def cluster_policies_create(
        self,
        definition: Optional[str] = None,
        description: Optional[str] = None,
        libraries: Optional[List[Dict[str, Any]]] = None,
        max_clusters_per_user: Optional[int] = None,
        name: Optional[str] = None,
        policy_family_definition_overrides: Optional[str] = None,
        policy_family_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new policy with prescribed settings."""
        kwargs: Dict[str, Any] = {}
        if definition is not None:
            kwargs['definition'] = definition
        if description is not None:
            kwargs['description'] = description
        if libraries is not None:
            kwargs['libraries'] = libraries
        if max_clusters_per_user is not None:
            kwargs['max_clusters_per_user'] = max_clusters_per_user
        if name is not None:
            kwargs['name'] = name
        if policy_family_definition_overrides is not None:
            kwargs['policy_family_definition_overrides'] = policy_family_definition_overrides
        if policy_family_id is not None:
            kwargs['policy_family_id'] = policy_family_id
        try:
            result = self._ws.cluster_policies.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def cluster_policies_delete(self, policy_id: str) -> DatabricksResponse:
        """Delete a policy for a cluster. Clusters governed by this policy can still run, but cannot be edited."""
        kwargs: Dict[str, Any] = {}
        kwargs['policy_id'] = policy_id
        try:
            result = self._ws.cluster_policies.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def cluster_policies_edit(
        self,
        policy_id: str,
        definition: Optional[str] = None,
        description: Optional[str] = None,
        libraries: Optional[List[Dict[str, Any]]] = None,
        max_clusters_per_user: Optional[int] = None,
        name: Optional[str] = None,
        policy_family_definition_overrides: Optional[str] = None,
        policy_family_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Update an existing policy for cluster. This operation may make some clusters governed by the previous policy invalid."""
        kwargs: Dict[str, Any] = {}
        kwargs['policy_id'] = policy_id
        if definition is not None:
            kwargs['definition'] = definition
        if description is not None:
            kwargs['description'] = description
        if libraries is not None:
            kwargs['libraries'] = libraries
        if max_clusters_per_user is not None:
            kwargs['max_clusters_per_user'] = max_clusters_per_user
        if name is not None:
            kwargs['name'] = name
        if policy_family_definition_overrides is not None:
            kwargs['policy_family_definition_overrides'] = policy_family_definition_overrides
        if policy_family_id is not None:
            kwargs['policy_family_id'] = policy_family_id
        try:
            result = self._ws.cluster_policies.edit(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def cluster_policies_get(self, policy_id: str) -> DatabricksResponse:
        """Get a cluster policy entity. Creation and editing is available to admins only."""
        kwargs: Dict[str, Any] = {}
        kwargs['policy_id'] = policy_id
        try:
            result = self._ws.cluster_policies.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def cluster_policies_get_permission_levels(self, cluster_policy_id: str) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_policy_id'] = cluster_policy_id
        try:
            result = self._ws.cluster_policies.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def cluster_policies_get_permissions(self, cluster_policy_id: str) -> DatabricksResponse:
        """Gets the permissions of a cluster policy. Cluster policies can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_policy_id'] = cluster_policy_id
        try:
            result = self._ws.cluster_policies.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def cluster_policies_list(
        self,
        sort_column: Optional[Dict[str, Any]] = None,
        sort_order: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Returns a list of policies accessible by the requesting user."""
        kwargs: Dict[str, Any] = {}
        if sort_column is not None:
            kwargs['sort_column'] = sort_column
        if sort_order is not None:
            kwargs['sort_order'] = sort_order
        try:
            result = list(self._ws.cluster_policies.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def cluster_policies_set_permissions(
        self,
        cluster_policy_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_policy_id'] = cluster_policy_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.cluster_policies.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def cluster_policies_update_permissions(
        self,
        cluster_policy_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on a cluster policy. Cluster policies can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_policy_id'] = cluster_policy_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.cluster_policies.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CLUSTERS (ClustersExt) — 24 methods
    # ============================================================================

    async def clusters_change_owner(self, cluster_id: str, owner_username: str) -> DatabricksResponse:
        """Change the owner of the cluster. You must be an admin and the cluster must be terminated to perform this operation. The service principal application ID can be supplied as an argument to `owner_use..."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        kwargs['owner_username'] = owner_username
        try:
            result = self._ws.clusters.change_owner(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_create(
        self,
        spark_version: str,
        apply_policy_default_values: Optional[bool] = None,
        autoscale: Optional[Dict[str, Any]] = None,
        autotermination_minutes: Optional[int] = None,
        aws_attributes: Optional[Dict[str, Any]] = None,
        azure_attributes: Optional[Dict[str, Any]] = None,
        clone_from: Optional[Dict[str, Any]] = None,
        cluster_log_conf: Optional[Dict[str, Any]] = None,
        cluster_name: Optional[str] = None,
        custom_tags: Optional[Dict[str, str]] = None,
        data_security_mode: Optional[Dict[str, Any]] = None,
        docker_image: Optional[Dict[str, Any]] = None,
        driver_instance_pool_id: Optional[str] = None,
        driver_node_type_flexibility: Optional[Dict[str, Any]] = None,
        driver_node_type_id: Optional[str] = None,
        enable_elastic_disk: Optional[bool] = None,
        enable_local_disk_encryption: Optional[bool] = None,
        gcp_attributes: Optional[Dict[str, Any]] = None,
        init_scripts: Optional[List[Dict[str, Any]]] = None,
        instance_pool_id: Optional[str] = None,
        is_single_node: Optional[bool] = None,
        kind: Optional[Dict[str, Any]] = None,
        node_type_id: Optional[str] = None,
        num_workers: Optional[int] = None,
        policy_id: Optional[str] = None,
        remote_disk_throughput: Optional[int] = None,
        runtime_engine: Optional[Dict[str, Any]] = None,
        single_user_name: Optional[str] = None,
        spark_conf: Optional[Dict[str, str]] = None,
        spark_env_vars: Optional[Dict[str, str]] = None,
        ssh_public_keys: Optional[List[str]] = None,
        total_initial_remote_disk_size: Optional[int] = None,
        use_ml_runtime: Optional[bool] = None,
        worker_node_type_flexibility: Optional[Dict[str, Any]] = None,
        workload_type: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Creates a new Spark cluster. This method will acquire new instances from the cloud provider if necessary. This method is asynchronous; the returned ``cluster_id`` can be used to poll the cluster st..."""
        kwargs: Dict[str, Any] = {}
        kwargs['spark_version'] = spark_version
        if apply_policy_default_values is not None:
            kwargs['apply_policy_default_values'] = apply_policy_default_values
        if autoscale is not None:
            kwargs['autoscale'] = autoscale
        if autotermination_minutes is not None:
            kwargs['autotermination_minutes'] = autotermination_minutes
        if aws_attributes is not None:
            kwargs['aws_attributes'] = aws_attributes
        if azure_attributes is not None:
            kwargs['azure_attributes'] = azure_attributes
        if clone_from is not None:
            kwargs['clone_from'] = clone_from
        if cluster_log_conf is not None:
            kwargs['cluster_log_conf'] = cluster_log_conf
        if cluster_name is not None:
            kwargs['cluster_name'] = cluster_name
        if custom_tags is not None:
            kwargs['custom_tags'] = custom_tags
        if data_security_mode is not None:
            kwargs['data_security_mode'] = data_security_mode
        if docker_image is not None:
            kwargs['docker_image'] = docker_image
        if driver_instance_pool_id is not None:
            kwargs['driver_instance_pool_id'] = driver_instance_pool_id
        if driver_node_type_flexibility is not None:
            kwargs['driver_node_type_flexibility'] = driver_node_type_flexibility
        if driver_node_type_id is not None:
            kwargs['driver_node_type_id'] = driver_node_type_id
        if enable_elastic_disk is not None:
            kwargs['enable_elastic_disk'] = enable_elastic_disk
        if enable_local_disk_encryption is not None:
            kwargs['enable_local_disk_encryption'] = enable_local_disk_encryption
        if gcp_attributes is not None:
            kwargs['gcp_attributes'] = gcp_attributes
        if init_scripts is not None:
            kwargs['init_scripts'] = init_scripts
        if instance_pool_id is not None:
            kwargs['instance_pool_id'] = instance_pool_id
        if is_single_node is not None:
            kwargs['is_single_node'] = is_single_node
        if kind is not None:
            kwargs['kind'] = kind
        if node_type_id is not None:
            kwargs['node_type_id'] = node_type_id
        if num_workers is not None:
            kwargs['num_workers'] = num_workers
        if policy_id is not None:
            kwargs['policy_id'] = policy_id
        if remote_disk_throughput is not None:
            kwargs['remote_disk_throughput'] = remote_disk_throughput
        if runtime_engine is not None:
            kwargs['runtime_engine'] = runtime_engine
        if single_user_name is not None:
            kwargs['single_user_name'] = single_user_name
        if spark_conf is not None:
            kwargs['spark_conf'] = spark_conf
        if spark_env_vars is not None:
            kwargs['spark_env_vars'] = spark_env_vars
        if ssh_public_keys is not None:
            kwargs['ssh_public_keys'] = ssh_public_keys
        if total_initial_remote_disk_size is not None:
            kwargs['total_initial_remote_disk_size'] = total_initial_remote_disk_size
        if use_ml_runtime is not None:
            kwargs['use_ml_runtime'] = use_ml_runtime
        if worker_node_type_flexibility is not None:
            kwargs['worker_node_type_flexibility'] = worker_node_type_flexibility
        if workload_type is not None:
            kwargs['workload_type'] = workload_type
        try:
            result = self._ws.clusters.create(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_delete(self, cluster_id: str) -> DatabricksResponse:
        """Terminates the Spark cluster with the specified ID. The cluster is removed asynchronously. Once the termination has completed, the cluster will be in a `TERMINATED` state. If the cluster is already..."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        try:
            result = self._ws.clusters.delete(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_edit(
        self,
        cluster_id: str,
        spark_version: str,
        apply_policy_default_values: Optional[bool] = None,
        autoscale: Optional[Dict[str, Any]] = None,
        autotermination_minutes: Optional[int] = None,
        aws_attributes: Optional[Dict[str, Any]] = None,
        azure_attributes: Optional[Dict[str, Any]] = None,
        cluster_log_conf: Optional[Dict[str, Any]] = None,
        cluster_name: Optional[str] = None,
        custom_tags: Optional[Dict[str, str]] = None,
        data_security_mode: Optional[Dict[str, Any]] = None,
        docker_image: Optional[Dict[str, Any]] = None,
        driver_instance_pool_id: Optional[str] = None,
        driver_node_type_flexibility: Optional[Dict[str, Any]] = None,
        driver_node_type_id: Optional[str] = None,
        enable_elastic_disk: Optional[bool] = None,
        enable_local_disk_encryption: Optional[bool] = None,
        gcp_attributes: Optional[Dict[str, Any]] = None,
        init_scripts: Optional[List[Dict[str, Any]]] = None,
        instance_pool_id: Optional[str] = None,
        is_single_node: Optional[bool] = None,
        kind: Optional[Dict[str, Any]] = None,
        node_type_id: Optional[str] = None,
        num_workers: Optional[int] = None,
        policy_id: Optional[str] = None,
        remote_disk_throughput: Optional[int] = None,
        runtime_engine: Optional[Dict[str, Any]] = None,
        single_user_name: Optional[str] = None,
        spark_conf: Optional[Dict[str, str]] = None,
        spark_env_vars: Optional[Dict[str, str]] = None,
        ssh_public_keys: Optional[List[str]] = None,
        total_initial_remote_disk_size: Optional[int] = None,
        use_ml_runtime: Optional[bool] = None,
        worker_node_type_flexibility: Optional[Dict[str, Any]] = None,
        workload_type: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Updates the configuration of a cluster to match the provided attributes and size. A cluster can be updated if it is in a `RUNNING` or `TERMINATED` state."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        kwargs['spark_version'] = spark_version
        if apply_policy_default_values is not None:
            kwargs['apply_policy_default_values'] = apply_policy_default_values
        if autoscale is not None:
            kwargs['autoscale'] = autoscale
        if autotermination_minutes is not None:
            kwargs['autotermination_minutes'] = autotermination_minutes
        if aws_attributes is not None:
            kwargs['aws_attributes'] = aws_attributes
        if azure_attributes is not None:
            kwargs['azure_attributes'] = azure_attributes
        if cluster_log_conf is not None:
            kwargs['cluster_log_conf'] = cluster_log_conf
        if cluster_name is not None:
            kwargs['cluster_name'] = cluster_name
        if custom_tags is not None:
            kwargs['custom_tags'] = custom_tags
        if data_security_mode is not None:
            kwargs['data_security_mode'] = data_security_mode
        if docker_image is not None:
            kwargs['docker_image'] = docker_image
        if driver_instance_pool_id is not None:
            kwargs['driver_instance_pool_id'] = driver_instance_pool_id
        if driver_node_type_flexibility is not None:
            kwargs['driver_node_type_flexibility'] = driver_node_type_flexibility
        if driver_node_type_id is not None:
            kwargs['driver_node_type_id'] = driver_node_type_id
        if enable_elastic_disk is not None:
            kwargs['enable_elastic_disk'] = enable_elastic_disk
        if enable_local_disk_encryption is not None:
            kwargs['enable_local_disk_encryption'] = enable_local_disk_encryption
        if gcp_attributes is not None:
            kwargs['gcp_attributes'] = gcp_attributes
        if init_scripts is not None:
            kwargs['init_scripts'] = init_scripts
        if instance_pool_id is not None:
            kwargs['instance_pool_id'] = instance_pool_id
        if is_single_node is not None:
            kwargs['is_single_node'] = is_single_node
        if kind is not None:
            kwargs['kind'] = kind
        if node_type_id is not None:
            kwargs['node_type_id'] = node_type_id
        if num_workers is not None:
            kwargs['num_workers'] = num_workers
        if policy_id is not None:
            kwargs['policy_id'] = policy_id
        if remote_disk_throughput is not None:
            kwargs['remote_disk_throughput'] = remote_disk_throughput
        if runtime_engine is not None:
            kwargs['runtime_engine'] = runtime_engine
        if single_user_name is not None:
            kwargs['single_user_name'] = single_user_name
        if spark_conf is not None:
            kwargs['spark_conf'] = spark_conf
        if spark_env_vars is not None:
            kwargs['spark_env_vars'] = spark_env_vars
        if ssh_public_keys is not None:
            kwargs['ssh_public_keys'] = ssh_public_keys
        if total_initial_remote_disk_size is not None:
            kwargs['total_initial_remote_disk_size'] = total_initial_remote_disk_size
        if use_ml_runtime is not None:
            kwargs['use_ml_runtime'] = use_ml_runtime
        if worker_node_type_flexibility is not None:
            kwargs['worker_node_type_flexibility'] = worker_node_type_flexibility
        if workload_type is not None:
            kwargs['workload_type'] = workload_type
        try:
            result = self._ws.clusters.edit(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_ensure_cluster_is_running(self, cluster_id: str) -> DatabricksResponse:
        """Ensures that given cluster is running, regardless of the current state"""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        try:
            result = self._ws.clusters.ensure_cluster_is_running(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_events(
        self,
        cluster_id: str,
        end_time: Optional[int] = None,
        event_types: Optional[List[Dict[str, Any]]] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        order: Optional[Dict[str, Any]] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        start_time: Optional[int] = None,
    ) -> DatabricksResponse:
        """Retrieves a list of events about the activity of a cluster. This API is paginated. If there are more events to read, the response includes all the parameters necessary to request the next page of e..."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        if end_time is not None:
            kwargs['end_time'] = end_time
        if event_types is not None:
            kwargs['event_types'] = event_types
        if limit is not None:
            kwargs['limit'] = limit
        if offset is not None:
            kwargs['offset'] = offset
        if order is not None:
            kwargs['order'] = order
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        if start_time is not None:
            kwargs['start_time'] = start_time
        try:
            result = list(self._ws.clusters.events(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_get(self, cluster_id: str) -> DatabricksResponse:
        """Retrieves the information for a cluster given its identifier. Clusters can be described while they are running, or up to 60 days after they are terminated."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        try:
            result = self._ws.clusters.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_get_permission_levels(self, cluster_id: str) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        try:
            result = self._ws.clusters.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_get_permissions(self, cluster_id: str) -> DatabricksResponse:
        """Gets the permissions of a cluster. Clusters can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        try:
            result = self._ws.clusters.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_list(
        self,
        filter_by: Optional[Dict[str, Any]] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        sort_by: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Return information about all pinned and active clusters, and all clusters terminated within the last 30 days. Clusters terminated prior to this period are not included."""
        kwargs: Dict[str, Any] = {}
        if filter_by is not None:
            kwargs['filter_by'] = filter_by
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        if sort_by is not None:
            kwargs['sort_by'] = sort_by
        try:
            result = list(self._ws.clusters.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_list_node_types(self) -> DatabricksResponse:
        """Returns a list of supported Spark node types. These node types can be used to launch a cluster."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.clusters.list_node_types(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_list_zones(self) -> DatabricksResponse:
        """Returns a list of availability zones where clusters can be created in (For example, us-west-2a). These zones can be used to launch a cluster."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.clusters.list_zones(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_permanent_delete(self, cluster_id: str) -> DatabricksResponse:
        """Permanently deletes a Spark cluster. This cluster is terminated and resources are asynchronously removed."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        try:
            result = self._ws.clusters.permanent_delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_pin(self, cluster_id: str) -> DatabricksResponse:
        """Pinning a cluster ensures that the cluster will always be returned by the ListClusters API. Pinning a cluster that is already pinned will have no effect. This API can only be called by workspace ad..."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        try:
            result = self._ws.clusters.pin(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_resize(
        self,
        cluster_id: str,
        autoscale: Optional[Dict[str, Any]] = None,
        num_workers: Optional[int] = None,
    ) -> DatabricksResponse:
        """Resizes a cluster to have a desired number of workers. This will fail unless the cluster is in a `RUNNING` state."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        if autoscale is not None:
            kwargs['autoscale'] = autoscale
        if num_workers is not None:
            kwargs['num_workers'] = num_workers
        try:
            result = self._ws.clusters.resize(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_restart(self, cluster_id: str, restart_user: Optional[str] = None) -> DatabricksResponse:
        """Restarts a Spark cluster with the supplied ID. If the cluster is not currently in a `RUNNING` state, nothing will happen."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        if restart_user is not None:
            kwargs['restart_user'] = restart_user
        try:
            result = self._ws.clusters.restart(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_select_node_type(
        self,
        min_memory_gb: Optional[int] = None,
        gb_per_core: Optional[int] = None,
        min_cores: Optional[int] = None,
        min_gpus: Optional[int] = None,
        local_disk: Optional[bool] = None,
        local_disk_min_size: Optional[int] = None,
        category: Optional[str] = None,
        photon_worker_capable: Optional[bool] = None,
        photon_driver_capable: Optional[bool] = None,
        graviton: Optional[bool] = None,
        is_io_cache_enabled: Optional[bool] = None,
        support_port_forwarding: Optional[bool] = None,
        fleet: Optional[str] = None,
    ) -> DatabricksResponse:
        """Selects smallest available node type given the conditions."""
        kwargs: Dict[str, Any] = {}
        if min_memory_gb is not None:
            kwargs['min_memory_gb'] = min_memory_gb
        if gb_per_core is not None:
            kwargs['gb_per_core'] = gb_per_core
        if min_cores is not None:
            kwargs['min_cores'] = min_cores
        if min_gpus is not None:
            kwargs['min_gpus'] = min_gpus
        if local_disk is not None:
            kwargs['local_disk'] = local_disk
        if local_disk_min_size is not None:
            kwargs['local_disk_min_size'] = local_disk_min_size
        if category is not None:
            kwargs['category'] = category
        if photon_worker_capable is not None:
            kwargs['photon_worker_capable'] = photon_worker_capable
        if photon_driver_capable is not None:
            kwargs['photon_driver_capable'] = photon_driver_capable
        if graviton is not None:
            kwargs['graviton'] = graviton
        if is_io_cache_enabled is not None:
            kwargs['is_io_cache_enabled'] = is_io_cache_enabled
        if support_port_forwarding is not None:
            kwargs['support_port_forwarding'] = support_port_forwarding
        if fleet is not None:
            kwargs['fleet'] = fleet
        try:
            result = self._ws.clusters.select_node_type(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_select_spark_version(
        self,
        long_term_support: Optional[bool] = False,
        beta: Optional[bool] = False,
        latest: Optional[bool] = True,
        ml: Optional[bool] = False,
        genomics: Optional[bool] = False,
        gpu: Optional[bool] = False,
        scala: Optional[str] = '2.12',
        spark_version: Optional[str] = None,
        photon: Optional[bool] = False,
        graviton: Optional[bool] = False,
    ) -> DatabricksResponse:
        """Selects the latest Databricks Runtime Version."""
        kwargs: Dict[str, Any] = {}
        if long_term_support is not None:
            kwargs['long_term_support'] = long_term_support
        if beta is not None:
            kwargs['beta'] = beta
        if latest is not None:
            kwargs['latest'] = latest
        if ml is not None:
            kwargs['ml'] = ml
        if genomics is not None:
            kwargs['genomics'] = genomics
        if gpu is not None:
            kwargs['gpu'] = gpu
        if scala is not None:
            kwargs['scala'] = scala
        if spark_version is not None:
            kwargs['spark_version'] = spark_version
        if photon is not None:
            kwargs['photon'] = photon
        if graviton is not None:
            kwargs['graviton'] = graviton
        try:
            result = self._ws.clusters.select_spark_version(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_set_permissions(
        self,
        cluster_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.clusters.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_spark_versions(self) -> DatabricksResponse:
        """Returns the list of available Spark versions. These versions can be used to launch a cluster."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.clusters.spark_versions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_start(self, cluster_id: str) -> DatabricksResponse:
        """Starts a terminated Spark cluster with the supplied ID. This works similar to `createCluster` except: - The previous cluster id and attributes are preserved. - The cluster starts with the last spec..."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        try:
            result = self._ws.clusters.start(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_unpin(self, cluster_id: str) -> DatabricksResponse:
        """Unpinning a cluster will allow the cluster to eventually be removed from the ListClusters API. Unpinning a cluster that is not pinned will have no effect. This API can only be called by workspace a..."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        try:
            result = self._ws.clusters.unpin(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_update(
        self,
        cluster_id: str,
        update_mask: str,
        cluster: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Updates the configuration of a cluster to match the partial set of attributes and size. Denote which fields to update using the `update_mask` field in the request body. A cluster can be updated if ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        kwargs['update_mask'] = update_mask
        if cluster is not None:
            kwargs['cluster'] = cluster
        try:
            result = self._ws.clusters.update(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def clusters_update_permissions(
        self,
        cluster_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on a cluster. Clusters can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.clusters.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # COMMAND EXECUTION (CommandExecutionAPI) — 6 methods
    # ============================================================================

    async def command_execution_cancel(
        self,
        cluster_id: Optional[str] = None,
        command_id: Optional[str] = None,
        context_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Cancels a currently running command within an execution context."""
        kwargs: Dict[str, Any] = {}
        if cluster_id is not None:
            kwargs['cluster_id'] = cluster_id
        if command_id is not None:
            kwargs['command_id'] = command_id
        if context_id is not None:
            kwargs['context_id'] = context_id
        try:
            result = self._ws.command_execution.cancel(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def command_execution_command_status(
        self,
        cluster_id: str,
        context_id: str,
        command_id: str,
    ) -> DatabricksResponse:
        """Gets the status of and, if available, the results from a currently executing command."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        kwargs['context_id'] = context_id
        kwargs['command_id'] = command_id
        try:
            result = self._ws.command_execution.command_status(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def command_execution_context_status(self, cluster_id: str, context_id: str) -> DatabricksResponse:
        """Gets the status for an execution context."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        kwargs['context_id'] = context_id
        try:
            result = self._ws.command_execution.context_status(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def command_execution_create(
        self,
        cluster_id: Optional[str] = None,
        language: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Creates an execution context for running cluster commands."""
        kwargs: Dict[str, Any] = {}
        if cluster_id is not None:
            kwargs['cluster_id'] = cluster_id
        if language is not None:
            kwargs['language'] = language
        try:
            result = self._ws.command_execution.create(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def command_execution_destroy(self, cluster_id: str, context_id: str) -> DatabricksResponse:
        """Deletes an execution context."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        kwargs['context_id'] = context_id
        try:
            result = self._ws.command_execution.destroy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def command_execution_execute(
        self,
        cluster_id: Optional[str] = None,
        command: Optional[str] = None,
        context_id: Optional[str] = None,
        language: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Runs a cluster command in the given execution context, using the provided language."""
        kwargs: Dict[str, Any] = {}
        if cluster_id is not None:
            kwargs['cluster_id'] = cluster_id
        if command is not None:
            kwargs['command'] = command
        if context_id is not None:
            kwargs['context_id'] = context_id
        if language is not None:
            kwargs['language'] = language
        try:
            result = self._ws.command_execution.execute(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CONNECTIONS (ConnectionsAPI) — 5 methods
    # ============================================================================

    async def connections_create(
        self,
        name: str,
        connection_type: Dict[str, Any],
        options: Dict[str, str],
        comment: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        read_only: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Creates a new connection"""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['connection_type'] = connection_type
        kwargs['options'] = options
        if comment is not None:
            kwargs['comment'] = comment
        if properties is not None:
            kwargs['properties'] = properties
        if read_only is not None:
            kwargs['read_only'] = read_only
        try:
            result = self._ws.connections.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def connections_delete(self, name: str) -> DatabricksResponse:
        """Deletes the connection that matches the supplied name."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.connections.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def connections_get(self, name: str) -> DatabricksResponse:
        """Gets a connection from it's name."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.connections.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def connections_list(self, max_results: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """List all connections."""
        kwargs: Dict[str, Any] = {}
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.connections.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def connections_update(
        self,
        name: str,
        options: Dict[str, str],
        new_name: Optional[str] = None,
        owner: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates the connection that matches the supplied name."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['options'] = options
        if new_name is not None:
            kwargs['new_name'] = new_name
        if owner is not None:
            kwargs['owner'] = owner
        try:
            result = self._ws.connections.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CONSUMER FULFILLMENTS (ConsumerFulfillmentsAPI) — 2 methods
    # ============================================================================

    async def consumer_fulfillments_get(
        self,
        listing_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Get a high level preview of the metadata of listing installable content."""
        kwargs: Dict[str, Any] = {}
        kwargs['listing_id'] = listing_id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.consumer_fulfillments.get(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def consumer_fulfillments_list(
        self,
        listing_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Get all listings fulfillments associated with a listing. A _fulfillment_ is a potential installation. Standard installations contain metadata about the attached share or git repo. Only one of these..."""
        kwargs: Dict[str, Any] = {}
        kwargs['listing_id'] = listing_id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.consumer_fulfillments.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CONSUMER INSTALLATIONS (ConsumerInstallationsAPI) — 5 methods
    # ============================================================================

    async def consumer_installations_create(
        self,
        listing_id: str,
        accepted_consumer_terms: Optional[Dict[str, Any]] = None,
        catalog_name: Optional[str] = None,
        recipient_type: Optional[Dict[str, Any]] = None,
        repo_detail: Optional[Dict[str, Any]] = None,
        share_name: Optional[str] = None,
    ) -> DatabricksResponse:
        """Install payload associated with a Databricks Marketplace listing."""
        kwargs: Dict[str, Any] = {}
        kwargs['listing_id'] = listing_id
        if accepted_consumer_terms is not None:
            kwargs['accepted_consumer_terms'] = accepted_consumer_terms
        if catalog_name is not None:
            kwargs['catalog_name'] = catalog_name
        if recipient_type is not None:
            kwargs['recipient_type'] = recipient_type
        if repo_detail is not None:
            kwargs['repo_detail'] = repo_detail
        if share_name is not None:
            kwargs['share_name'] = share_name
        try:
            result = self._ws.consumer_installations.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def consumer_installations_delete(self, listing_id: str, installation_id: str) -> DatabricksResponse:
        """Uninstall an installation associated with a Databricks Marketplace listing."""
        kwargs: Dict[str, Any] = {}
        kwargs['listing_id'] = listing_id
        kwargs['installation_id'] = installation_id
        try:
            result = self._ws.consumer_installations.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def consumer_installations_list(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """List all installations across all listings."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.consumer_installations.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def consumer_installations_list_listing_installations(
        self,
        listing_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List all installations for a particular listing."""
        kwargs: Dict[str, Any] = {}
        kwargs['listing_id'] = listing_id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.consumer_installations.list_listing_installations(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def consumer_installations_update(
        self,
        listing_id: str,
        installation_id: str,
        installation: Dict[str, Any],
        rotate_token: Optional[bool] = None,
    ) -> DatabricksResponse:
        """This is a update API that will update the part of the fields defined in the installation table as well as interact with external services according to the fields not included in the installation ta..."""
        kwargs: Dict[str, Any] = {}
        kwargs['listing_id'] = listing_id
        kwargs['installation_id'] = installation_id
        kwargs['installation'] = installation
        if rotate_token is not None:
            kwargs['rotate_token'] = rotate_token
        try:
            result = self._ws.consumer_installations.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CONSUMER LISTINGS (ConsumerListingsAPI) — 4 methods
    # ============================================================================

    async def consumer_listings_batch_get(self, ids: Optional[List[str]] = None) -> DatabricksResponse:
        """Batch get a published listing in the Databricks Marketplace that the consumer has access to."""
        kwargs: Dict[str, Any] = {}
        if ids is not None:
            kwargs['ids'] = ids
        try:
            result = self._ws.consumer_listings.batch_get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def consumer_listings_get(self, id: str) -> DatabricksResponse:
        """Get a published listing in the Databricks Marketplace that the consumer has access to."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.consumer_listings.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def consumer_listings_list(
        self,
        assets: Optional[List[Dict[str, Any]]] = None,
        categories: Optional[List[Dict[str, Any]]] = None,
        is_free: Optional[bool] = None,
        is_private_exchange: Optional[bool] = None,
        is_staff_pick: Optional[bool] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        provider_ids: Optional[List[str]] = None,
        tags: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """List all published listings in the Databricks Marketplace that the consumer has access to."""
        kwargs: Dict[str, Any] = {}
        if assets is not None:
            kwargs['assets'] = assets
        if categories is not None:
            kwargs['categories'] = categories
        if is_free is not None:
            kwargs['is_free'] = is_free
        if is_private_exchange is not None:
            kwargs['is_private_exchange'] = is_private_exchange
        if is_staff_pick is not None:
            kwargs['is_staff_pick'] = is_staff_pick
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        if provider_ids is not None:
            kwargs['provider_ids'] = provider_ids
        if tags is not None:
            kwargs['tags'] = tags
        try:
            result = list(self._ws.consumer_listings.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def consumer_listings_search(
        self,
        query: str,
        assets: Optional[List[Dict[str, Any]]] = None,
        categories: Optional[List[Dict[str, Any]]] = None,
        is_free: Optional[bool] = None,
        is_private_exchange: Optional[bool] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        provider_ids: Optional[List[str]] = None,
    ) -> DatabricksResponse:
        """Search published listings in the Databricks Marketplace that the consumer has access to. This query supports a variety of different search parameters and performs fuzzy matching."""
        kwargs: Dict[str, Any] = {}
        kwargs['query'] = query
        if assets is not None:
            kwargs['assets'] = assets
        if categories is not None:
            kwargs['categories'] = categories
        if is_free is not None:
            kwargs['is_free'] = is_free
        if is_private_exchange is not None:
            kwargs['is_private_exchange'] = is_private_exchange
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        if provider_ids is not None:
            kwargs['provider_ids'] = provider_ids
        try:
            result = list(self._ws.consumer_listings.search(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CONSUMER PERSONALIZATION REQUESTS (ConsumerPersonalizationRequestsAPI) — 3 methods
    # ============================================================================

    async def consumer_personalization_requests_create(
        self,
        listing_id: str,
        intended_use: str,
        accepted_consumer_terms: Dict[str, Any],
        comment: Optional[str] = None,
        company: Optional[str] = None,
        first_name: Optional[str] = None,
        is_from_lighthouse: Optional[bool] = None,
        last_name: Optional[str] = None,
        recipient_type: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Create a personalization request for a listing."""
        kwargs: Dict[str, Any] = {}
        kwargs['listing_id'] = listing_id
        kwargs['intended_use'] = intended_use
        kwargs['accepted_consumer_terms'] = accepted_consumer_terms
        if comment is not None:
            kwargs['comment'] = comment
        if company is not None:
            kwargs['company'] = company
        if first_name is not None:
            kwargs['first_name'] = first_name
        if is_from_lighthouse is not None:
            kwargs['is_from_lighthouse'] = is_from_lighthouse
        if last_name is not None:
            kwargs['last_name'] = last_name
        if recipient_type is not None:
            kwargs['recipient_type'] = recipient_type
        try:
            result = self._ws.consumer_personalization_requests.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def consumer_personalization_requests_get(self, listing_id: str) -> DatabricksResponse:
        """Get the personalization request for a listing. Each consumer can make at *most* one personalization request for a listing."""
        kwargs: Dict[str, Any] = {}
        kwargs['listing_id'] = listing_id
        try:
            result = self._ws.consumer_personalization_requests.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def consumer_personalization_requests_list(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """List personalization requests for a consumer across all listings."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.consumer_personalization_requests.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CONSUMER PROVIDERS (ConsumerProvidersAPI) — 3 methods
    # ============================================================================

    async def consumer_providers_batch_get(self, ids: Optional[List[str]] = None) -> DatabricksResponse:
        """Batch get a provider in the Databricks Marketplace with at least one visible listing."""
        kwargs: Dict[str, Any] = {}
        if ids is not None:
            kwargs['ids'] = ids
        try:
            result = self._ws.consumer_providers.batch_get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def consumer_providers_get(self, id: str) -> DatabricksResponse:
        """Get a provider in the Databricks Marketplace with at least one visible listing."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.consumer_providers.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def consumer_providers_list(
        self,
        is_featured: Optional[bool] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List all providers in the Databricks Marketplace with at least one visible listing."""
        kwargs: Dict[str, Any] = {}
        if is_featured is not None:
            kwargs['is_featured'] = is_featured
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.consumer_providers.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CREDENTIALS (CredentialsAPI) — 7 methods
    # ============================================================================

    async def credentials_create_credential(
        self,
        name: str,
        aws_iam_role: Optional[Dict[str, Any]] = None,
        azure_managed_identity: Optional[Dict[str, Any]] = None,
        azure_service_principal: Optional[Dict[str, Any]] = None,
        comment: Optional[str] = None,
        databricks_gcp_service_account: Optional[Dict[str, Any]] = None,
        purpose: Optional[Dict[str, Any]] = None,
        read_only: Optional[bool] = None,
        skip_validation: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Creates a new credential. The type of credential to be created is determined by the **purpose** field, which should be either **SERVICE** or **STORAGE**."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if aws_iam_role is not None:
            kwargs['aws_iam_role'] = aws_iam_role
        if azure_managed_identity is not None:
            kwargs['azure_managed_identity'] = azure_managed_identity
        if azure_service_principal is not None:
            kwargs['azure_service_principal'] = azure_service_principal
        if comment is not None:
            kwargs['comment'] = comment
        if databricks_gcp_service_account is not None:
            kwargs['databricks_gcp_service_account'] = databricks_gcp_service_account
        if purpose is not None:
            kwargs['purpose'] = purpose
        if read_only is not None:
            kwargs['read_only'] = read_only
        if skip_validation is not None:
            kwargs['skip_validation'] = skip_validation
        try:
            result = self._ws.credentials.create_credential(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def credentials_delete_credential(self, name_arg: str, force: Optional[bool] = None) -> DatabricksResponse:
        """Deletes a service or storage credential from the metastore. The caller must be an owner of the credential."""
        kwargs: Dict[str, Any] = {}
        kwargs['name_arg'] = name_arg
        if force is not None:
            kwargs['force'] = force
        try:
            result = self._ws.credentials.delete_credential(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def credentials_generate_temporary_service_credential(
        self,
        credential_name: str,
        azure_options: Optional[Dict[str, Any]] = None,
        gcp_options: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Returns a set of temporary credentials generated using the specified service credential. The caller must be a metastore admin or have the metastore privilege **ACCESS** on the service credential."""
        kwargs: Dict[str, Any] = {}
        kwargs['credential_name'] = credential_name
        if azure_options is not None:
            kwargs['azure_options'] = azure_options
        if gcp_options is not None:
            kwargs['gcp_options'] = gcp_options
        try:
            result = self._ws.credentials.generate_temporary_service_credential(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def credentials_get_credential(self, name_arg: str) -> DatabricksResponse:
        """Gets a service or storage credential from the metastore. The caller must be a metastore admin, the owner of the credential, or have any permission on the credential."""
        kwargs: Dict[str, Any] = {}
        kwargs['name_arg'] = name_arg
        try:
            result = self._ws.credentials.get_credential(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def credentials_list_credentials(
        self,
        include_unbound: Optional[bool] = None,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
        purpose: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Gets an array of credentials (as __CredentialInfo__ objects)."""
        kwargs: Dict[str, Any] = {}
        if include_unbound is not None:
            kwargs['include_unbound'] = include_unbound
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        if purpose is not None:
            kwargs['purpose'] = purpose
        try:
            result = list(self._ws.credentials.list_credentials(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def credentials_update_credential(
        self,
        name_arg: str,
        aws_iam_role: Optional[Dict[str, Any]] = None,
        azure_managed_identity: Optional[Dict[str, Any]] = None,
        azure_service_principal: Optional[Dict[str, Any]] = None,
        comment: Optional[str] = None,
        databricks_gcp_service_account: Optional[Dict[str, Any]] = None,
        force: Optional[bool] = None,
        isolation_mode: Optional[Dict[str, Any]] = None,
        new_name: Optional[str] = None,
        owner: Optional[str] = None,
        read_only: Optional[bool] = None,
        skip_validation: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Updates a service or storage credential on the metastore."""
        kwargs: Dict[str, Any] = {}
        kwargs['name_arg'] = name_arg
        if aws_iam_role is not None:
            kwargs['aws_iam_role'] = aws_iam_role
        if azure_managed_identity is not None:
            kwargs['azure_managed_identity'] = azure_managed_identity
        if azure_service_principal is not None:
            kwargs['azure_service_principal'] = azure_service_principal
        if comment is not None:
            kwargs['comment'] = comment
        if databricks_gcp_service_account is not None:
            kwargs['databricks_gcp_service_account'] = databricks_gcp_service_account
        if force is not None:
            kwargs['force'] = force
        if isolation_mode is not None:
            kwargs['isolation_mode'] = isolation_mode
        if new_name is not None:
            kwargs['new_name'] = new_name
        if owner is not None:
            kwargs['owner'] = owner
        if read_only is not None:
            kwargs['read_only'] = read_only
        if skip_validation is not None:
            kwargs['skip_validation'] = skip_validation
        try:
            result = self._ws.credentials.update_credential(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def credentials_validate_credential(
        self,
        aws_iam_role: Optional[Dict[str, Any]] = None,
        azure_managed_identity: Optional[Dict[str, Any]] = None,
        credential_name: Optional[str] = None,
        databricks_gcp_service_account: Optional[Dict[str, Any]] = None,
        external_location_name: Optional[str] = None,
        purpose: Optional[Dict[str, Any]] = None,
        read_only: Optional[bool] = None,
        url: Optional[str] = None,
    ) -> DatabricksResponse:
        """Validates a credential."""
        kwargs: Dict[str, Any] = {}
        if aws_iam_role is not None:
            kwargs['aws_iam_role'] = aws_iam_role
        if azure_managed_identity is not None:
            kwargs['azure_managed_identity'] = azure_managed_identity
        if credential_name is not None:
            kwargs['credential_name'] = credential_name
        if databricks_gcp_service_account is not None:
            kwargs['databricks_gcp_service_account'] = databricks_gcp_service_account
        if external_location_name is not None:
            kwargs['external_location_name'] = external_location_name
        if purpose is not None:
            kwargs['purpose'] = purpose
        if read_only is not None:
            kwargs['read_only'] = read_only
        if url is not None:
            kwargs['url'] = url
        try:
            result = self._ws.credentials.validate_credential(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CREDENTIALS MANAGER (CredentialsManagerAPI) — 1 methods
    # ============================================================================

    async def credentials_manager_exchange_token(
        self,
        partition_id: Dict[str, Any],
        token_type: List[Dict[str, Any]],
        scopes: List[str],
    ) -> DatabricksResponse:
        """Exchange tokens with an Identity Provider to get a new access token. It allows specifying scopes to determine token permissions."""
        kwargs: Dict[str, Any] = {}
        kwargs['partition_id'] = partition_id
        kwargs['token_type'] = token_type
        kwargs['scopes'] = scopes
        try:
            result = self._ws.credentials_manager.exchange_token(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # CURRENT USER (CurrentUserAPI) — 1 methods
    # ============================================================================

    async def current_user_me(self) -> DatabricksResponse:
        """Get details about the current method caller's identity."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.current_user.me(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # DASHBOARD WIDGETS (DashboardWidgetsAPI) — 3 methods
    # ============================================================================

    async def dashboard_widgets_create(
        self,
        dashboard_id: str,
        options: Dict[str, Any],
        width: int,
        text: Optional[str] = None,
        visualization_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Adds a widget to a dashboard"""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        kwargs['options'] = options
        kwargs['width'] = width
        if text is not None:
            kwargs['text'] = text
        if visualization_id is not None:
            kwargs['visualization_id'] = visualization_id
        try:
            result = self._ws.dashboard_widgets.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dashboard_widgets_delete(self, id: str) -> DatabricksResponse:
        """Removes a widget from a dashboard"""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.dashboard_widgets.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dashboard_widgets_update(
        self,
        id: str,
        dashboard_id: str,
        options: Dict[str, Any],
        width: int,
        text: Optional[str] = None,
        visualization_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates an existing widget"""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        kwargs['dashboard_id'] = dashboard_id
        kwargs['options'] = options
        kwargs['width'] = width
        if text is not None:
            kwargs['text'] = text
        if visualization_id is not None:
            kwargs['visualization_id'] = visualization_id
        try:
            result = self._ws.dashboard_widgets.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # DASHBOARDS (DashboardsAPI) — 5 methods
    # ============================================================================

    async def dashboards_delete(self, dashboard_id: str) -> DatabricksResponse:
        """Moves a dashboard to the trash. Trashed dashboards do not appear in list views or searches, and cannot be shared."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        try:
            result = self._ws.dashboards.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dashboards_get(self, dashboard_id: str) -> DatabricksResponse:
        """Returns a JSON representation of a dashboard object, including its visualization and query objects."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        try:
            result = self._ws.dashboards.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dashboards_list(
        self,
        order: Optional[Dict[str, Any]] = None,
        page: Optional[int] = None,
        page_size: Optional[int] = None,
        q: Optional[str] = None,
    ) -> DatabricksResponse:
        """Fetch a paginated list of dashboard objects."""
        kwargs: Dict[str, Any] = {}
        if order is not None:
            kwargs['order'] = order
        if page is not None:
            kwargs['page'] = page
        if page_size is not None:
            kwargs['page_size'] = page_size
        if q is not None:
            kwargs['q'] = q
        try:
            result = list(self._ws.dashboards.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dashboards_restore(self, dashboard_id: str) -> DatabricksResponse:
        """A restored dashboard appears in list views and searches and can be shared."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        try:
            result = self._ws.dashboards.restore(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dashboards_update(
        self,
        dashboard_id: str,
        name: Optional[str] = None,
        run_as_role: Optional[Dict[str, Any]] = None,
        tags: Optional[List[str]] = None,
    ) -> DatabricksResponse:
        """Modify this dashboard definition. This operation only affects attributes of the dashboard object. It does not add, modify, or remove widgets."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        if name is not None:
            kwargs['name'] = name
        if run_as_role is not None:
            kwargs['run_as_role'] = run_as_role
        if tags is not None:
            kwargs['tags'] = tags
        try:
            result = self._ws.dashboards.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # DATA QUALITY (DataQualityAPI) — 11 methods
    # ============================================================================

    async def data_quality_cancel_refresh(
        self,
        object_type: str,
        object_id: str,
        refresh_id: int,
    ) -> DatabricksResponse:
        """Cancels a data quality monitor refresh. Currently only supported for the `table` `object_type`. The call must be made in the same workspace as where the monitor was created."""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        kwargs['refresh_id'] = refresh_id
        try:
            result = self._ws.data_quality.cancel_refresh(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def data_quality_create_monitor(self, monitor: Dict[str, Any]) -> DatabricksResponse:
        """Create a data quality monitor on a Unity Catalog object. The caller must provide either `anomaly_detection_config` for a schema monitor or `data_profiling_config` for a table monitor."""
        kwargs: Dict[str, Any] = {}
        kwargs['monitor'] = monitor
        try:
            result = self._ws.data_quality.create_monitor(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def data_quality_create_refresh(
        self,
        object_type: str,
        object_id: str,
        refresh: Dict[str, Any],
    ) -> DatabricksResponse:
        """Creates a refresh. Currently only supported for the `table` `object_type`. The call must be made in the same workspace as where the monitor was created."""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        kwargs['refresh'] = refresh
        try:
            result = self._ws.data_quality.create_refresh(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def data_quality_delete_monitor(self, object_type: str, object_id: str) -> DatabricksResponse:
        """Delete a data quality monitor on Unity Catalog object."""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        try:
            result = self._ws.data_quality.delete_monitor(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def data_quality_delete_refresh(
        self,
        object_type: str,
        object_id: str,
        refresh_id: int,
    ) -> DatabricksResponse:
        """(Unimplemented) Delete a refresh"""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        kwargs['refresh_id'] = refresh_id
        try:
            result = self._ws.data_quality.delete_refresh(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def data_quality_get_monitor(self, object_type: str, object_id: str) -> DatabricksResponse:
        """Read a data quality monitor on a Unity Catalog object."""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        try:
            result = self._ws.data_quality.get_monitor(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def data_quality_get_refresh(
        self,
        object_type: str,
        object_id: str,
        refresh_id: int,
    ) -> DatabricksResponse:
        """Get data quality monitor refresh. The call must be made in the same workspace as where the monitor was created."""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        kwargs['refresh_id'] = refresh_id
        try:
            result = self._ws.data_quality.get_refresh(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def data_quality_list_monitor(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """(Unimplemented) List data quality monitors."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.data_quality.list_monitor(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def data_quality_list_refresh(
        self,
        object_type: str,
        object_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List data quality monitor refreshes. The call must be made in the same workspace as where the monitor was created."""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.data_quality.list_refresh(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def data_quality_update_monitor(
        self,
        object_type: str,
        object_id: str,
        monitor: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Update a data quality monitor on Unity Catalog object."""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        kwargs['monitor'] = monitor
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.data_quality.update_monitor(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def data_quality_update_refresh(
        self,
        object_type: str,
        object_id: str,
        refresh_id: int,
        refresh: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """(Unimplemented) Update a refresh"""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        kwargs['refresh_id'] = refresh_id
        kwargs['refresh'] = refresh
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.data_quality.update_refresh(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # DATA SOURCES (DataSourcesAPI) — 1 methods
    # ============================================================================

    async def data_sources_list(self) -> DatabricksResponse:
        """Retrieves a full list of SQL warehouses available in this workspace. All fields that appear in this API response are enumerated for clarity. However, you need only a SQL warehouse's `id` to create ..."""
        kwargs: Dict[str, Any] = {}
        try:
            result = list(self._ws.data_sources.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # DATABASE (DatabaseAPI) — 24 methods
    # ============================================================================

    async def database_create_database_catalog(self, catalog: Dict[str, Any]) -> DatabricksResponse:
        """Create a Database Catalog."""
        kwargs: Dict[str, Any] = {}
        kwargs['catalog'] = catalog
        try:
            result = self._ws.database.create_database_catalog(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_create_database_instance(self, database_instance: Dict[str, Any]) -> DatabricksResponse:
        """Create a Database Instance."""
        kwargs: Dict[str, Any] = {}
        kwargs['database_instance'] = database_instance
        try:
            result = self._ws.database.create_database_instance(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_create_database_instance_role(
        self,
        instance_name: str,
        database_instance_role: Dict[str, Any],
        database_instance_name: Optional[str] = None,
    ) -> DatabricksResponse:
        """Create a role for a Database Instance."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_name'] = instance_name
        kwargs['database_instance_role'] = database_instance_role
        if database_instance_name is not None:
            kwargs['database_instance_name'] = database_instance_name
        try:
            result = self._ws.database.create_database_instance_role(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_create_database_table(self, table: Dict[str, Any]) -> DatabricksResponse:
        """Create a Database Table. Useful for registering pre-existing PG tables in UC. See CreateSyncedDatabaseTable for creating synced tables in PG from a source table in UC."""
        kwargs: Dict[str, Any] = {}
        kwargs['table'] = table
        try:
            result = self._ws.database.create_database_table(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_create_synced_database_table(self, synced_table: Dict[str, Any]) -> DatabricksResponse:
        """Create a Synced Database Table."""
        kwargs: Dict[str, Any] = {}
        kwargs['synced_table'] = synced_table
        try:
            result = self._ws.database.create_synced_database_table(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_delete_database_catalog(self, name: str) -> DatabricksResponse:
        """Delete a Database Catalog."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.database.delete_database_catalog(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_delete_database_instance(
        self,
        name: str,
        force: Optional[bool] = None,
        purge: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Delete a Database Instance."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if force is not None:
            kwargs['force'] = force
        if purge is not None:
            kwargs['purge'] = purge
        try:
            result = self._ws.database.delete_database_instance(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_delete_database_instance_role(
        self,
        instance_name: str,
        name: str,
        allow_missing: Optional[bool] = None,
        reassign_owned_to: Optional[str] = None,
    ) -> DatabricksResponse:
        """Deletes a role for a Database Instance."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_name'] = instance_name
        kwargs['name'] = name
        if allow_missing is not None:
            kwargs['allow_missing'] = allow_missing
        if reassign_owned_to is not None:
            kwargs['reassign_owned_to'] = reassign_owned_to
        try:
            result = self._ws.database.delete_database_instance_role(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_delete_database_table(self, name: str) -> DatabricksResponse:
        """Delete a Database Table."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.database.delete_database_table(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_delete_synced_database_table(self, name: str, purge_data: Optional[bool] = None) -> DatabricksResponse:
        """Delete a Synced Database Table."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if purge_data is not None:
            kwargs['purge_data'] = purge_data
        try:
            result = self._ws.database.delete_synced_database_table(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_find_database_instance_by_uid(self, uid: Optional[str] = None) -> DatabricksResponse:
        """Find a Database Instance by uid."""
        kwargs: Dict[str, Any] = {}
        if uid is not None:
            kwargs['uid'] = uid
        try:
            result = self._ws.database.find_database_instance_by_uid(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_generate_database_credential(
        self,
        claims: Optional[List[Dict[str, Any]]] = None,
        instance_names: Optional[List[str]] = None,
        request_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Generates a credential that can be used to access database instances."""
        kwargs: Dict[str, Any] = {}
        if claims is not None:
            kwargs['claims'] = claims
        if instance_names is not None:
            kwargs['instance_names'] = instance_names
        if request_id is not None:
            kwargs['request_id'] = request_id
        try:
            result = self._ws.database.generate_database_credential(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_get_database_catalog(self, name: str) -> DatabricksResponse:
        """Get a Database Catalog."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.database.get_database_catalog(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_get_database_instance(self, name: str) -> DatabricksResponse:
        """Get a Database Instance."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.database.get_database_instance(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_get_database_instance_role(self, instance_name: str, name: str) -> DatabricksResponse:
        """Gets a role for a Database Instance."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_name'] = instance_name
        kwargs['name'] = name
        try:
            result = self._ws.database.get_database_instance_role(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_get_database_table(self, name: str) -> DatabricksResponse:
        """Get a Database Table."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.database.get_database_table(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_get_synced_database_table(self, name: str) -> DatabricksResponse:
        """Get a Synced Database Table."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.database.get_synced_database_table(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_list_database_catalogs(
        self,
        instance_name: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """This API is currently unimplemented, but exposed for Terraform support."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_name'] = instance_name
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.database.list_database_catalogs(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_list_database_instance_roles(
        self,
        instance_name: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """START OF PG ROLE APIs Section These APIs are marked a PUBLIC with stage < PUBLIC_PREVIEW. With more recent Lakebase V2 plans, we don't plan to ever advance these to PUBLIC_PREVIEW. These APIs will ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_name'] = instance_name
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.database.list_database_instance_roles(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_list_database_instances(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """List Database Instances."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.database.list_database_instances(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_list_synced_database_tables(
        self,
        instance_name: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """This API is currently unimplemented, but exposed for Terraform support."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_name'] = instance_name
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.database.list_synced_database_tables(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_update_database_catalog(
        self,
        name: str,
        database_catalog: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """This API is currently unimplemented, but exposed for Terraform support."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['database_catalog'] = database_catalog
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.database.update_database_catalog(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_update_database_instance(
        self,
        name: str,
        database_instance: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Update a Database Instance."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['database_instance'] = database_instance
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.database.update_database_instance(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def database_update_synced_database_table(
        self,
        name: str,
        synced_table: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """This API is currently unimplemented, but exposed for Terraform support."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['synced_table'] = synced_table
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.database.update_synced_database_table(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # DBFS (DbfsExt) — 16 methods
    # ============================================================================

    async def dbfs_add_block(self, handle: int, data: str) -> DatabricksResponse:
        """Appends a block of data to the stream specified by the input handle. If the handle does not exist, this call will throw an exception with ``RESOURCE_DOES_NOT_EXIST``."""
        kwargs: Dict[str, Any] = {}
        kwargs['handle'] = handle
        kwargs['data'] = data
        try:
            result = self._ws.dbfs.add_block(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_close(self, handle: int) -> DatabricksResponse:
        """Closes the stream specified by the input handle. If the handle does not exist, this call throws an exception with ``RESOURCE_DOES_NOT_EXIST``."""
        kwargs: Dict[str, Any] = {}
        kwargs['handle'] = handle
        try:
            result = self._ws.dbfs.close(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_copy(
        self,
        src: str,
        dst: str,
        recursive: Optional[Any] = False,
        overwrite: Optional[Any] = False,
    ) -> DatabricksResponse:
        """Copy files between DBFS and local filesystems"""
        kwargs: Dict[str, Any] = {}
        kwargs['src'] = src
        kwargs['dst'] = dst
        if recursive is not None:
            kwargs['recursive'] = recursive
        if overwrite is not None:
            kwargs['overwrite'] = overwrite
        try:
            result = self._ws.dbfs.copy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_create(self, path: str, overwrite: Optional[bool] = None) -> DatabricksResponse:
        """Opens a stream to write to a file and returns a handle to this stream. There is a 10 minute idle timeout on this handle. If a file or directory already exists on the given path and __overwrite__ is..."""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        if overwrite is not None:
            kwargs['overwrite'] = overwrite
        try:
            result = self._ws.dbfs.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_delete(self, path: str, recursive: Optional[Any] = False) -> DatabricksResponse:
        """Delete file or directory on DBFS"""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        if recursive is not None:
            kwargs['recursive'] = recursive
        try:
            result = self._ws.dbfs.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_download(self, path: str) -> DatabricksResponse:
        """Download file from DBFS"""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        try:
            result = self._ws.dbfs.download(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_exists(self, path: str) -> DatabricksResponse:
        """If file exists on DBFS"""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        try:
            result = self._ws.dbfs.exists(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_get_status(self, path: str) -> DatabricksResponse:
        """Gets the file information for a file or directory. If the file or directory does not exist, this call throws an exception with `RESOURCE_DOES_NOT_EXIST`."""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        try:
            result = self._ws.dbfs.get_status(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_list(self, path: str, recursive: Optional[Any] = False) -> DatabricksResponse:
        """List directory contents or file details."""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        if recursive is not None:
            kwargs['recursive'] = recursive
        try:
            result = list(self._ws.dbfs.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_mkdirs(self, path: str) -> DatabricksResponse:
        """Create directory on DBFS"""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        try:
            result = self._ws.dbfs.mkdirs(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_move(self, source_path: str, destination_path: str) -> DatabricksResponse:
        """Moves a file from one location to another location within DBFS. If the source file does not exist, this call throws an exception with `RESOURCE_DOES_NOT_EXIST`. If a file already exists in the dest..."""
        kwargs: Dict[str, Any] = {}
        kwargs['source_path'] = source_path
        kwargs['destination_path'] = destination_path
        try:
            result = self._ws.dbfs.move(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_move_(
        self,
        src: str,
        dst: str,
        recursive: Optional[Any] = False,
        overwrite: Optional[Any] = False,
    ) -> DatabricksResponse:
        """Move files between local and DBFS systems"""
        kwargs: Dict[str, Any] = {}
        kwargs['src'] = src
        kwargs['dst'] = dst
        if recursive is not None:
            kwargs['recursive'] = recursive
        if overwrite is not None:
            kwargs['overwrite'] = overwrite
        try:
            result = self._ws.dbfs.move_(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_open(
        self,
        path: str,
        read: Optional[bool] = False,
        write: Optional[bool] = False,
        overwrite: Optional[bool] = False,
    ) -> DatabricksResponse:
        """dbfs.open"""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        if read is not None:
            kwargs['read'] = read
        if write is not None:
            kwargs['write'] = write
        if overwrite is not None:
            kwargs['overwrite'] = overwrite
        try:
            result = self._ws.dbfs.open(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_put(
        self,
        path: str,
        contents: Optional[str] = None,
        overwrite: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Uploads a file through the use of multipart form post. It is mainly used for streaming uploads, but can also be used as a convenient single call for data upload."""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        if contents is not None:
            kwargs['contents'] = contents
        if overwrite is not None:
            kwargs['overwrite'] = overwrite
        try:
            result = self._ws.dbfs.put(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_read(
        self,
        path: str,
        length: Optional[int] = None,
        offset: Optional[int] = None,
    ) -> DatabricksResponse:
        """Returns the contents of a file. If the file does not exist, this call throws an exception with `RESOURCE_DOES_NOT_EXIST`. If the path is a directory, the read length is negative, or if the offset i..."""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        if length is not None:
            kwargs['length'] = length
        if offset is not None:
            kwargs['offset'] = offset
        try:
            result = self._ws.dbfs.read(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbfs_upload(
        self,
        path: str,
        src: bytes,
        overwrite: Optional[bool] = False,
    ) -> DatabricksResponse:
        """Upload file to DBFS"""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        kwargs['src'] = src
        if overwrite is not None:
            kwargs['overwrite'] = overwrite
        try:
            result = self._ws.dbfs.upload(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # DBSQL PERMISSIONS (DbsqlPermissionsAPI) — 3 methods
    # ============================================================================

    async def dbsql_permissions_get(self, object_type: Dict[str, Any], object_id: str) -> DatabricksResponse:
        """Gets a JSON representation of the access control list (ACL) for a specified object."""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        try:
            result = self._ws.dbsql_permissions.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbsql_permissions_set(
        self,
        object_type: Dict[str, Any],
        object_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets the access control list (ACL) for a specified object. This operation will complete rewrite the ACL."""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.dbsql_permissions.set(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def dbsql_permissions_transfer_ownership(
        self,
        object_type: Dict[str, Any],
        object_id: Dict[str, Any],
        new_owner: Optional[str] = None,
    ) -> DatabricksResponse:
        """Transfers ownership of a dashboard, query, or alert to an active user. Requires an admin API key."""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        if new_owner is not None:
            kwargs['new_owner'] = new_owner
        try:
            result = self._ws.dbsql_permissions.transfer_ownership(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # ENTITY TAG ASSIGNMENTS (EntityTagAssignmentsAPI) — 5 methods
    # ============================================================================

    async def entity_tag_assignments_create(self, tag_assignment: Dict[str, Any]) -> DatabricksResponse:
        """Creates a tag assignment for an Unity Catalog entity."""
        kwargs: Dict[str, Any] = {}
        kwargs['tag_assignment'] = tag_assignment
        try:
            result = self._ws.entity_tag_assignments.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def entity_tag_assignments_delete(
        self,
        entity_type: str,
        entity_name: str,
        tag_key: str,
    ) -> DatabricksResponse:
        """Deletes a tag assignment for an Unity Catalog entity by its key."""
        kwargs: Dict[str, Any] = {}
        kwargs['entity_type'] = entity_type
        kwargs['entity_name'] = entity_name
        kwargs['tag_key'] = tag_key
        try:
            result = self._ws.entity_tag_assignments.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def entity_tag_assignments_get(
        self,
        entity_type: str,
        entity_name: str,
        tag_key: str,
    ) -> DatabricksResponse:
        """Gets a tag assignment for an Unity Catalog entity by tag key."""
        kwargs: Dict[str, Any] = {}
        kwargs['entity_type'] = entity_type
        kwargs['entity_name'] = entity_name
        kwargs['tag_key'] = tag_key
        try:
            result = self._ws.entity_tag_assignments.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def entity_tag_assignments_list(
        self,
        entity_type: str,
        entity_name: str,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List tag assignments for an Unity Catalog entity"""
        kwargs: Dict[str, Any] = {}
        kwargs['entity_type'] = entity_type
        kwargs['entity_name'] = entity_name
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.entity_tag_assignments.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def entity_tag_assignments_update(
        self,
        entity_type: str,
        entity_name: str,
        tag_key: str,
        tag_assignment: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Updates an existing tag assignment for an Unity Catalog entity."""
        kwargs: Dict[str, Any] = {}
        kwargs['entity_type'] = entity_type
        kwargs['entity_name'] = entity_name
        kwargs['tag_key'] = tag_key
        kwargs['tag_assignment'] = tag_assignment
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.entity_tag_assignments.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # EXPERIMENTS (ExperimentsAPI) — 39 methods
    # ============================================================================

    async def experiments_create_experiment(
        self,
        name: str,
        artifact_location: Optional[str] = None,
        tags: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Creates an experiment with a name. Returns the ID of the newly created experiment. Validates that another experiment with the same name does not already exist and fails if another experiment with t..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if artifact_location is not None:
            kwargs['artifact_location'] = artifact_location
        if tags is not None:
            kwargs['tags'] = tags
        try:
            result = self._ws.experiments.create_experiment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_create_logged_model(
        self,
        experiment_id: str,
        model_type: Optional[str] = None,
        name: Optional[str] = None,
        params: Optional[List[Dict[str, Any]]] = None,
        source_run_id: Optional[str] = None,
        tags: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Create a logged model."""
        kwargs: Dict[str, Any] = {}
        kwargs['experiment_id'] = experiment_id
        if model_type is not None:
            kwargs['model_type'] = model_type
        if name is not None:
            kwargs['name'] = name
        if params is not None:
            kwargs['params'] = params
        if source_run_id is not None:
            kwargs['source_run_id'] = source_run_id
        if tags is not None:
            kwargs['tags'] = tags
        try:
            result = self._ws.experiments.create_logged_model(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_create_run(
        self,
        experiment_id: Optional[str] = None,
        run_name: Optional[str] = None,
        start_time: Optional[int] = None,
        tags: Optional[List[Dict[str, Any]]] = None,
        user_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new run within an experiment. A run is usually a single execution of a machine learning or data ETL pipeline. MLflow uses runs to track the `mlflowParam`, `mlflowMetric`, and `mlflowRunTa..."""
        kwargs: Dict[str, Any] = {}
        if experiment_id is not None:
            kwargs['experiment_id'] = experiment_id
        if run_name is not None:
            kwargs['run_name'] = run_name
        if start_time is not None:
            kwargs['start_time'] = start_time
        if tags is not None:
            kwargs['tags'] = tags
        if user_id is not None:
            kwargs['user_id'] = user_id
        try:
            result = self._ws.experiments.create_run(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_delete_experiment(self, experiment_id: str) -> DatabricksResponse:
        """Marks an experiment and associated metadata, runs, metrics, params, and tags for deletion. If the experiment uses FileStore, artifacts associated with the experiment are also deleted."""
        kwargs: Dict[str, Any] = {}
        kwargs['experiment_id'] = experiment_id
        try:
            result = self._ws.experiments.delete_experiment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_delete_logged_model(self, model_id: str) -> DatabricksResponse:
        """Delete a logged model."""
        kwargs: Dict[str, Any] = {}
        kwargs['model_id'] = model_id
        try:
            result = self._ws.experiments.delete_logged_model(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_delete_logged_model_tag(self, model_id: str, tag_key: str) -> DatabricksResponse:
        """Delete a tag on a logged model."""
        kwargs: Dict[str, Any] = {}
        kwargs['model_id'] = model_id
        kwargs['tag_key'] = tag_key
        try:
            result = self._ws.experiments.delete_logged_model_tag(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_delete_run(self, run_id: str) -> DatabricksResponse:
        """Marks a run for deletion."""
        kwargs: Dict[str, Any] = {}
        kwargs['run_id'] = run_id
        try:
            result = self._ws.experiments.delete_run(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_delete_runs(
        self,
        experiment_id: str,
        max_timestamp_millis: int,
        max_runs: Optional[int] = None,
    ) -> DatabricksResponse:
        """Bulk delete runs in an experiment that were created prior to or at the specified timestamp. Deletes at most max_runs per request. To call this API from a Databricks Notebook in Python, you can use ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['experiment_id'] = experiment_id
        kwargs['max_timestamp_millis'] = max_timestamp_millis
        if max_runs is not None:
            kwargs['max_runs'] = max_runs
        try:
            result = self._ws.experiments.delete_runs(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_delete_tag(self, run_id: str, key: str) -> DatabricksResponse:
        """Deletes a tag on a run. Tags are run metadata that can be updated during a run and after a run completes."""
        kwargs: Dict[str, Any] = {}
        kwargs['run_id'] = run_id
        kwargs['key'] = key
        try:
            result = self._ws.experiments.delete_tag(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_finalize_logged_model(self, model_id: str, status: Dict[str, Any]) -> DatabricksResponse:
        """Finalize a logged model."""
        kwargs: Dict[str, Any] = {}
        kwargs['model_id'] = model_id
        kwargs['status'] = status
        try:
            result = self._ws.experiments.finalize_logged_model(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_get_by_name(self, experiment_name: str) -> DatabricksResponse:
        """Gets metadata for an experiment."""
        kwargs: Dict[str, Any] = {}
        kwargs['experiment_name'] = experiment_name
        try:
            result = self._ws.experiments.get_by_name(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_get_experiment(self, experiment_id: str) -> DatabricksResponse:
        """Gets metadata for an experiment. This method works on deleted experiments."""
        kwargs: Dict[str, Any] = {}
        kwargs['experiment_id'] = experiment_id
        try:
            result = self._ws.experiments.get_experiment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_get_history(
        self,
        metric_key: str,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
        run_id: Optional[str] = None,
        run_uuid: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets a list of all values for the specified metric for a given run."""
        kwargs: Dict[str, Any] = {}
        kwargs['metric_key'] = metric_key
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        if run_id is not None:
            kwargs['run_id'] = run_id
        if run_uuid is not None:
            kwargs['run_uuid'] = run_uuid
        try:
            result = list(self._ws.experiments.get_history(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_get_logged_model(self, model_id: str) -> DatabricksResponse:
        """Get a logged model."""
        kwargs: Dict[str, Any] = {}
        kwargs['model_id'] = model_id
        try:
            result = self._ws.experiments.get_logged_model(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_get_permission_levels(self, experiment_id: str) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        kwargs['experiment_id'] = experiment_id
        try:
            result = self._ws.experiments.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_get_permissions(self, experiment_id: str) -> DatabricksResponse:
        """Gets the permissions of an experiment. Experiments can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['experiment_id'] = experiment_id
        try:
            result = self._ws.experiments.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_get_run(self, run_id: str, run_uuid: Optional[str] = None) -> DatabricksResponse:
        """Gets the metadata, metrics, params, and tags for a run. In the case where multiple metrics with the same key are logged for a run, return only the value with the latest timestamp."""
        kwargs: Dict[str, Any] = {}
        kwargs['run_id'] = run_id
        if run_uuid is not None:
            kwargs['run_uuid'] = run_uuid
        try:
            result = self._ws.experiments.get_run(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_list_artifacts(
        self,
        page_token: Optional[str] = None,
        path: Optional[str] = None,
        run_id: Optional[str] = None,
        run_uuid: Optional[str] = None,
    ) -> DatabricksResponse:
        """List artifacts for a run. Takes an optional `artifact_path` prefix which if specified, the response contains only artifacts with the specified prefix. A maximum of 1000 artifacts will be retrieved ..."""
        kwargs: Dict[str, Any] = {}
        if page_token is not None:
            kwargs['page_token'] = page_token
        if path is not None:
            kwargs['path'] = path
        if run_id is not None:
            kwargs['run_id'] = run_id
        if run_uuid is not None:
            kwargs['run_uuid'] = run_uuid
        try:
            result = list(self._ws.experiments.list_artifacts(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_list_experiments(
        self,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
        view_type: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Gets a list of all experiments."""
        kwargs: Dict[str, Any] = {}
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        if view_type is not None:
            kwargs['view_type'] = view_type
        try:
            result = list(self._ws.experiments.list_experiments(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_log_batch(
        self,
        metrics: Optional[List[Dict[str, Any]]] = None,
        params: Optional[List[Dict[str, Any]]] = None,
        run_id: Optional[str] = None,
        tags: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Logs a batch of metrics, params, and tags for a run. If any data failed to be persisted, the server will respond with an error (non-200 status code)."""
        kwargs: Dict[str, Any] = {}
        if metrics is not None:
            kwargs['metrics'] = metrics
        if params is not None:
            kwargs['params'] = params
        if run_id is not None:
            kwargs['run_id'] = run_id
        if tags is not None:
            kwargs['tags'] = tags
        try:
            result = self._ws.experiments.log_batch(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_log_inputs(
        self,
        run_id: str,
        datasets: Optional[List[Dict[str, Any]]] = None,
        models: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Logs inputs, such as datasets and models, to an MLflow Run."""
        kwargs: Dict[str, Any] = {}
        kwargs['run_id'] = run_id
        if datasets is not None:
            kwargs['datasets'] = datasets
        if models is not None:
            kwargs['models'] = models
        try:
            result = self._ws.experiments.log_inputs(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_log_logged_model_params(
        self,
        model_id: str,
        params: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Logs params for a logged model. A param is a key-value pair (string key, string value). Examples include hyperparameters used for ML model training. A param can be logged only once for a logged mod..."""
        kwargs: Dict[str, Any] = {}
        kwargs['model_id'] = model_id
        if params is not None:
            kwargs['params'] = params
        try:
            result = self._ws.experiments.log_logged_model_params(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_log_metric(
        self,
        key: str,
        value: float,
        timestamp: int,
        dataset_digest: Optional[str] = None,
        dataset_name: Optional[str] = None,
        model_id: Optional[str] = None,
        run_id: Optional[str] = None,
        run_uuid: Optional[str] = None,
        step: Optional[int] = None,
    ) -> DatabricksResponse:
        """Log a metric for a run. A metric is a key-value pair (string key, float value) with an associated timestamp. Examples include the various metrics that represent ML model accuracy. A metric can be l..."""
        kwargs: Dict[str, Any] = {}
        kwargs['key'] = key
        kwargs['value'] = value
        kwargs['timestamp'] = timestamp
        if dataset_digest is not None:
            kwargs['dataset_digest'] = dataset_digest
        if dataset_name is not None:
            kwargs['dataset_name'] = dataset_name
        if model_id is not None:
            kwargs['model_id'] = model_id
        if run_id is not None:
            kwargs['run_id'] = run_id
        if run_uuid is not None:
            kwargs['run_uuid'] = run_uuid
        if step is not None:
            kwargs['step'] = step
        try:
            result = self._ws.experiments.log_metric(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_log_model(self, model_json: Optional[str] = None, run_id: Optional[str] = None) -> DatabricksResponse:
        """**Note:** the [Create a logged model](/api/workspace/experiments/createloggedmodel) API replaces this endpoint."""
        kwargs: Dict[str, Any] = {}
        if model_json is not None:
            kwargs['model_json'] = model_json
        if run_id is not None:
            kwargs['run_id'] = run_id
        try:
            result = self._ws.experiments.log_model(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_log_outputs(
        self,
        run_id: str,
        models: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Logs outputs, such as models, from an MLflow Run."""
        kwargs: Dict[str, Any] = {}
        kwargs['run_id'] = run_id
        if models is not None:
            kwargs['models'] = models
        try:
            result = self._ws.experiments.log_outputs(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_log_param(
        self,
        key: str,
        value: str,
        run_id: Optional[str] = None,
        run_uuid: Optional[str] = None,
    ) -> DatabricksResponse:
        """Logs a param used for a run. A param is a key-value pair (string key, string value). Examples include hyperparameters used for ML model training and constant dates and values used in an ETL pipelin..."""
        kwargs: Dict[str, Any] = {}
        kwargs['key'] = key
        kwargs['value'] = value
        if run_id is not None:
            kwargs['run_id'] = run_id
        if run_uuid is not None:
            kwargs['run_uuid'] = run_uuid
        try:
            result = self._ws.experiments.log_param(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_restore_experiment(self, experiment_id: str) -> DatabricksResponse:
        """Restore an experiment marked for deletion. This also restores associated metadata, runs, metrics, params, and tags. If experiment uses FileStore, underlying artifacts associated with experiment are..."""
        kwargs: Dict[str, Any] = {}
        kwargs['experiment_id'] = experiment_id
        try:
            result = self._ws.experiments.restore_experiment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_restore_run(self, run_id: str) -> DatabricksResponse:
        """Restores a deleted run. This also restores associated metadata, runs, metrics, params, and tags."""
        kwargs: Dict[str, Any] = {}
        kwargs['run_id'] = run_id
        try:
            result = self._ws.experiments.restore_run(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_restore_runs(
        self,
        experiment_id: str,
        min_timestamp_millis: int,
        max_runs: Optional[int] = None,
    ) -> DatabricksResponse:
        """Bulk restore runs in an experiment that were deleted no earlier than the specified timestamp. Restores at most max_runs per request. To call this API from a Databricks Notebook in Python, you can u..."""
        kwargs: Dict[str, Any] = {}
        kwargs['experiment_id'] = experiment_id
        kwargs['min_timestamp_millis'] = min_timestamp_millis
        if max_runs is not None:
            kwargs['max_runs'] = max_runs
        try:
            result = self._ws.experiments.restore_runs(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_search_experiments(
        self,
        filter: Optional[str] = None,
        max_results: Optional[int] = None,
        order_by: Optional[List[str]] = None,
        page_token: Optional[str] = None,
        view_type: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Searches for experiments that satisfy specified search criteria."""
        kwargs: Dict[str, Any] = {}
        if filter is not None:
            kwargs['filter'] = filter
        if max_results is not None:
            kwargs['max_results'] = max_results
        if order_by is not None:
            kwargs['order_by'] = order_by
        if page_token is not None:
            kwargs['page_token'] = page_token
        if view_type is not None:
            kwargs['view_type'] = view_type
        try:
            result = list(self._ws.experiments.search_experiments(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_search_logged_models(
        self,
        datasets: Optional[List[Dict[str, Any]]] = None,
        experiment_ids: Optional[List[str]] = None,
        filter: Optional[str] = None,
        max_results: Optional[int] = None,
        order_by: Optional[List[Dict[str, Any]]] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Search for Logged Models that satisfy specified search criteria."""
        kwargs: Dict[str, Any] = {}
        if datasets is not None:
            kwargs['datasets'] = datasets
        if experiment_ids is not None:
            kwargs['experiment_ids'] = experiment_ids
        if filter is not None:
            kwargs['filter'] = filter
        if max_results is not None:
            kwargs['max_results'] = max_results
        if order_by is not None:
            kwargs['order_by'] = order_by
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = self._ws.experiments.search_logged_models(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_search_runs(
        self,
        experiment_ids: Optional[List[str]] = None,
        filter: Optional[str] = None,
        max_results: Optional[int] = None,
        order_by: Optional[List[str]] = None,
        page_token: Optional[str] = None,
        run_view_type: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Searches for runs that satisfy expressions."""
        kwargs: Dict[str, Any] = {}
        if experiment_ids is not None:
            kwargs['experiment_ids'] = experiment_ids
        if filter is not None:
            kwargs['filter'] = filter
        if max_results is not None:
            kwargs['max_results'] = max_results
        if order_by is not None:
            kwargs['order_by'] = order_by
        if page_token is not None:
            kwargs['page_token'] = page_token
        if run_view_type is not None:
            kwargs['run_view_type'] = run_view_type
        try:
            result = list(self._ws.experiments.search_runs(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_set_experiment_tag(
        self,
        experiment_id: str,
        key: str,
        value: str,
    ) -> DatabricksResponse:
        """Sets a tag on an experiment. Experiment tags are metadata that can be updated."""
        kwargs: Dict[str, Any] = {}
        kwargs['experiment_id'] = experiment_id
        kwargs['key'] = key
        kwargs['value'] = value
        try:
            result = self._ws.experiments.set_experiment_tag(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_set_logged_model_tags(
        self,
        model_id: str,
        tags: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Set tags for a logged model."""
        kwargs: Dict[str, Any] = {}
        kwargs['model_id'] = model_id
        if tags is not None:
            kwargs['tags'] = tags
        try:
            result = self._ws.experiments.set_logged_model_tags(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_set_permissions(
        self,
        experiment_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['experiment_id'] = experiment_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.experiments.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_set_tag(
        self,
        key: str,
        value: str,
        run_id: Optional[str] = None,
        run_uuid: Optional[str] = None,
    ) -> DatabricksResponse:
        """Sets a tag on a run. Tags are run metadata that can be updated during a run and after a run completes."""
        kwargs: Dict[str, Any] = {}
        kwargs['key'] = key
        kwargs['value'] = value
        if run_id is not None:
            kwargs['run_id'] = run_id
        if run_uuid is not None:
            kwargs['run_uuid'] = run_uuid
        try:
            result = self._ws.experiments.set_tag(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_update_experiment(self, experiment_id: str, new_name: Optional[str] = None) -> DatabricksResponse:
        """Updates experiment metadata."""
        kwargs: Dict[str, Any] = {}
        kwargs['experiment_id'] = experiment_id
        if new_name is not None:
            kwargs['new_name'] = new_name
        try:
            result = self._ws.experiments.update_experiment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_update_permissions(
        self,
        experiment_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on an experiment. Experiments can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['experiment_id'] = experiment_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.experiments.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def experiments_update_run(
        self,
        end_time: Optional[int] = None,
        run_id: Optional[str] = None,
        run_name: Optional[str] = None,
        run_uuid: Optional[str] = None,
        status: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Updates run metadata."""
        kwargs: Dict[str, Any] = {}
        if end_time is not None:
            kwargs['end_time'] = end_time
        if run_id is not None:
            kwargs['run_id'] = run_id
        if run_name is not None:
            kwargs['run_name'] = run_name
        if run_uuid is not None:
            kwargs['run_uuid'] = run_uuid
        if status is not None:
            kwargs['status'] = status
        try:
            result = self._ws.experiments.update_run(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # EXTERNAL LINEAGE (ExternalLineageAPI) — 4 methods
    # ============================================================================

    async def external_lineage_create_external_lineage_relationship(
        self,
        external_lineage_relationship: Dict[str, Any],
    ) -> DatabricksResponse:
        """Creates an external lineage relationship between a Databricks or external metadata object and another external metadata object."""
        kwargs: Dict[str, Any] = {}
        kwargs['external_lineage_relationship'] = external_lineage_relationship
        try:
            result = self._ws.external_lineage.create_external_lineage_relationship(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def external_lineage_delete_external_lineage_relationship(
        self,
        external_lineage_relationship: Dict[str, Any],
    ) -> DatabricksResponse:
        """Deletes an external lineage relationship between a Databricks or external metadata object and another external metadata object."""
        kwargs: Dict[str, Any] = {}
        kwargs['external_lineage_relationship'] = external_lineage_relationship
        try:
            result = self._ws.external_lineage.delete_external_lineage_relationship(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def external_lineage_list_external_lineage_relationships(
        self,
        object_info: Dict[str, Any],
        lineage_direction: Dict[str, Any],
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Lists external lineage relationships of a Databricks object or external metadata given a supplied direction."""
        kwargs: Dict[str, Any] = {}
        kwargs['object_info'] = object_info
        kwargs['lineage_direction'] = lineage_direction
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.external_lineage.list_external_lineage_relationships(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def external_lineage_update_external_lineage_relationship(
        self,
        external_lineage_relationship: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Updates an external lineage relationship between a Databricks or external metadata object and another external metadata object."""
        kwargs: Dict[str, Any] = {}
        kwargs['external_lineage_relationship'] = external_lineage_relationship
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.external_lineage.update_external_lineage_relationship(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # EXTERNAL LOCATIONS (ExternalLocationsAPI) — 5 methods
    # ============================================================================

    async def external_locations_create(
        self,
        name: str,
        url: str,
        credential_name: str,
        comment: Optional[str] = None,
        enable_file_events: Optional[bool] = None,
        encryption_details: Optional[Dict[str, Any]] = None,
        fallback: Optional[bool] = None,
        file_event_queue: Optional[Dict[str, Any]] = None,
        read_only: Optional[bool] = None,
        skip_validation: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Creates a new external location entry in the metastore. The caller must be a metastore admin or have the **CREATE_EXTERNAL_LOCATION** privilege on both the metastore and the associated storage cred..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['url'] = url
        kwargs['credential_name'] = credential_name
        if comment is not None:
            kwargs['comment'] = comment
        if enable_file_events is not None:
            kwargs['enable_file_events'] = enable_file_events
        if encryption_details is not None:
            kwargs['encryption_details'] = encryption_details
        if fallback is not None:
            kwargs['fallback'] = fallback
        if file_event_queue is not None:
            kwargs['file_event_queue'] = file_event_queue
        if read_only is not None:
            kwargs['read_only'] = read_only
        if skip_validation is not None:
            kwargs['skip_validation'] = skip_validation
        try:
            result = self._ws.external_locations.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def external_locations_delete(self, name: str, force: Optional[bool] = None) -> DatabricksResponse:
        """Deletes the specified external location from the metastore. The caller must be the owner of the external location."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if force is not None:
            kwargs['force'] = force
        try:
            result = self._ws.external_locations.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def external_locations_get(self, name: str, include_browse: Optional[bool] = None) -> DatabricksResponse:
        """Gets an external location from the metastore. The caller must be either a metastore admin, the owner of the external location, or a user that has some privilege on the external location."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        try:
            result = self._ws.external_locations.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def external_locations_list(
        self,
        include_browse: Optional[bool] = None,
        include_unbound: Optional[bool] = None,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets an array of external locations (__ExternalLocationInfo__ objects) from the metastore. The caller must be a metastore admin, the owner of the external location, or a user that has some privileg..."""
        kwargs: Dict[str, Any] = {}
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        if include_unbound is not None:
            kwargs['include_unbound'] = include_unbound
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.external_locations.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def external_locations_update(
        self,
        name: str,
        comment: Optional[str] = None,
        credential_name: Optional[str] = None,
        enable_file_events: Optional[bool] = None,
        encryption_details: Optional[Dict[str, Any]] = None,
        fallback: Optional[bool] = None,
        file_event_queue: Optional[Dict[str, Any]] = None,
        force: Optional[bool] = None,
        isolation_mode: Optional[Dict[str, Any]] = None,
        new_name: Optional[str] = None,
        owner: Optional[str] = None,
        read_only: Optional[bool] = None,
        skip_validation: Optional[bool] = None,
        url: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates an external location in the metastore. The caller must be the owner of the external location, or be a metastore admin. In the second case, the admin can only update the name of the external..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if comment is not None:
            kwargs['comment'] = comment
        if credential_name is not None:
            kwargs['credential_name'] = credential_name
        if enable_file_events is not None:
            kwargs['enable_file_events'] = enable_file_events
        if encryption_details is not None:
            kwargs['encryption_details'] = encryption_details
        if fallback is not None:
            kwargs['fallback'] = fallback
        if file_event_queue is not None:
            kwargs['file_event_queue'] = file_event_queue
        if force is not None:
            kwargs['force'] = force
        if isolation_mode is not None:
            kwargs['isolation_mode'] = isolation_mode
        if new_name is not None:
            kwargs['new_name'] = new_name
        if owner is not None:
            kwargs['owner'] = owner
        if read_only is not None:
            kwargs['read_only'] = read_only
        if skip_validation is not None:
            kwargs['skip_validation'] = skip_validation
        if url is not None:
            kwargs['url'] = url
        try:
            result = self._ws.external_locations.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # EXTERNAL METADATA (ExternalMetadataAPI) — 5 methods
    # ============================================================================

    async def external_metadata_create_external_metadata(self, external_metadata: Dict[str, Any]) -> DatabricksResponse:
        """Creates a new external metadata object in the parent metastore if the caller is a metastore admin or has the **CREATE_EXTERNAL_METADATA** privilege. Grants **BROWSE** to all account users upon crea..."""
        kwargs: Dict[str, Any] = {}
        kwargs['external_metadata'] = external_metadata
        try:
            result = self._ws.external_metadata.create_external_metadata(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def external_metadata_delete_external_metadata(self, name: str) -> DatabricksResponse:
        """Deletes the external metadata object that matches the supplied name. The caller must be a metastore admin, the owner of the external metadata object, or a user that has the **MANAGE** privilege."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.external_metadata.delete_external_metadata(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def external_metadata_get_external_metadata(self, name: str) -> DatabricksResponse:
        """Gets the specified external metadata object in a metastore. The caller must be a metastore admin, the owner of the external metadata object, or a user that has the **BROWSE** privilege."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.external_metadata.get_external_metadata(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def external_metadata_list_external_metadata(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Gets an array of external metadata objects in the metastore. If the caller is the metastore admin, all external metadata objects will be retrieved. Otherwise, only external metadata objects that th..."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.external_metadata.list_external_metadata(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def external_metadata_update_external_metadata(
        self,
        name: str,
        external_metadata: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Updates the external metadata object that matches the supplied name. The caller can only update either the owner or other metadata fields in one request. The caller must be a metastore admin, the o..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['external_metadata'] = external_metadata
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.external_metadata.update_external_metadata(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # FEATURE ENGINEERING (FeatureEngineeringAPI) — 16 methods
    # ============================================================================

    async def feature_engineering_batch_create_materialized_features(self, requests: List[Dict[str, Any]]) -> DatabricksResponse:
        """Batch create materialized features."""
        kwargs: Dict[str, Any] = {}
        kwargs['requests'] = requests
        try:
            result = self._ws.feature_engineering.batch_create_materialized_features(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_create_feature(self, feature: Dict[str, Any]) -> DatabricksResponse:
        """Create a Feature."""
        kwargs: Dict[str, Any] = {}
        kwargs['feature'] = feature
        try:
            result = self._ws.feature_engineering.create_feature(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_create_kafka_config(self, kafka_config: Dict[str, Any]) -> DatabricksResponse:
        """Create a Kafka config. During PrPr, Kafka configs can be read and used when creating features under the entire metastore. Only the creator of the Kafka config can delete it."""
        kwargs: Dict[str, Any] = {}
        kwargs['kafka_config'] = kafka_config
        try:
            result = self._ws.feature_engineering.create_kafka_config(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_create_materialized_feature(self, materialized_feature: Dict[str, Any]) -> DatabricksResponse:
        """Create a materialized feature."""
        kwargs: Dict[str, Any] = {}
        kwargs['materialized_feature'] = materialized_feature
        try:
            result = self._ws.feature_engineering.create_materialized_feature(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_delete_feature(self, full_name: str) -> DatabricksResponse:
        """Delete a Feature."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        try:
            result = self._ws.feature_engineering.delete_feature(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_delete_kafka_config(self, name: str) -> DatabricksResponse:
        """Delete a Kafka config. During PrPr, Kafka configs can be read and used when creating features under the entire metastore. Only the creator of the Kafka config can delete it."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.feature_engineering.delete_kafka_config(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_delete_materialized_feature(self, materialized_feature_id: str) -> DatabricksResponse:
        """Delete a materialized feature."""
        kwargs: Dict[str, Any] = {}
        kwargs['materialized_feature_id'] = materialized_feature_id
        try:
            result = self._ws.feature_engineering.delete_materialized_feature(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_get_feature(self, full_name: str) -> DatabricksResponse:
        """Get a Feature."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        try:
            result = self._ws.feature_engineering.get_feature(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_get_kafka_config(self, name: str) -> DatabricksResponse:
        """Get a Kafka config. During PrPr, Kafka configs can be read and used when creating features under the entire metastore. Only the creator of the Kafka config can delete it."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.feature_engineering.get_kafka_config(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_get_materialized_feature(self, materialized_feature_id: str) -> DatabricksResponse:
        """Get a materialized feature."""
        kwargs: Dict[str, Any] = {}
        kwargs['materialized_feature_id'] = materialized_feature_id
        try:
            result = self._ws.feature_engineering.get_materialized_feature(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_list_features(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """List Features."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.feature_engineering.list_features(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_list_kafka_configs(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """List Kafka configs. During PrPr, Kafka configs can be read and used when creating features under the entire metastore. Only the creator of the Kafka config can delete it."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.feature_engineering.list_kafka_configs(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_list_materialized_features(
        self,
        feature_name: Optional[str] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List materialized features."""
        kwargs: Dict[str, Any] = {}
        if feature_name is not None:
            kwargs['feature_name'] = feature_name
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.feature_engineering.list_materialized_features(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_update_feature(
        self,
        full_name: str,
        feature: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Update a Feature."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        kwargs['feature'] = feature
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.feature_engineering.update_feature(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_update_kafka_config(
        self,
        name: str,
        kafka_config: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Update a Kafka config. During PrPr, Kafka configs can be read and used when creating features under the entire metastore. Only the creator of the Kafka config can delete it."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['kafka_config'] = kafka_config
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.feature_engineering.update_kafka_config(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_engineering_update_materialized_feature(
        self,
        materialized_feature_id: str,
        materialized_feature: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Update a materialized feature (pause/resume)."""
        kwargs: Dict[str, Any] = {}
        kwargs['materialized_feature_id'] = materialized_feature_id
        kwargs['materialized_feature'] = materialized_feature
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.feature_engineering.update_materialized_feature(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # FEATURE STORE (FeatureStoreAPI) — 7 methods
    # ============================================================================

    async def feature_store_create_online_store(self, online_store: Dict[str, Any]) -> DatabricksResponse:
        """Create an Online Feature Store."""
        kwargs: Dict[str, Any] = {}
        kwargs['online_store'] = online_store
        try:
            result = self._ws.feature_store.create_online_store(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_store_delete_online_store(self, name: str) -> DatabricksResponse:
        """Delete an Online Feature Store."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.feature_store.delete_online_store(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_store_delete_online_table(self, online_table_name: str) -> DatabricksResponse:
        """Delete online table."""
        kwargs: Dict[str, Any] = {}
        kwargs['online_table_name'] = online_table_name
        try:
            result = self._ws.feature_store.delete_online_table(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_store_get_online_store(self, name: str) -> DatabricksResponse:
        """Get an Online Feature Store."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.feature_store.get_online_store(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_store_list_online_stores(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """List Online Feature Stores."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.feature_store.list_online_stores(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_store_publish_table(self, source_table_name: str, publish_spec: Dict[str, Any]) -> DatabricksResponse:
        """Publish features."""
        kwargs: Dict[str, Any] = {}
        kwargs['source_table_name'] = source_table_name
        kwargs['publish_spec'] = publish_spec
        try:
            result = self._ws.feature_store.publish_table(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def feature_store_update_online_store(
        self,
        name: str,
        online_store: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Update an Online Feature Store."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['online_store'] = online_store
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.feature_store.update_online_store(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # FILES (FilesExt) — 10 methods
    # ============================================================================

    async def files_create_directory(self, directory_path: str) -> DatabricksResponse:
        """Creates an empty directory. If necessary, also creates any parent directories of the new, empty directory (like the shell command `mkdir -p`). If called on an existing directory, returns a success ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['directory_path'] = directory_path
        try:
            result = self._ws.files.create_directory(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def files_delete(self, file_path: str) -> DatabricksResponse:
        """Deletes a file. If the request is successful, there is no response body."""
        kwargs: Dict[str, Any] = {}
        kwargs['file_path'] = file_path
        try:
            result = self._ws.files.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def files_delete_directory(self, directory_path: str) -> DatabricksResponse:
        """Deletes an empty directory."""
        kwargs: Dict[str, Any] = {}
        kwargs['directory_path'] = directory_path
        try:
            result = self._ws.files.delete_directory(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def files_download(self, file_path: str) -> DatabricksResponse:
        """Download a file."""
        kwargs: Dict[str, Any] = {}
        kwargs['file_path'] = file_path
        try:
            result = self._ws.files.download(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def files_download_to(
        self,
        file_path: str,
        destination: str,
        overwrite: Optional[bool] = True,
        use_parallel: Optional[bool] = False,
        parallelism: Optional[int] = None,
    ) -> DatabricksResponse:
        """Downloads a file directly to a local file path."""
        kwargs: Dict[str, Any] = {}
        kwargs['file_path'] = file_path
        kwargs['destination'] = destination
        if overwrite is not None:
            kwargs['overwrite'] = overwrite
        if use_parallel is not None:
            kwargs['use_parallel'] = use_parallel
        if parallelism is not None:
            kwargs['parallelism'] = parallelism
        try:
            result = self._ws.files.download_to(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def files_get_directory_metadata(self, directory_path: str) -> DatabricksResponse:
        """Get the metadata of a directory. The response HTTP headers contain the metadata. There is no response body."""
        kwargs: Dict[str, Any] = {}
        kwargs['directory_path'] = directory_path
        try:
            result = self._ws.files.get_directory_metadata(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def files_get_metadata(self, file_path: str) -> DatabricksResponse:
        """Get the metadata of a file. The response HTTP headers contain the metadata. There is no response body."""
        kwargs: Dict[str, Any] = {}
        kwargs['file_path'] = file_path
        try:
            result = self._ws.files.get_metadata(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def files_list_directory_contents(
        self,
        directory_path: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Returns the contents of a directory. If there is no directory at the specified path, the API returns a HTTP 404 error."""
        kwargs: Dict[str, Any] = {}
        kwargs['directory_path'] = directory_path
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.files.list_directory_contents(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def files_upload(
        self,
        file_path: str,
        contents: bytes,
        overwrite: Optional[bool] = None,
        part_size: Optional[int] = None,
        use_parallel: Optional[bool] = True,
        parallelism: Optional[int] = None,
    ) -> DatabricksResponse:
        """Uploads a file from memory or a stream interface."""
        kwargs: Dict[str, Any] = {}
        kwargs['file_path'] = file_path
        kwargs['contents'] = contents
        if overwrite is not None:
            kwargs['overwrite'] = overwrite
        if part_size is not None:
            kwargs['part_size'] = part_size
        if use_parallel is not None:
            kwargs['use_parallel'] = use_parallel
        if parallelism is not None:
            kwargs['parallelism'] = parallelism
        try:
            result = self._ws.files.upload(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def files_upload_from(
        self,
        file_path: str,
        source_path: str,
        overwrite: Optional[bool] = None,
        part_size: Optional[int] = None,
        use_parallel: Optional[bool] = True,
        parallelism: Optional[int] = None,
    ) -> DatabricksResponse:
        """Uploads a file from a local file path."""
        kwargs: Dict[str, Any] = {}
        kwargs['file_path'] = file_path
        kwargs['source_path'] = source_path
        if overwrite is not None:
            kwargs['overwrite'] = overwrite
        if part_size is not None:
            kwargs['part_size'] = part_size
        if use_parallel is not None:
            kwargs['use_parallel'] = use_parallel
        if parallelism is not None:
            kwargs['parallelism'] = parallelism
        try:
            result = self._ws.files.upload_from(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # FORECASTING (ForecastingAPI) — 2 methods
    # ============================================================================

    async def forecasting_create_experiment(
        self,
        train_data_path: str,
        target_column: str,
        time_column: str,
        forecast_granularity: str,
        forecast_horizon: int,
        custom_weights_column: Optional[str] = None,
        experiment_path: Optional[str] = None,
        future_feature_data_path: Optional[str] = None,
        holiday_regions: Optional[List[str]] = None,
        include_features: Optional[List[str]] = None,
        max_runtime: Optional[int] = None,
        prediction_data_path: Optional[str] = None,
        primary_metric: Optional[str] = None,
        register_to: Optional[str] = None,
        split_column: Optional[str] = None,
        timeseries_identifier_columns: Optional[List[str]] = None,
        training_frameworks: Optional[List[str]] = None,
    ) -> DatabricksResponse:
        """Creates a serverless forecasting experiment. Returns the experiment ID."""
        kwargs: Dict[str, Any] = {}
        kwargs['train_data_path'] = train_data_path
        kwargs['target_column'] = target_column
        kwargs['time_column'] = time_column
        kwargs['forecast_granularity'] = forecast_granularity
        kwargs['forecast_horizon'] = forecast_horizon
        if custom_weights_column is not None:
            kwargs['custom_weights_column'] = custom_weights_column
        if experiment_path is not None:
            kwargs['experiment_path'] = experiment_path
        if future_feature_data_path is not None:
            kwargs['future_feature_data_path'] = future_feature_data_path
        if holiday_regions is not None:
            kwargs['holiday_regions'] = holiday_regions
        if include_features is not None:
            kwargs['include_features'] = include_features
        if max_runtime is not None:
            kwargs['max_runtime'] = max_runtime
        if prediction_data_path is not None:
            kwargs['prediction_data_path'] = prediction_data_path
        if primary_metric is not None:
            kwargs['primary_metric'] = primary_metric
        if register_to is not None:
            kwargs['register_to'] = register_to
        if split_column is not None:
            kwargs['split_column'] = split_column
        if timeseries_identifier_columns is not None:
            kwargs['timeseries_identifier_columns'] = timeseries_identifier_columns
        if training_frameworks is not None:
            kwargs['training_frameworks'] = training_frameworks
        try:
            result = self._ws.forecasting.create_experiment(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def forecasting_get_experiment(self, experiment_id: str) -> DatabricksResponse:
        """Public RPC to get forecasting experiment"""
        kwargs: Dict[str, Any] = {}
        kwargs['experiment_id'] = experiment_id
        try:
            result = self._ws.forecasting.get_experiment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # FUNCTIONS (FunctionsAPI) — 5 methods
    # ============================================================================

    async def functions_create(self, function_info: Dict[str, Any]) -> DatabricksResponse:
        """**WARNING: This API is experimental and will change in future versions**"""
        kwargs: Dict[str, Any] = {}
        kwargs['function_info'] = function_info
        try:
            result = self._ws.functions.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def functions_delete(self, name: str, force: Optional[bool] = None) -> DatabricksResponse:
        """Deletes the function that matches the supplied name. For the deletion to succeed, the user must satisfy one of the following conditions: - Is the owner of the function's parent catalog - Is the own..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if force is not None:
            kwargs['force'] = force
        try:
            result = self._ws.functions.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def functions_get(self, name: str, include_browse: Optional[bool] = None) -> DatabricksResponse:
        """Gets a function from within a parent catalog and schema. For the fetch to succeed, the user must satisfy one of the following requirements: - Is a metastore admin - Is an owner of the function's pa..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        try:
            result = self._ws.functions.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def functions_list(
        self,
        catalog_name: str,
        schema_name: str,
        include_browse: Optional[bool] = None,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List functions within the specified parent catalog and schema. If the user is a metastore admin, all functions are returned in the output list. Otherwise, the user must have the **USE_CATALOG** pri..."""
        kwargs: Dict[str, Any] = {}
        kwargs['catalog_name'] = catalog_name
        kwargs['schema_name'] = schema_name
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.functions.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def functions_update(self, name: str, owner: Optional[str] = None) -> DatabricksResponse:
        """Updates the function that matches the supplied name. Only the owner of the function can be updated. If the user is not a metastore admin, the user must be a member of the group that is the new func..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if owner is not None:
            kwargs['owner'] = owner
        try:
            result = self._ws.functions.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # GENIE (GenieAPI) — 20 methods
    # ============================================================================

    async def genie_create_message(
        self,
        space_id: str,
        conversation_id: str,
        content: str,
    ) -> DatabricksResponse:
        """Create new message in a [conversation](:method:genie/startconversation). The AI response uses all previously created messages in the conversation to respond."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        kwargs['conversation_id'] = conversation_id
        kwargs['content'] = content
        try:
            result = self._ws.genie.create_message(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_create_space(
        self,
        warehouse_id: str,
        serialized_space: str,
        description: Optional[str] = None,
        parent_path: Optional[str] = None,
        title: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a Genie space from a serialized payload."""
        kwargs: Dict[str, Any] = {}
        kwargs['warehouse_id'] = warehouse_id
        kwargs['serialized_space'] = serialized_space
        if description is not None:
            kwargs['description'] = description
        if parent_path is not None:
            kwargs['parent_path'] = parent_path
        if title is not None:
            kwargs['title'] = title
        try:
            result = self._ws.genie.create_space(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_delete_conversation(self, space_id: str, conversation_id: str) -> DatabricksResponse:
        """Delete a conversation."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        kwargs['conversation_id'] = conversation_id
        try:
            result = self._ws.genie.delete_conversation(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_delete_conversation_message(
        self,
        space_id: str,
        conversation_id: str,
        message_id: str,
    ) -> DatabricksResponse:
        """Delete a conversation message."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        kwargs['conversation_id'] = conversation_id
        kwargs['message_id'] = message_id
        try:
            result = self._ws.genie.delete_conversation_message(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_execute_message_attachment_query(
        self,
        space_id: str,
        conversation_id: str,
        message_id: str,
        attachment_id: str,
    ) -> DatabricksResponse:
        """Execute the SQL for a message query attachment. Use this API when the query attachment has expired and needs to be re-executed."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        kwargs['conversation_id'] = conversation_id
        kwargs['message_id'] = message_id
        kwargs['attachment_id'] = attachment_id
        try:
            result = self._ws.genie.execute_message_attachment_query(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_execute_message_query(
        self,
        space_id: str,
        conversation_id: str,
        message_id: str,
    ) -> DatabricksResponse:
        """DEPRECATED: Use [Execute Message Attachment Query](:method:genie/executemessageattachmentquery) instead."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        kwargs['conversation_id'] = conversation_id
        kwargs['message_id'] = message_id
        try:
            result = self._ws.genie.execute_message_query(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_generate_download_full_query_result(
        self,
        space_id: str,
        conversation_id: str,
        message_id: str,
        attachment_id: str,
    ) -> DatabricksResponse:
        """Initiates a new SQL execution and returns a `download_id` and `download_id_signature` that you can use to track the progress of the download. The query result is stored in an external link and can ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        kwargs['conversation_id'] = conversation_id
        kwargs['message_id'] = message_id
        kwargs['attachment_id'] = attachment_id
        try:
            result = self._ws.genie.generate_download_full_query_result(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_get_download_full_query_result(
        self,
        space_id: str,
        conversation_id: str,
        message_id: str,
        attachment_id: str,
        download_id: str,
        download_id_signature: Optional[str] = None,
    ) -> DatabricksResponse:
        """After [Generating a Full Query Result Download](:method:genie/generatedownloadfullqueryresult) and successfully receiving a `download_id` and `download_id_signature`, use this API to poll the downl..."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        kwargs['conversation_id'] = conversation_id
        kwargs['message_id'] = message_id
        kwargs['attachment_id'] = attachment_id
        kwargs['download_id'] = download_id
        if download_id_signature is not None:
            kwargs['download_id_signature'] = download_id_signature
        try:
            result = self._ws.genie.get_download_full_query_result(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_get_message(
        self,
        space_id: str,
        conversation_id: str,
        message_id: str,
    ) -> DatabricksResponse:
        """Get message from conversation."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        kwargs['conversation_id'] = conversation_id
        kwargs['message_id'] = message_id
        try:
            result = self._ws.genie.get_message(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_get_message_attachment_query_result(
        self,
        space_id: str,
        conversation_id: str,
        message_id: str,
        attachment_id: str,
    ) -> DatabricksResponse:
        """Get the result of SQL query if the message has a query attachment. This is only available if a message has a query attachment and the message status is `EXECUTING_QUERY` OR `COMPLETED`."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        kwargs['conversation_id'] = conversation_id
        kwargs['message_id'] = message_id
        kwargs['attachment_id'] = attachment_id
        try:
            result = self._ws.genie.get_message_attachment_query_result(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_get_message_query_result(
        self,
        space_id: str,
        conversation_id: str,
        message_id: str,
    ) -> DatabricksResponse:
        """DEPRECATED: Use [Get Message Attachment Query Result](:method:genie/getmessageattachmentqueryresult) instead."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        kwargs['conversation_id'] = conversation_id
        kwargs['message_id'] = message_id
        try:
            result = self._ws.genie.get_message_query_result(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_get_message_query_result_by_attachment(
        self,
        space_id: str,
        conversation_id: str,
        message_id: str,
        attachment_id: str,
    ) -> DatabricksResponse:
        """DEPRECATED: Use [Get Message Attachment Query Result](:method:genie/getmessageattachmentqueryresult) instead."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        kwargs['conversation_id'] = conversation_id
        kwargs['message_id'] = message_id
        kwargs['attachment_id'] = attachment_id
        try:
            result = self._ws.genie.get_message_query_result_by_attachment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_get_space(
        self,
        space_id: str,
        include_serialized_space: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Get details of a Genie Space."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        if include_serialized_space is not None:
            kwargs['include_serialized_space'] = include_serialized_space
        try:
            result = self._ws.genie.get_space(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_list_conversation_messages(
        self,
        space_id: str,
        conversation_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List messages in a conversation"""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        kwargs['conversation_id'] = conversation_id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = self._ws.genie.list_conversation_messages(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_list_conversations(
        self,
        space_id: str,
        include_all: Optional[bool] = None,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Get a list of conversations in a Genie Space."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        if include_all is not None:
            kwargs['include_all'] = include_all
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = self._ws.genie.list_conversations(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_list_spaces(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Get list of Genie Spaces."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = self._ws.genie.list_spaces(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_send_message_feedback(
        self,
        space_id: str,
        conversation_id: str,
        message_id: str,
        rating: Dict[str, Any],
    ) -> DatabricksResponse:
        """Send feedback for a message."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        kwargs['conversation_id'] = conversation_id
        kwargs['message_id'] = message_id
        kwargs['rating'] = rating
        try:
            result = self._ws.genie.send_message_feedback(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_start_conversation(self, space_id: str, content: str) -> DatabricksResponse:
        """Start a new conversation."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        kwargs['content'] = content
        try:
            result = self._ws.genie.start_conversation(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_trash_space(self, space_id: str) -> DatabricksResponse:
        """Move a Genie Space to the trash."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        try:
            result = self._ws.genie.trash_space(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def genie_update_space(
        self,
        space_id: str,
        description: Optional[str] = None,
        serialized_space: Optional[str] = None,
        title: Optional[str] = None,
        warehouse_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates a Genie space with a serialized payload."""
        kwargs: Dict[str, Any] = {}
        kwargs['space_id'] = space_id
        if description is not None:
            kwargs['description'] = description
        if serialized_space is not None:
            kwargs['serialized_space'] = serialized_space
        if title is not None:
            kwargs['title'] = title
        if warehouse_id is not None:
            kwargs['warehouse_id'] = warehouse_id
        try:
            result = self._ws.genie.update_space(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # GIT CREDENTIALS (GitCredentialsAPI) — 5 methods
    # ============================================================================

    async def git_credentials_create(
        self,
        git_provider: str,
        git_email: Optional[str] = None,
        git_username: Optional[str] = None,
        is_default_for_provider: Optional[bool] = None,
        name: Optional[str] = None,
        personal_access_token: Optional[str] = None,
        principal_id: Optional[int] = None,
    ) -> DatabricksResponse:
        """Creates a Git credential entry for the user. Only one Git credential per user is supported, so any attempts to create credentials if an entry already exists will fail. Use the PATCH endpoint to upd..."""
        kwargs: Dict[str, Any] = {}
        kwargs['git_provider'] = git_provider
        if git_email is not None:
            kwargs['git_email'] = git_email
        if git_username is not None:
            kwargs['git_username'] = git_username
        if is_default_for_provider is not None:
            kwargs['is_default_for_provider'] = is_default_for_provider
        if name is not None:
            kwargs['name'] = name
        if personal_access_token is not None:
            kwargs['personal_access_token'] = personal_access_token
        if principal_id is not None:
            kwargs['principal_id'] = principal_id
        try:
            result = self._ws.git_credentials.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def git_credentials_delete(self, credential_id: int, principal_id: Optional[int] = None) -> DatabricksResponse:
        """Deletes the specified Git credential."""
        kwargs: Dict[str, Any] = {}
        kwargs['credential_id'] = credential_id
        if principal_id is not None:
            kwargs['principal_id'] = principal_id
        try:
            result = self._ws.git_credentials.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def git_credentials_get(self, credential_id: int, principal_id: Optional[int] = None) -> DatabricksResponse:
        """Gets the Git credential with the specified credential ID."""
        kwargs: Dict[str, Any] = {}
        kwargs['credential_id'] = credential_id
        if principal_id is not None:
            kwargs['principal_id'] = principal_id
        try:
            result = self._ws.git_credentials.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def git_credentials_list(self, principal_id: Optional[int] = None) -> DatabricksResponse:
        """Lists the calling user's Git credentials."""
        kwargs: Dict[str, Any] = {}
        if principal_id is not None:
            kwargs['principal_id'] = principal_id
        try:
            result = list(self._ws.git_credentials.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def git_credentials_update(
        self,
        credential_id: int,
        git_provider: str,
        git_email: Optional[str] = None,
        git_username: Optional[str] = None,
        is_default_for_provider: Optional[bool] = None,
        name: Optional[str] = None,
        personal_access_token: Optional[str] = None,
        principal_id: Optional[int] = None,
    ) -> DatabricksResponse:
        """Updates the specified Git credential."""
        kwargs: Dict[str, Any] = {}
        kwargs['credential_id'] = credential_id
        kwargs['git_provider'] = git_provider
        if git_email is not None:
            kwargs['git_email'] = git_email
        if git_username is not None:
            kwargs['git_username'] = git_username
        if is_default_for_provider is not None:
            kwargs['is_default_for_provider'] = is_default_for_provider
        if name is not None:
            kwargs['name'] = name
        if personal_access_token is not None:
            kwargs['personal_access_token'] = personal_access_token
        if principal_id is not None:
            kwargs['principal_id'] = principal_id
        try:
            result = self._ws.git_credentials.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # GLOBAL INIT SCRIPTS (GlobalInitScriptsAPI) — 5 methods
    # ============================================================================

    async def global_init_scripts_create(
        self,
        name: str,
        script: str,
        enabled: Optional[bool] = None,
        position: Optional[int] = None,
    ) -> DatabricksResponse:
        """Creates a new global init script in this workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['script'] = script
        if enabled is not None:
            kwargs['enabled'] = enabled
        if position is not None:
            kwargs['position'] = position
        try:
            result = self._ws.global_init_scripts.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def global_init_scripts_delete(self, script_id: str) -> DatabricksResponse:
        """Deletes a global init script."""
        kwargs: Dict[str, Any] = {}
        kwargs['script_id'] = script_id
        try:
            result = self._ws.global_init_scripts.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def global_init_scripts_get(self, script_id: str) -> DatabricksResponse:
        """Gets all the details of a script, including its Base64-encoded contents."""
        kwargs: Dict[str, Any] = {}
        kwargs['script_id'] = script_id
        try:
            result = self._ws.global_init_scripts.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def global_init_scripts_list(self) -> DatabricksResponse:
        """Get a list of all global init scripts for this workspace. This returns all properties for each script but **not** the script contents. To retrieve the contents of a script, use the [get a global in..."""
        kwargs: Dict[str, Any] = {}
        try:
            result = list(self._ws.global_init_scripts.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def global_init_scripts_update(
        self,
        script_id: str,
        name: str,
        script: str,
        enabled: Optional[bool] = None,
        position: Optional[int] = None,
    ) -> DatabricksResponse:
        """Updates a global init script, specifying only the fields to change. All fields are optional. Unspecified fields retain their current value."""
        kwargs: Dict[str, Any] = {}
        kwargs['script_id'] = script_id
        kwargs['name'] = name
        kwargs['script'] = script
        if enabled is not None:
            kwargs['enabled'] = enabled
        if position is not None:
            kwargs['position'] = position
        try:
            result = self._ws.global_init_scripts.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # GRANTS (GrantsAPI) — 3 methods
    # ============================================================================

    async def grants_get(
        self,
        securable_type: str,
        full_name: str,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
        principal: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets the permissions for a securable. Does not include inherited permissions."""
        kwargs: Dict[str, Any] = {}
        kwargs['securable_type'] = securable_type
        kwargs['full_name'] = full_name
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        if principal is not None:
            kwargs['principal'] = principal
        try:
            result = self._ws.grants.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def grants_get_effective(
        self,
        securable_type: str,
        full_name: str,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
        principal: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets the effective permissions for a securable. Includes inherited permissions from any parent securables."""
        kwargs: Dict[str, Any] = {}
        kwargs['securable_type'] = securable_type
        kwargs['full_name'] = full_name
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        if principal is not None:
            kwargs['principal'] = principal
        try:
            result = self._ws.grants.get_effective(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def grants_update(
        self,
        securable_type: str,
        full_name: str,
        changes: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions for a securable."""
        kwargs: Dict[str, Any] = {}
        kwargs['securable_type'] = securable_type
        kwargs['full_name'] = full_name
        if changes is not None:
            kwargs['changes'] = changes
        try:
            result = self._ws.grants.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # GROUPS (GroupsAPI) — 6 methods
    # ============================================================================

    async def groups_create(
        self,
        display_name: Optional[str] = None,
        entitlements: Optional[List[Dict[str, Any]]] = None,
        external_id: Optional[str] = None,
        groups: Optional[List[Dict[str, Any]]] = None,
        id: Optional[str] = None,
        members: Optional[List[Dict[str, Any]]] = None,
        meta: Optional[Dict[str, Any]] = None,
        roles: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Creates a group in the Databricks workspace with a unique name, using the supplied group details."""
        kwargs: Dict[str, Any] = {}
        if display_name is not None:
            kwargs['display_name'] = display_name
        if entitlements is not None:
            kwargs['entitlements'] = entitlements
        if external_id is not None:
            kwargs['external_id'] = external_id
        if groups is not None:
            kwargs['groups'] = groups
        if id is not None:
            kwargs['id'] = id
        if members is not None:
            kwargs['members'] = members
        if meta is not None:
            kwargs['meta'] = meta
        if roles is not None:
            kwargs['roles'] = roles
        if schemas is not None:
            kwargs['schemas'] = schemas
        try:
            result = self._ws.groups.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def groups_delete(self, id: str) -> DatabricksResponse:
        """Deletes a group from the Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.groups.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def groups_get(self, id: str) -> DatabricksResponse:
        """Gets the information for a specific group in the Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.groups.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def groups_list(
        self,
        attributes: Optional[str] = None,
        count: Optional[int] = None,
        excluded_attributes: Optional[str] = None,
        filter: Optional[str] = None,
        sort_by: Optional[str] = None,
        sort_order: Optional[Dict[str, Any]] = None,
        start_index: Optional[int] = None,
    ) -> DatabricksResponse:
        """Gets all details of the groups associated with the Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        if attributes is not None:
            kwargs['attributes'] = attributes
        if count is not None:
            kwargs['count'] = count
        if excluded_attributes is not None:
            kwargs['excluded_attributes'] = excluded_attributes
        if filter is not None:
            kwargs['filter'] = filter
        if sort_by is not None:
            kwargs['sort_by'] = sort_by
        if sort_order is not None:
            kwargs['sort_order'] = sort_order
        if start_index is not None:
            kwargs['start_index'] = start_index
        try:
            result = list(self._ws.groups.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def groups_patch(
        self,
        id: str,
        operations: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Partially updates the details of a group."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if operations is not None:
            kwargs['operations'] = operations
        if schemas is not None:
            kwargs['schemas'] = schemas
        try:
            result = self._ws.groups.patch(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def groups_update(
        self,
        id: str,
        display_name: Optional[str] = None,
        entitlements: Optional[List[Dict[str, Any]]] = None,
        external_id: Optional[str] = None,
        groups: Optional[List[Dict[str, Any]]] = None,
        members: Optional[List[Dict[str, Any]]] = None,
        meta: Optional[Dict[str, Any]] = None,
        roles: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the details of a group by replacing the entire group entity."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if display_name is not None:
            kwargs['display_name'] = display_name
        if entitlements is not None:
            kwargs['entitlements'] = entitlements
        if external_id is not None:
            kwargs['external_id'] = external_id
        if groups is not None:
            kwargs['groups'] = groups
        if members is not None:
            kwargs['members'] = members
        if meta is not None:
            kwargs['meta'] = meta
        if roles is not None:
            kwargs['roles'] = roles
        if schemas is not None:
            kwargs['schemas'] = schemas
        try:
            result = self._ws.groups.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # GROUPS V2 (GroupsV2API) — 6 methods
    # ============================================================================

    async def groups_v2_create(
        self,
        display_name: Optional[str] = None,
        entitlements: Optional[List[Dict[str, Any]]] = None,
        external_id: Optional[str] = None,
        groups: Optional[List[Dict[str, Any]]] = None,
        id: Optional[str] = None,
        members: Optional[List[Dict[str, Any]]] = None,
        meta: Optional[Dict[str, Any]] = None,
        roles: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Creates a group in the Databricks workspace with a unique name, using the supplied group details."""
        kwargs: Dict[str, Any] = {}
        if display_name is not None:
            kwargs['display_name'] = display_name
        if entitlements is not None:
            kwargs['entitlements'] = entitlements
        if external_id is not None:
            kwargs['external_id'] = external_id
        if groups is not None:
            kwargs['groups'] = groups
        if id is not None:
            kwargs['id'] = id
        if members is not None:
            kwargs['members'] = members
        if meta is not None:
            kwargs['meta'] = meta
        if roles is not None:
            kwargs['roles'] = roles
        if schemas is not None:
            kwargs['schemas'] = schemas
        try:
            result = self._ws.groups_v2.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def groups_v2_delete(self, id: str) -> DatabricksResponse:
        """Deletes a group from the Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.groups_v2.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def groups_v2_get(self, id: str) -> DatabricksResponse:
        """Gets the information for a specific group in the Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.groups_v2.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def groups_v2_list(
        self,
        attributes: Optional[str] = None,
        count: Optional[int] = None,
        excluded_attributes: Optional[str] = None,
        filter: Optional[str] = None,
        sort_by: Optional[str] = None,
        sort_order: Optional[Dict[str, Any]] = None,
        start_index: Optional[int] = None,
    ) -> DatabricksResponse:
        """Gets all details of the groups associated with the Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        if attributes is not None:
            kwargs['attributes'] = attributes
        if count is not None:
            kwargs['count'] = count
        if excluded_attributes is not None:
            kwargs['excluded_attributes'] = excluded_attributes
        if filter is not None:
            kwargs['filter'] = filter
        if sort_by is not None:
            kwargs['sort_by'] = sort_by
        if sort_order is not None:
            kwargs['sort_order'] = sort_order
        if start_index is not None:
            kwargs['start_index'] = start_index
        try:
            result = list(self._ws.groups_v2.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def groups_v2_patch(
        self,
        id: str,
        operations: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Partially updates the details of a group."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if operations is not None:
            kwargs['operations'] = operations
        if schemas is not None:
            kwargs['schemas'] = schemas
        try:
            result = self._ws.groups_v2.patch(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def groups_v2_update(
        self,
        id: str,
        display_name: Optional[str] = None,
        entitlements: Optional[List[Dict[str, Any]]] = None,
        external_id: Optional[str] = None,
        groups: Optional[List[Dict[str, Any]]] = None,
        members: Optional[List[Dict[str, Any]]] = None,
        meta: Optional[Dict[str, Any]] = None,
        roles: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the details of a group by replacing the entire group entity."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if display_name is not None:
            kwargs['display_name'] = display_name
        if entitlements is not None:
            kwargs['entitlements'] = entitlements
        if external_id is not None:
            kwargs['external_id'] = external_id
        if groups is not None:
            kwargs['groups'] = groups
        if members is not None:
            kwargs['members'] = members
        if meta is not None:
            kwargs['meta'] = meta
        if roles is not None:
            kwargs['roles'] = roles
        if schemas is not None:
            kwargs['schemas'] = schemas
        try:
            result = self._ws.groups_v2.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # INSTANCE POOLS (InstancePoolsAPI) — 9 methods
    # ============================================================================

    async def instance_pools_create(
        self,
        instance_pool_name: str,
        node_type_id: str,
        aws_attributes: Optional[Dict[str, Any]] = None,
        azure_attributes: Optional[Dict[str, Any]] = None,
        custom_tags: Optional[Dict[str, str]] = None,
        disk_spec: Optional[Dict[str, Any]] = None,
        enable_elastic_disk: Optional[bool] = None,
        gcp_attributes: Optional[Dict[str, Any]] = None,
        idle_instance_autotermination_minutes: Optional[int] = None,
        max_capacity: Optional[int] = None,
        min_idle_instances: Optional[int] = None,
        node_type_flexibility: Optional[Dict[str, Any]] = None,
        preloaded_docker_images: Optional[List[Dict[str, Any]]] = None,
        preloaded_spark_versions: Optional[List[str]] = None,
        remote_disk_throughput: Optional[int] = None,
        total_initial_remote_disk_size: Optional[int] = None,
    ) -> DatabricksResponse:
        """Creates a new instance pool using idle and ready-to-use cloud instances."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_pool_name'] = instance_pool_name
        kwargs['node_type_id'] = node_type_id
        if aws_attributes is not None:
            kwargs['aws_attributes'] = aws_attributes
        if azure_attributes is not None:
            kwargs['azure_attributes'] = azure_attributes
        if custom_tags is not None:
            kwargs['custom_tags'] = custom_tags
        if disk_spec is not None:
            kwargs['disk_spec'] = disk_spec
        if enable_elastic_disk is not None:
            kwargs['enable_elastic_disk'] = enable_elastic_disk
        if gcp_attributes is not None:
            kwargs['gcp_attributes'] = gcp_attributes
        if idle_instance_autotermination_minutes is not None:
            kwargs['idle_instance_autotermination_minutes'] = idle_instance_autotermination_minutes
        if max_capacity is not None:
            kwargs['max_capacity'] = max_capacity
        if min_idle_instances is not None:
            kwargs['min_idle_instances'] = min_idle_instances
        if node_type_flexibility is not None:
            kwargs['node_type_flexibility'] = node_type_flexibility
        if preloaded_docker_images is not None:
            kwargs['preloaded_docker_images'] = preloaded_docker_images
        if preloaded_spark_versions is not None:
            kwargs['preloaded_spark_versions'] = preloaded_spark_versions
        if remote_disk_throughput is not None:
            kwargs['remote_disk_throughput'] = remote_disk_throughput
        if total_initial_remote_disk_size is not None:
            kwargs['total_initial_remote_disk_size'] = total_initial_remote_disk_size
        try:
            result = self._ws.instance_pools.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def instance_pools_delete(self, instance_pool_id: str) -> DatabricksResponse:
        """Deletes the instance pool permanently. The idle instances in the pool are terminated asynchronously."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_pool_id'] = instance_pool_id
        try:
            result = self._ws.instance_pools.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def instance_pools_edit(
        self,
        instance_pool_id: str,
        instance_pool_name: str,
        node_type_id: str,
        custom_tags: Optional[Dict[str, str]] = None,
        idle_instance_autotermination_minutes: Optional[int] = None,
        max_capacity: Optional[int] = None,
        min_idle_instances: Optional[int] = None,
        node_type_flexibility: Optional[Dict[str, Any]] = None,
        remote_disk_throughput: Optional[int] = None,
        total_initial_remote_disk_size: Optional[int] = None,
    ) -> DatabricksResponse:
        """Modifies the configuration of an existing instance pool."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_pool_id'] = instance_pool_id
        kwargs['instance_pool_name'] = instance_pool_name
        kwargs['node_type_id'] = node_type_id
        if custom_tags is not None:
            kwargs['custom_tags'] = custom_tags
        if idle_instance_autotermination_minutes is not None:
            kwargs['idle_instance_autotermination_minutes'] = idle_instance_autotermination_minutes
        if max_capacity is not None:
            kwargs['max_capacity'] = max_capacity
        if min_idle_instances is not None:
            kwargs['min_idle_instances'] = min_idle_instances
        if node_type_flexibility is not None:
            kwargs['node_type_flexibility'] = node_type_flexibility
        if remote_disk_throughput is not None:
            kwargs['remote_disk_throughput'] = remote_disk_throughput
        if total_initial_remote_disk_size is not None:
            kwargs['total_initial_remote_disk_size'] = total_initial_remote_disk_size
        try:
            result = self._ws.instance_pools.edit(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def instance_pools_get(self, instance_pool_id: str) -> DatabricksResponse:
        """Retrieve the information for an instance pool based on its identifier."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_pool_id'] = instance_pool_id
        try:
            result = self._ws.instance_pools.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def instance_pools_get_permission_levels(self, instance_pool_id: str) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_pool_id'] = instance_pool_id
        try:
            result = self._ws.instance_pools.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def instance_pools_get_permissions(self, instance_pool_id: str) -> DatabricksResponse:
        """Gets the permissions of an instance pool. Instance pools can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_pool_id'] = instance_pool_id
        try:
            result = self._ws.instance_pools.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def instance_pools_list(self) -> DatabricksResponse:
        """Gets a list of instance pools with their statistics."""
        kwargs: Dict[str, Any] = {}
        try:
            result = list(self._ws.instance_pools.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def instance_pools_set_permissions(
        self,
        instance_pool_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_pool_id'] = instance_pool_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.instance_pools.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def instance_pools_update_permissions(
        self,
        instance_pool_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on an instance pool. Instance pools can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_pool_id'] = instance_pool_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.instance_pools.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # INSTANCE PROFILES (InstanceProfilesAPI) — 4 methods
    # ============================================================================

    async def instance_profiles_add(
        self,
        instance_profile_arn: str,
        iam_role_arn: Optional[str] = None,
        is_meta_instance_profile: Optional[bool] = None,
        skip_validation: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Registers an instance profile in Databricks. In the UI, you can then give users the permission to use this instance profile when launching clusters."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_profile_arn'] = instance_profile_arn
        if iam_role_arn is not None:
            kwargs['iam_role_arn'] = iam_role_arn
        if is_meta_instance_profile is not None:
            kwargs['is_meta_instance_profile'] = is_meta_instance_profile
        if skip_validation is not None:
            kwargs['skip_validation'] = skip_validation
        try:
            result = self._ws.instance_profiles.add(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def instance_profiles_edit(
        self,
        instance_profile_arn: str,
        iam_role_arn: Optional[str] = None,
        is_meta_instance_profile: Optional[bool] = None,
    ) -> DatabricksResponse:
        """The only supported field to change is the optional IAM role ARN associated with the instance profile. It is required to specify the IAM role ARN if both of the following are true:"""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_profile_arn'] = instance_profile_arn
        if iam_role_arn is not None:
            kwargs['iam_role_arn'] = iam_role_arn
        if is_meta_instance_profile is not None:
            kwargs['is_meta_instance_profile'] = is_meta_instance_profile
        try:
            result = self._ws.instance_profiles.edit(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def instance_profiles_list(self) -> DatabricksResponse:
        """List the instance profiles that the calling user can use to launch a cluster."""
        kwargs: Dict[str, Any] = {}
        try:
            result = list(self._ws.instance_profiles.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def instance_profiles_remove(self, instance_profile_arn: str) -> DatabricksResponse:
        """Remove the instance profile with the provided ARN. Existing clusters with this instance profile will continue to function."""
        kwargs: Dict[str, Any] = {}
        kwargs['instance_profile_arn'] = instance_profile_arn
        try:
            result = self._ws.instance_profiles.remove(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # IP ACCESS LISTS (IpAccessListsAPI) — 6 methods
    # ============================================================================

    async def ip_access_lists_create(
        self,
        label: str,
        list_type: Dict[str, Any],
        ip_addresses: Optional[List[str]] = None,
    ) -> DatabricksResponse:
        """Creates an IP access list for this workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['label'] = label
        kwargs['list_type'] = list_type
        if ip_addresses is not None:
            kwargs['ip_addresses'] = ip_addresses
        try:
            result = self._ws.ip_access_lists.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def ip_access_lists_delete(self, ip_access_list_id: str) -> DatabricksResponse:
        """Deletes an IP access list, specified by its list ID."""
        kwargs: Dict[str, Any] = {}
        kwargs['ip_access_list_id'] = ip_access_list_id
        try:
            result = self._ws.ip_access_lists.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def ip_access_lists_get(self, ip_access_list_id: str) -> DatabricksResponse:
        """Gets an IP access list, specified by its list ID."""
        kwargs: Dict[str, Any] = {}
        kwargs['ip_access_list_id'] = ip_access_list_id
        try:
            result = self._ws.ip_access_lists.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def ip_access_lists_list(self) -> DatabricksResponse:
        """Gets all IP access lists for the specified workspace."""
        kwargs: Dict[str, Any] = {}
        try:
            result = list(self._ws.ip_access_lists.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def ip_access_lists_replace(
        self,
        ip_access_list_id: str,
        label: str,
        list_type: Dict[str, Any],
        enabled: bool,
        ip_addresses: Optional[List[str]] = None,
    ) -> DatabricksResponse:
        """Replaces an IP access list, specified by its ID."""
        kwargs: Dict[str, Any] = {}
        kwargs['ip_access_list_id'] = ip_access_list_id
        kwargs['label'] = label
        kwargs['list_type'] = list_type
        kwargs['enabled'] = enabled
        if ip_addresses is not None:
            kwargs['ip_addresses'] = ip_addresses
        try:
            result = self._ws.ip_access_lists.replace(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def ip_access_lists_update(
        self,
        ip_access_list_id: str,
        enabled: Optional[bool] = None,
        ip_addresses: Optional[List[str]] = None,
        label: Optional[str] = None,
        list_type: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Updates an existing IP access list, specified by its ID."""
        kwargs: Dict[str, Any] = {}
        kwargs['ip_access_list_id'] = ip_access_list_id
        if enabled is not None:
            kwargs['enabled'] = enabled
        if ip_addresses is not None:
            kwargs['ip_addresses'] = ip_addresses
        if label is not None:
            kwargs['label'] = label
        if list_type is not None:
            kwargs['list_type'] = list_type
        try:
            result = self._ws.ip_access_lists.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # JOBS (JobsExt) — 20 methods
    # ============================================================================

    async def jobs_cancel_all_runs(self, all_queued_runs: Optional[bool] = None, job_id: Optional[int] = None) -> DatabricksResponse:
        """Cancels all active runs of a job. The runs are canceled asynchronously, so it doesn't prevent new runs from being started."""
        kwargs: Dict[str, Any] = {}
        if all_queued_runs is not None:
            kwargs['all_queued_runs'] = all_queued_runs
        if job_id is not None:
            kwargs['job_id'] = job_id
        try:
            result = self._ws.jobs.cancel_all_runs(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_cancel_run(self, run_id: int) -> DatabricksResponse:
        """Cancels a job run or a task run. The run is canceled asynchronously, so it may still be running when this request completes."""
        kwargs: Dict[str, Any] = {}
        kwargs['run_id'] = run_id
        try:
            result = self._ws.jobs.cancel_run(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_create(
        self,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
        budget_policy_id: Optional[str] = None,
        continuous: Optional[Dict[str, Any]] = None,
        deployment: Optional[Dict[str, Any]] = None,
        description: Optional[str] = None,
        edit_mode: Optional[Dict[str, Any]] = None,
        email_notifications: Optional[Dict[str, Any]] = None,
        environments: Optional[List[Dict[str, Any]]] = None,
        format: Optional[Dict[str, Any]] = None,
        git_source: Optional[Dict[str, Any]] = None,
        health: Optional[Dict[str, Any]] = None,
        job_clusters: Optional[List[Dict[str, Any]]] = None,
        max_concurrent_runs: Optional[int] = None,
        name: Optional[str] = None,
        notification_settings: Optional[Dict[str, Any]] = None,
        parameters: Optional[List[Dict[str, Any]]] = None,
        performance_target: Optional[Dict[str, Any]] = None,
        queue: Optional[Dict[str, Any]] = None,
        run_as: Optional[Dict[str, Any]] = None,
        schedule: Optional[Dict[str, Any]] = None,
        tags: Optional[Dict[str, str]] = None,
        tasks: Optional[List[Dict[str, Any]]] = None,
        timeout_seconds: Optional[int] = None,
        trigger: Optional[Dict[str, Any]] = None,
        usage_policy_id: Optional[str] = None,
        webhook_notifications: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Create a new job."""
        kwargs: Dict[str, Any] = {}
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        if budget_policy_id is not None:
            kwargs['budget_policy_id'] = budget_policy_id
        if continuous is not None:
            kwargs['continuous'] = continuous
        if deployment is not None:
            kwargs['deployment'] = deployment
        if description is not None:
            kwargs['description'] = description
        if edit_mode is not None:
            kwargs['edit_mode'] = edit_mode
        if email_notifications is not None:
            kwargs['email_notifications'] = email_notifications
        if environments is not None:
            kwargs['environments'] = environments
        if format is not None:
            kwargs['format'] = format
        if git_source is not None:
            kwargs['git_source'] = git_source
        if health is not None:
            kwargs['health'] = health
        if job_clusters is not None:
            kwargs['job_clusters'] = job_clusters
        if max_concurrent_runs is not None:
            kwargs['max_concurrent_runs'] = max_concurrent_runs
        if name is not None:
            kwargs['name'] = name
        if notification_settings is not None:
            kwargs['notification_settings'] = notification_settings
        if parameters is not None:
            kwargs['parameters'] = parameters
        if performance_target is not None:
            kwargs['performance_target'] = performance_target
        if queue is not None:
            kwargs['queue'] = queue
        if run_as is not None:
            kwargs['run_as'] = run_as
        if schedule is not None:
            kwargs['schedule'] = schedule
        if tags is not None:
            kwargs['tags'] = tags
        if tasks is not None:
            kwargs['tasks'] = tasks
        if timeout_seconds is not None:
            kwargs['timeout_seconds'] = timeout_seconds
        if trigger is not None:
            kwargs['trigger'] = trigger
        if usage_policy_id is not None:
            kwargs['usage_policy_id'] = usage_policy_id
        if webhook_notifications is not None:
            kwargs['webhook_notifications'] = webhook_notifications
        try:
            result = self._ws.jobs.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_delete(self, job_id: int) -> DatabricksResponse:
        """Deletes a job."""
        kwargs: Dict[str, Any] = {}
        kwargs['job_id'] = job_id
        try:
            result = self._ws.jobs.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_delete_run(self, run_id: int) -> DatabricksResponse:
        """Deletes a non-active run. Returns an error if the run is active."""
        kwargs: Dict[str, Any] = {}
        kwargs['run_id'] = run_id
        try:
            result = self._ws.jobs.delete_run(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_export_run(
        self,
        run_id: int,
        views_to_export: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Export and retrieve the job run task."""
        kwargs: Dict[str, Any] = {}
        kwargs['run_id'] = run_id
        if views_to_export is not None:
            kwargs['views_to_export'] = views_to_export
        try:
            result = self._ws.jobs.export_run(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_get(self, job_id: int, page_token: Optional[str] = None) -> DatabricksResponse:
        """Get a single job."""
        kwargs: Dict[str, Any] = {}
        kwargs['job_id'] = job_id
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = self._ws.jobs.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_get_permission_levels(self, job_id: str) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        kwargs['job_id'] = job_id
        try:
            result = self._ws.jobs.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_get_permissions(self, job_id: str) -> DatabricksResponse:
        """Gets the permissions of a job. Jobs can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['job_id'] = job_id
        try:
            result = self._ws.jobs.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_get_run(
        self,
        run_id: int,
        include_history: Optional[bool] = None,
        include_resolved_values: Optional[bool] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Get a single job run."""
        kwargs: Dict[str, Any] = {}
        kwargs['run_id'] = run_id
        if include_history is not None:
            kwargs['include_history'] = include_history
        if include_resolved_values is not None:
            kwargs['include_resolved_values'] = include_resolved_values
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = self._ws.jobs.get_run(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_get_run_output(self, run_id: int) -> DatabricksResponse:
        """Retrieve the output and metadata of a single task run. When a notebook task returns a value through the `dbutils.notebook.exit()` call, you can use this endpoint to retrieve that value. Databricks ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['run_id'] = run_id
        try:
            result = self._ws.jobs.get_run_output(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_list(
        self,
        expand_tasks: Optional[bool] = None,
        limit: Optional[int] = None,
        name: Optional[str] = None,
        offset: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List jobs."""
        kwargs: Dict[str, Any] = {}
        if expand_tasks is not None:
            kwargs['expand_tasks'] = expand_tasks
        if limit is not None:
            kwargs['limit'] = limit
        if name is not None:
            kwargs['name'] = name
        if offset is not None:
            kwargs['offset'] = offset
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.jobs.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_list_runs(
        self,
        active_only: Optional[bool] = None,
        completed_only: Optional[bool] = None,
        expand_tasks: Optional[bool] = None,
        job_id: Optional[int] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        page_token: Optional[str] = None,
        run_type: Optional[Dict[str, Any]] = None,
        start_time_from: Optional[int] = None,
        start_time_to: Optional[int] = None,
    ) -> DatabricksResponse:
        """List job runs."""
        kwargs: Dict[str, Any] = {}
        if active_only is not None:
            kwargs['active_only'] = active_only
        if completed_only is not None:
            kwargs['completed_only'] = completed_only
        if expand_tasks is not None:
            kwargs['expand_tasks'] = expand_tasks
        if job_id is not None:
            kwargs['job_id'] = job_id
        if limit is not None:
            kwargs['limit'] = limit
        if offset is not None:
            kwargs['offset'] = offset
        if page_token is not None:
            kwargs['page_token'] = page_token
        if run_type is not None:
            kwargs['run_type'] = run_type
        if start_time_from is not None:
            kwargs['start_time_from'] = start_time_from
        if start_time_to is not None:
            kwargs['start_time_to'] = start_time_to
        try:
            result = list(self._ws.jobs.list_runs(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_repair_run(
        self,
        run_id: int,
        dbt_commands: Optional[List[str]] = None,
        jar_params: Optional[List[str]] = None,
        job_parameters: Optional[Dict[str, str]] = None,
        latest_repair_id: Optional[int] = None,
        notebook_params: Optional[Dict[str, str]] = None,
        performance_target: Optional[Dict[str, Any]] = None,
        pipeline_params: Optional[Dict[str, Any]] = None,
        python_named_params: Optional[Dict[str, str]] = None,
        python_params: Optional[List[str]] = None,
        rerun_all_failed_tasks: Optional[bool] = None,
        rerun_dependent_tasks: Optional[bool] = None,
        rerun_tasks: Optional[List[str]] = None,
        spark_submit_params: Optional[List[str]] = None,
        sql_params: Optional[Dict[str, str]] = None,
    ) -> DatabricksResponse:
        """Re-run one or more tasks. Tasks are re-run as part of the original job run. They use the current job and task settings, and can be viewed in the history for the original job run."""
        kwargs: Dict[str, Any] = {}
        kwargs['run_id'] = run_id
        if dbt_commands is not None:
            kwargs['dbt_commands'] = dbt_commands
        if jar_params is not None:
            kwargs['jar_params'] = jar_params
        if job_parameters is not None:
            kwargs['job_parameters'] = job_parameters
        if latest_repair_id is not None:
            kwargs['latest_repair_id'] = latest_repair_id
        if notebook_params is not None:
            kwargs['notebook_params'] = notebook_params
        if performance_target is not None:
            kwargs['performance_target'] = performance_target
        if pipeline_params is not None:
            kwargs['pipeline_params'] = pipeline_params
        if python_named_params is not None:
            kwargs['python_named_params'] = python_named_params
        if python_params is not None:
            kwargs['python_params'] = python_params
        if rerun_all_failed_tasks is not None:
            kwargs['rerun_all_failed_tasks'] = rerun_all_failed_tasks
        if rerun_dependent_tasks is not None:
            kwargs['rerun_dependent_tasks'] = rerun_dependent_tasks
        if rerun_tasks is not None:
            kwargs['rerun_tasks'] = rerun_tasks
        if spark_submit_params is not None:
            kwargs['spark_submit_params'] = spark_submit_params
        if sql_params is not None:
            kwargs['sql_params'] = sql_params
        try:
            result = self._ws.jobs.repair_run(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_reset(self, job_id: int, new_settings: Dict[str, Any]) -> DatabricksResponse:
        """Overwrite all settings for the given job. Use the [_Update_ endpoint](:method:jobs/update) to update job settings partially."""
        kwargs: Dict[str, Any] = {}
        kwargs['job_id'] = job_id
        kwargs['new_settings'] = new_settings
        try:
            result = self._ws.jobs.reset(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_run_now(
        self,
        job_id: int,
        dbt_commands: Optional[List[str]] = None,
        idempotency_token: Optional[str] = None,
        jar_params: Optional[List[str]] = None,
        job_parameters: Optional[Dict[str, str]] = None,
        notebook_params: Optional[Dict[str, str]] = None,
        only: Optional[List[str]] = None,
        performance_target: Optional[Dict[str, Any]] = None,
        pipeline_params: Optional[Dict[str, Any]] = None,
        python_named_params: Optional[Dict[str, str]] = None,
        python_params: Optional[List[str]] = None,
        queue: Optional[Dict[str, Any]] = None,
        spark_submit_params: Optional[List[str]] = None,
        sql_params: Optional[Dict[str, str]] = None,
    ) -> DatabricksResponse:
        """Run a job and return the `run_id` of the triggered run."""
        kwargs: Dict[str, Any] = {}
        kwargs['job_id'] = job_id
        if dbt_commands is not None:
            kwargs['dbt_commands'] = dbt_commands
        if idempotency_token is not None:
            kwargs['idempotency_token'] = idempotency_token
        if jar_params is not None:
            kwargs['jar_params'] = jar_params
        if job_parameters is not None:
            kwargs['job_parameters'] = job_parameters
        if notebook_params is not None:
            kwargs['notebook_params'] = notebook_params
        if only is not None:
            kwargs['only'] = only
        if performance_target is not None:
            kwargs['performance_target'] = performance_target
        if pipeline_params is not None:
            kwargs['pipeline_params'] = pipeline_params
        if python_named_params is not None:
            kwargs['python_named_params'] = python_named_params
        if python_params is not None:
            kwargs['python_params'] = python_params
        if queue is not None:
            kwargs['queue'] = queue
        if spark_submit_params is not None:
            kwargs['spark_submit_params'] = spark_submit_params
        if sql_params is not None:
            kwargs['sql_params'] = sql_params
        try:
            result = self._ws.jobs.run_now(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_set_permissions(
        self,
        job_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['job_id'] = job_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.jobs.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_submit(
        self,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
        budget_policy_id: Optional[str] = None,
        email_notifications: Optional[Dict[str, Any]] = None,
        environments: Optional[List[Dict[str, Any]]] = None,
        git_source: Optional[Dict[str, Any]] = None,
        health: Optional[Dict[str, Any]] = None,
        idempotency_token: Optional[str] = None,
        notification_settings: Optional[Dict[str, Any]] = None,
        queue: Optional[Dict[str, Any]] = None,
        run_as: Optional[Dict[str, Any]] = None,
        run_name: Optional[str] = None,
        tasks: Optional[List[Dict[str, Any]]] = None,
        timeout_seconds: Optional[int] = None,
        usage_policy_id: Optional[str] = None,
        webhook_notifications: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Submit a one-time run. This endpoint allows you to submit a workload directly without creating a job. Runs submitted using this endpoint don’t display in the UI. Use the `jobs/runs/get` API to chec..."""
        kwargs: Dict[str, Any] = {}
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        if budget_policy_id is not None:
            kwargs['budget_policy_id'] = budget_policy_id
        if email_notifications is not None:
            kwargs['email_notifications'] = email_notifications
        if environments is not None:
            kwargs['environments'] = environments
        if git_source is not None:
            kwargs['git_source'] = git_source
        if health is not None:
            kwargs['health'] = health
        if idempotency_token is not None:
            kwargs['idempotency_token'] = idempotency_token
        if notification_settings is not None:
            kwargs['notification_settings'] = notification_settings
        if queue is not None:
            kwargs['queue'] = queue
        if run_as is not None:
            kwargs['run_as'] = run_as
        if run_name is not None:
            kwargs['run_name'] = run_name
        if tasks is not None:
            kwargs['tasks'] = tasks
        if timeout_seconds is not None:
            kwargs['timeout_seconds'] = timeout_seconds
        if usage_policy_id is not None:
            kwargs['usage_policy_id'] = usage_policy_id
        if webhook_notifications is not None:
            kwargs['webhook_notifications'] = webhook_notifications
        try:
            result = self._ws.jobs.submit(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_update(
        self,
        job_id: int,
        fields_to_remove: Optional[List[str]] = None,
        new_settings: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Add, update, or remove specific settings of an existing job. Use the [_Reset_ endpoint](:method:jobs/reset) to overwrite all job settings."""
        kwargs: Dict[str, Any] = {}
        kwargs['job_id'] = job_id
        if fields_to_remove is not None:
            kwargs['fields_to_remove'] = fields_to_remove
        if new_settings is not None:
            kwargs['new_settings'] = new_settings
        try:
            result = self._ws.jobs.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def jobs_update_permissions(
        self,
        job_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on a job. Jobs can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['job_id'] = job_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.jobs.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # LAKEVIEW (LakeviewAPI) — 18 methods
    # ============================================================================

    async def lakeview_create(
        self,
        dashboard: Dict[str, Any],
        dataset_catalog: Optional[str] = None,
        dataset_schema: Optional[str] = None,
    ) -> DatabricksResponse:
        """Create a draft dashboard."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard'] = dashboard
        if dataset_catalog is not None:
            kwargs['dataset_catalog'] = dataset_catalog
        if dataset_schema is not None:
            kwargs['dataset_schema'] = dataset_schema
        try:
            result = self._ws.lakeview.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_create_schedule(self, dashboard_id: str, schedule: Dict[str, Any]) -> DatabricksResponse:
        """Create dashboard schedule."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        kwargs['schedule'] = schedule
        try:
            result = self._ws.lakeview.create_schedule(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_create_subscription(
        self,
        dashboard_id: str,
        schedule_id: str,
        subscription: Dict[str, Any],
    ) -> DatabricksResponse:
        """Create schedule subscription."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        kwargs['schedule_id'] = schedule_id
        kwargs['subscription'] = subscription
        try:
            result = self._ws.lakeview.create_subscription(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_delete_schedule(
        self,
        dashboard_id: str,
        schedule_id: str,
        etag: Optional[str] = None,
    ) -> DatabricksResponse:
        """Delete dashboard schedule."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        kwargs['schedule_id'] = schedule_id
        if etag is not None:
            kwargs['etag'] = etag
        try:
            result = self._ws.lakeview.delete_schedule(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_delete_subscription(
        self,
        dashboard_id: str,
        schedule_id: str,
        subscription_id: str,
        etag: Optional[str] = None,
    ) -> DatabricksResponse:
        """Delete schedule subscription."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        kwargs['schedule_id'] = schedule_id
        kwargs['subscription_id'] = subscription_id
        if etag is not None:
            kwargs['etag'] = etag
        try:
            result = self._ws.lakeview.delete_subscription(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_get(self, dashboard_id: str) -> DatabricksResponse:
        """Get a draft dashboard."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        try:
            result = self._ws.lakeview.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_get_published(self, dashboard_id: str) -> DatabricksResponse:
        """Get the current published dashboard."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        try:
            result = self._ws.lakeview.get_published(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_get_schedule(self, dashboard_id: str, schedule_id: str) -> DatabricksResponse:
        """Get dashboard schedule."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        kwargs['schedule_id'] = schedule_id
        try:
            result = self._ws.lakeview.get_schedule(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_get_subscription(
        self,
        dashboard_id: str,
        schedule_id: str,
        subscription_id: str,
    ) -> DatabricksResponse:
        """Get schedule subscription."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        kwargs['schedule_id'] = schedule_id
        kwargs['subscription_id'] = subscription_id
        try:
            result = self._ws.lakeview.get_subscription(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_list(
        self,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        show_trashed: Optional[bool] = None,
        view: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """List dashboards."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        if show_trashed is not None:
            kwargs['show_trashed'] = show_trashed
        if view is not None:
            kwargs['view'] = view
        try:
            result = list(self._ws.lakeview.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_list_schedules(
        self,
        dashboard_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List dashboard schedules."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.lakeview.list_schedules(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_list_subscriptions(
        self,
        dashboard_id: str,
        schedule_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List schedule subscriptions."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        kwargs['schedule_id'] = schedule_id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.lakeview.list_subscriptions(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_migrate(
        self,
        source_dashboard_id: str,
        display_name: Optional[str] = None,
        parent_path: Optional[str] = None,
        update_parameter_syntax: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Migrates a classic SQL dashboard to Lakeview."""
        kwargs: Dict[str, Any] = {}
        kwargs['source_dashboard_id'] = source_dashboard_id
        if display_name is not None:
            kwargs['display_name'] = display_name
        if parent_path is not None:
            kwargs['parent_path'] = parent_path
        if update_parameter_syntax is not None:
            kwargs['update_parameter_syntax'] = update_parameter_syntax
        try:
            result = self._ws.lakeview.migrate(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_publish(
        self,
        dashboard_id: str,
        embed_credentials: Optional[bool] = None,
        warehouse_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Publish the current draft dashboard."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        if embed_credentials is not None:
            kwargs['embed_credentials'] = embed_credentials
        if warehouse_id is not None:
            kwargs['warehouse_id'] = warehouse_id
        try:
            result = self._ws.lakeview.publish(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_trash(self, dashboard_id: str) -> DatabricksResponse:
        """Trash a dashboard."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        try:
            result = self._ws.lakeview.trash(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_unpublish(self, dashboard_id: str) -> DatabricksResponse:
        """Unpublish the dashboard."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        try:
            result = self._ws.lakeview.unpublish(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_update(
        self,
        dashboard_id: str,
        dashboard: Dict[str, Any],
        dataset_catalog: Optional[str] = None,
        dataset_schema: Optional[str] = None,
    ) -> DatabricksResponse:
        """Update a draft dashboard."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        kwargs['dashboard'] = dashboard
        if dataset_catalog is not None:
            kwargs['dataset_catalog'] = dataset_catalog
        if dataset_schema is not None:
            kwargs['dataset_schema'] = dataset_schema
        try:
            result = self._ws.lakeview.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def lakeview_update_schedule(
        self,
        dashboard_id: str,
        schedule_id: str,
        schedule: Dict[str, Any],
    ) -> DatabricksResponse:
        """Update dashboard schedule."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        kwargs['schedule_id'] = schedule_id
        kwargs['schedule'] = schedule
        try:
            result = self._ws.lakeview.update_schedule(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # LAKEVIEW EMBEDDED (LakeviewEmbeddedAPI) — 1 methods
    # ============================================================================

    async def lakeview_embedded_get_published_dashboard_token_info(
        self,
        dashboard_id: str,
        external_value: Optional[str] = None,
        external_viewer_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Get a required authorization details and scopes of a published dashboard to mint an OAuth token."""
        kwargs: Dict[str, Any] = {}
        kwargs['dashboard_id'] = dashboard_id
        if external_value is not None:
            kwargs['external_value'] = external_value
        if external_viewer_id is not None:
            kwargs['external_viewer_id'] = external_viewer_id
        try:
            result = self._ws.lakeview_embedded.get_published_dashboard_token_info(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # LIBRARIES (LibrariesAPI) — 4 methods
    # ============================================================================

    async def libraries_all_cluster_statuses(self) -> DatabricksResponse:
        """Get the status of all libraries on all clusters. A status is returned for all libraries installed on this cluster via the API or the libraries UI."""
        kwargs: Dict[str, Any] = {}
        try:
            result = list(self._ws.libraries.all_cluster_statuses(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def libraries_cluster_status(self, cluster_id: str) -> DatabricksResponse:
        """Get the status of libraries on a cluster. A status is returned for all libraries installed on this cluster via the API or the libraries UI. The order of returned libraries is as follows: 1. Librari..."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        try:
            result = list(self._ws.libraries.cluster_status(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def libraries_install(self, cluster_id: str, libraries: List[Dict[str, Any]]) -> DatabricksResponse:
        """Add libraries to install on a cluster. The installation is asynchronous; it happens in the background after the completion of this request."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        kwargs['libraries'] = libraries
        try:
            result = self._ws.libraries.install(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def libraries_uninstall(self, cluster_id: str, libraries: List[Dict[str, Any]]) -> DatabricksResponse:
        """Set libraries to uninstall from a cluster. The libraries won't be uninstalled until the cluster is restarted. A request to uninstall a library that is not currently installed is ignored."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        kwargs['libraries'] = libraries
        try:
            result = self._ws.libraries.uninstall(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # MATERIALIZED FEATURES (MaterializedFeaturesAPI) — 6 methods
    # ============================================================================

    async def materialized_features_create_feature_tag(
        self,
        table_name: str,
        feature_name: str,
        feature_tag: Dict[str, Any],
    ) -> DatabricksResponse:
        """Creates a FeatureTag."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        kwargs['feature_name'] = feature_name
        kwargs['feature_tag'] = feature_tag
        try:
            result = self._ws.materialized_features.create_feature_tag(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def materialized_features_delete_feature_tag(
        self,
        table_name: str,
        feature_name: str,
        key: str,
    ) -> DatabricksResponse:
        """Deletes a FeatureTag."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        kwargs['feature_name'] = feature_name
        kwargs['key'] = key
        try:
            result = self._ws.materialized_features.delete_feature_tag(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def materialized_features_get_feature_lineage(self, table_name: str, feature_name: str) -> DatabricksResponse:
        """Get Feature Lineage."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        kwargs['feature_name'] = feature_name
        try:
            result = self._ws.materialized_features.get_feature_lineage(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def materialized_features_get_feature_tag(
        self,
        table_name: str,
        feature_name: str,
        key: str,
    ) -> DatabricksResponse:
        """Gets a FeatureTag."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        kwargs['feature_name'] = feature_name
        kwargs['key'] = key
        try:
            result = self._ws.materialized_features.get_feature_tag(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def materialized_features_list_feature_tags(
        self,
        table_name: str,
        feature_name: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Lists FeatureTags."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        kwargs['feature_name'] = feature_name
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.materialized_features.list_feature_tags(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def materialized_features_update_feature_tag(
        self,
        table_name: str,
        feature_name: str,
        key: str,
        feature_tag: Dict[str, Any],
        update_mask: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates a FeatureTag."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        kwargs['feature_name'] = feature_name
        kwargs['key'] = key
        kwargs['feature_tag'] = feature_tag
        if update_mask is not None:
            kwargs['update_mask'] = update_mask
        try:
            result = self._ws.materialized_features.update_feature_tag(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # METASTORES (MetastoresAPI) — 10 methods
    # ============================================================================

    async def metastores_assign(
        self,
        workspace_id: int,
        metastore_id: str,
        default_catalog_name: str,
    ) -> DatabricksResponse:
        """Creates a new metastore assignment. If an assignment for the same __workspace_id__ exists, it will be overwritten by the new __metastore_id__ and __default_catalog_name__. The caller must be an acc..."""
        kwargs: Dict[str, Any] = {}
        kwargs['workspace_id'] = workspace_id
        kwargs['metastore_id'] = metastore_id
        kwargs['default_catalog_name'] = default_catalog_name
        try:
            result = self._ws.metastores.assign(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def metastores_create(
        self,
        name: str,
        external_access_enabled: Optional[bool] = None,
        region: Optional[str] = None,
        storage_root: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new metastore based on a provided name and optional storage root path. By default (if the __owner__ field is not set), the owner of the new metastore is the user calling the __createMetas..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if external_access_enabled is not None:
            kwargs['external_access_enabled'] = external_access_enabled
        if region is not None:
            kwargs['region'] = region
        if storage_root is not None:
            kwargs['storage_root'] = storage_root
        try:
            result = self._ws.metastores.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def metastores_current(self) -> DatabricksResponse:
        """Gets the metastore assignment for the workspace being accessed."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.metastores.current(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def metastores_delete(self, id: str, force: Optional[bool] = None) -> DatabricksResponse:
        """Deletes a metastore. The caller must be a metastore admin."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if force is not None:
            kwargs['force'] = force
        try:
            result = self._ws.metastores.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def metastores_get(self, id: str) -> DatabricksResponse:
        """Gets a metastore that matches the supplied ID. The caller must be a metastore admin to retrieve this info."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.metastores.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def metastores_list(self, max_results: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Gets an array of the available metastores (as __MetastoreInfo__ objects). The caller must be an admin to retrieve this info. There is no guarantee of a specific ordering of the elements in the array."""
        kwargs: Dict[str, Any] = {}
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.metastores.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def metastores_summary(self) -> DatabricksResponse:
        """Gets information about a metastore. This summary includes the storage credential, the cloud vendor, the cloud region, and the global metastore ID."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.metastores.summary(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def metastores_unassign(self, workspace_id: int, metastore_id: str) -> DatabricksResponse:
        """Deletes a metastore assignment. The caller must be an account administrator."""
        kwargs: Dict[str, Any] = {}
        kwargs['workspace_id'] = workspace_id
        kwargs['metastore_id'] = metastore_id
        try:
            result = self._ws.metastores.unassign(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def metastores_update(
        self,
        id: str,
        delta_sharing_organization_name: Optional[str] = None,
        delta_sharing_recipient_token_lifetime_in_seconds: Optional[int] = None,
        delta_sharing_scope: Optional[Dict[str, Any]] = None,
        external_access_enabled: Optional[bool] = None,
        new_name: Optional[str] = None,
        owner: Optional[str] = None,
        privilege_model_version: Optional[str] = None,
        storage_root_credential_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates information for a specific metastore. The caller must be a metastore admin. If the __owner__ field is set to the empty string (**""**), the ownership is updated to the System User."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if delta_sharing_organization_name is not None:
            kwargs['delta_sharing_organization_name'] = delta_sharing_organization_name
        if delta_sharing_recipient_token_lifetime_in_seconds is not None:
            kwargs['delta_sharing_recipient_token_lifetime_in_seconds'] = delta_sharing_recipient_token_lifetime_in_seconds
        if delta_sharing_scope is not None:
            kwargs['delta_sharing_scope'] = delta_sharing_scope
        if external_access_enabled is not None:
            kwargs['external_access_enabled'] = external_access_enabled
        if new_name is not None:
            kwargs['new_name'] = new_name
        if owner is not None:
            kwargs['owner'] = owner
        if privilege_model_version is not None:
            kwargs['privilege_model_version'] = privilege_model_version
        if storage_root_credential_id is not None:
            kwargs['storage_root_credential_id'] = storage_root_credential_id
        try:
            result = self._ws.metastores.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def metastores_update_assignment(
        self,
        workspace_id: int,
        default_catalog_name: Optional[str] = None,
        metastore_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates a metastore assignment. This operation can be used to update __metastore_id__ or __default_catalog_name__ for a specified Workspace, if the Workspace is already assigned a metastore. The ca..."""
        kwargs: Dict[str, Any] = {}
        kwargs['workspace_id'] = workspace_id
        if default_catalog_name is not None:
            kwargs['default_catalog_name'] = default_catalog_name
        if metastore_id is not None:
            kwargs['metastore_id'] = metastore_id
        try:
            result = self._ws.metastores.update_assignment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # MODEL REGISTRY (ModelRegistryAPI) — 36 methods
    # ============================================================================

    async def model_registry_approve_transition_request(
        self,
        name: str,
        version: str,
        stage: str,
        archive_existing_versions: bool,
        comment: Optional[str] = None,
    ) -> DatabricksResponse:
        """Approves a model version stage transition request."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['version'] = version
        kwargs['stage'] = stage
        kwargs['archive_existing_versions'] = archive_existing_versions
        if comment is not None:
            kwargs['comment'] = comment
        try:
            result = self._ws.model_registry.approve_transition_request(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_create_comment(
        self,
        name: str,
        version: str,
        comment: str,
    ) -> DatabricksResponse:
        """Posts a comment on a model version. A comment can be submitted either by a user or programmatically to display relevant information about the model. For example, test results or deployment errors."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['version'] = version
        kwargs['comment'] = comment
        try:
            result = self._ws.model_registry.create_comment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_create_model(
        self,
        name: str,
        description: Optional[str] = None,
        tags: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Creates a new registered model with the name specified in the request body. Throws `RESOURCE_ALREADY_EXISTS` if a registered model with the given name exists."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if description is not None:
            kwargs['description'] = description
        if tags is not None:
            kwargs['tags'] = tags
        try:
            result = self._ws.model_registry.create_model(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_create_model_version(
        self,
        name: str,
        source: str,
        description: Optional[str] = None,
        run_id: Optional[str] = None,
        run_link: Optional[str] = None,
        tags: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Creates a model version."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['source'] = source
        if description is not None:
            kwargs['description'] = description
        if run_id is not None:
            kwargs['run_id'] = run_id
        if run_link is not None:
            kwargs['run_link'] = run_link
        if tags is not None:
            kwargs['tags'] = tags
        try:
            result = self._ws.model_registry.create_model_version(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_create_transition_request(
        self,
        name: str,
        version: str,
        stage: str,
        comment: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a model version stage transition request."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['version'] = version
        kwargs['stage'] = stage
        if comment is not None:
            kwargs['comment'] = comment
        try:
            result = self._ws.model_registry.create_transition_request(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_create_webhook(
        self,
        events: List[Dict[str, Any]],
        description: Optional[str] = None,
        http_url_spec: Optional[Dict[str, Any]] = None,
        job_spec: Optional[Dict[str, Any]] = None,
        model_name: Optional[str] = None,
        status: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """**NOTE:** This endpoint is in Public Preview. Creates a registry webhook."""
        kwargs: Dict[str, Any] = {}
        kwargs['events'] = events
        if description is not None:
            kwargs['description'] = description
        if http_url_spec is not None:
            kwargs['http_url_spec'] = http_url_spec
        if job_spec is not None:
            kwargs['job_spec'] = job_spec
        if model_name is not None:
            kwargs['model_name'] = model_name
        if status is not None:
            kwargs['status'] = status
        try:
            result = self._ws.model_registry.create_webhook(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_delete_comment(self, id: str) -> DatabricksResponse:
        """Deletes a comment on a model version."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.model_registry.delete_comment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_delete_model(self, name: str) -> DatabricksResponse:
        """Deletes a registered model."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.model_registry.delete_model(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_delete_model_tag(self, name: str, key: str) -> DatabricksResponse:
        """Deletes the tag for a registered model."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['key'] = key
        try:
            result = self._ws.model_registry.delete_model_tag(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_delete_model_version(self, name: str, version: str) -> DatabricksResponse:
        """Deletes a model version."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['version'] = version
        try:
            result = self._ws.model_registry.delete_model_version(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_delete_model_version_tag(
        self,
        name: str,
        version: str,
        key: str,
    ) -> DatabricksResponse:
        """Deletes a model version tag."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['version'] = version
        kwargs['key'] = key
        try:
            result = self._ws.model_registry.delete_model_version_tag(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_delete_transition_request(
        self,
        name: str,
        version: str,
        stage: str,
        creator: str,
        comment: Optional[str] = None,
    ) -> DatabricksResponse:
        """Cancels a model version stage transition request."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['version'] = version
        kwargs['stage'] = stage
        kwargs['creator'] = creator
        if comment is not None:
            kwargs['comment'] = comment
        try:
            result = self._ws.model_registry.delete_transition_request(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_delete_webhook(self, id: str) -> DatabricksResponse:
        """**NOTE:** This endpoint is in Public Preview. Deletes a registry webhook."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.model_registry.delete_webhook(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_get_latest_versions(self, name: str, stages: Optional[List[str]] = None) -> DatabricksResponse:
        """Gets the latest version of a registered model."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if stages is not None:
            kwargs['stages'] = stages
        try:
            result = list(self._ws.model_registry.get_latest_versions(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_get_model(self, name: str) -> DatabricksResponse:
        """Get the details of a model. This is a Databricks workspace version of the [MLflow endpoint] that also returns the model's Databricks workspace ID and the permission level of the requesting user on ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.model_registry.get_model(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_get_model_version(self, name: str, version: str) -> DatabricksResponse:
        """Get a model version."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['version'] = version
        try:
            result = self._ws.model_registry.get_model_version(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_get_model_version_download_uri(self, name: str, version: str) -> DatabricksResponse:
        """Gets a URI to download the model version."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['version'] = version
        try:
            result = self._ws.model_registry.get_model_version_download_uri(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_get_permission_levels(self, registered_model_id: str) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        kwargs['registered_model_id'] = registered_model_id
        try:
            result = self._ws.model_registry.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_get_permissions(self, registered_model_id: str) -> DatabricksResponse:
        """Gets the permissions of a registered model. Registered models can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['registered_model_id'] = registered_model_id
        try:
            result = self._ws.model_registry.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_list_models(self, max_results: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Lists all available registered models, up to the limit specified in __max_results__."""
        kwargs: Dict[str, Any] = {}
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.model_registry.list_models(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_list_transition_requests(self, name: str, version: str) -> DatabricksResponse:
        """Gets a list of all open stage transition requests for the model version."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['version'] = version
        try:
            result = list(self._ws.model_registry.list_transition_requests(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_list_webhooks(
        self,
        events: Optional[List[Dict[str, Any]]] = None,
        max_results: Optional[int] = None,
        model_name: Optional[str] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """**NOTE:** This endpoint is in Public Preview. Lists all registry webhooks."""
        kwargs: Dict[str, Any] = {}
        if events is not None:
            kwargs['events'] = events
        if max_results is not None:
            kwargs['max_results'] = max_results
        if model_name is not None:
            kwargs['model_name'] = model_name
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.model_registry.list_webhooks(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_reject_transition_request(
        self,
        name: str,
        version: str,
        stage: str,
        comment: Optional[str] = None,
    ) -> DatabricksResponse:
        """Rejects a model version stage transition request."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['version'] = version
        kwargs['stage'] = stage
        if comment is not None:
            kwargs['comment'] = comment
        try:
            result = self._ws.model_registry.reject_transition_request(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_rename_model(self, name: str, new_name: Optional[str] = None) -> DatabricksResponse:
        """Renames a registered model."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if new_name is not None:
            kwargs['new_name'] = new_name
        try:
            result = self._ws.model_registry.rename_model(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_search_model_versions(
        self,
        filter: Optional[str] = None,
        max_results: Optional[int] = None,
        order_by: Optional[List[str]] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Searches for specific model versions based on the supplied __filter__."""
        kwargs: Dict[str, Any] = {}
        if filter is not None:
            kwargs['filter'] = filter
        if max_results is not None:
            kwargs['max_results'] = max_results
        if order_by is not None:
            kwargs['order_by'] = order_by
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.model_registry.search_model_versions(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_search_models(
        self,
        filter: Optional[str] = None,
        max_results: Optional[int] = None,
        order_by: Optional[List[str]] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Search for registered models based on the specified __filter__."""
        kwargs: Dict[str, Any] = {}
        if filter is not None:
            kwargs['filter'] = filter
        if max_results is not None:
            kwargs['max_results'] = max_results
        if order_by is not None:
            kwargs['order_by'] = order_by
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.model_registry.search_models(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_set_model_tag(
        self,
        name: str,
        key: str,
        value: str,
    ) -> DatabricksResponse:
        """Sets a tag on a registered model."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['key'] = key
        kwargs['value'] = value
        try:
            result = self._ws.model_registry.set_model_tag(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_set_model_version_tag(
        self,
        name: str,
        version: str,
        key: str,
        value: str,
    ) -> DatabricksResponse:
        """Sets a model version tag."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['version'] = version
        kwargs['key'] = key
        kwargs['value'] = value
        try:
            result = self._ws.model_registry.set_model_version_tag(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_set_permissions(
        self,
        registered_model_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['registered_model_id'] = registered_model_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.model_registry.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_test_registry_webhook(self, id: str, event: Optional[Dict[str, Any]] = None) -> DatabricksResponse:
        """**NOTE:** This endpoint is in Public Preview. Tests a registry webhook."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if event is not None:
            kwargs['event'] = event
        try:
            result = self._ws.model_registry.test_registry_webhook(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_transition_stage(
        self,
        name: str,
        version: str,
        stage: str,
        archive_existing_versions: bool,
        comment: Optional[str] = None,
    ) -> DatabricksResponse:
        """Transition a model version's stage. This is a Databricks workspace version of the [MLflow endpoint] that also accepts a comment associated with the transition to be recorded."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['version'] = version
        kwargs['stage'] = stage
        kwargs['archive_existing_versions'] = archive_existing_versions
        if comment is not None:
            kwargs['comment'] = comment
        try:
            result = self._ws.model_registry.transition_stage(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_update_comment(self, id: str, comment: str) -> DatabricksResponse:
        """Post an edit to a comment on a model version."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        kwargs['comment'] = comment
        try:
            result = self._ws.model_registry.update_comment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_update_model(self, name: str, description: Optional[str] = None) -> DatabricksResponse:
        """Updates a registered model."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if description is not None:
            kwargs['description'] = description
        try:
            result = self._ws.model_registry.update_model(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_update_model_version(
        self,
        name: str,
        version: str,
        description: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates the model version."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['version'] = version
        if description is not None:
            kwargs['description'] = description
        try:
            result = self._ws.model_registry.update_model_version(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_update_permissions(
        self,
        registered_model_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on a registered model. Registered models can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['registered_model_id'] = registered_model_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.model_registry.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_registry_update_webhook(
        self,
        id: str,
        description: Optional[str] = None,
        events: Optional[List[Dict[str, Any]]] = None,
        http_url_spec: Optional[Dict[str, Any]] = None,
        job_spec: Optional[Dict[str, Any]] = None,
        status: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """**NOTE:** This endpoint is in Public Preview. Updates a registry webhook."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if description is not None:
            kwargs['description'] = description
        if events is not None:
            kwargs['events'] = events
        if http_url_spec is not None:
            kwargs['http_url_spec'] = http_url_spec
        if job_spec is not None:
            kwargs['job_spec'] = job_spec
        if status is not None:
            kwargs['status'] = status
        try:
            result = self._ws.model_registry.update_webhook(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # MODEL VERSIONS (ModelVersionsAPI) — 5 methods
    # ============================================================================

    async def model_versions_delete(self, full_name: str, version: int) -> DatabricksResponse:
        """Deletes a model version from the specified registered model. Any aliases assigned to the model version will also be deleted."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        kwargs['version'] = version
        try:
            result = self._ws.model_versions.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_versions_get(
        self,
        full_name: str,
        version: int,
        include_aliases: Optional[bool] = None,
        include_browse: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Get a model version."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        kwargs['version'] = version
        if include_aliases is not None:
            kwargs['include_aliases'] = include_aliases
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        try:
            result = self._ws.model_versions.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_versions_get_by_alias(
        self,
        full_name: str,
        alias: str,
        include_aliases: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Get a model version by alias."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        kwargs['alias'] = alias
        if include_aliases is not None:
            kwargs['include_aliases'] = include_aliases
        try:
            result = self._ws.model_versions.get_by_alias(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_versions_list(
        self,
        full_name: str,
        include_browse: Optional[bool] = None,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List model versions. You can list model versions under a particular schema, or list all model versions in the current metastore."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.model_versions.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def model_versions_update(
        self,
        full_name: str,
        version: int,
        aliases: Optional[List[Dict[str, Any]]] = None,
        catalog_name: Optional[str] = None,
        comment: Optional[str] = None,
        created_at: Optional[int] = None,
        created_by: Optional[str] = None,
        id: Optional[str] = None,
        metastore_id: Optional[str] = None,
        model_name: Optional[str] = None,
        model_version_dependencies: Optional[Dict[str, Any]] = None,
        run_id: Optional[str] = None,
        run_workspace_id: Optional[int] = None,
        schema_name: Optional[str] = None,
        source: Optional[str] = None,
        status: Optional[Dict[str, Any]] = None,
        storage_location: Optional[str] = None,
        updated_at: Optional[int] = None,
        updated_by: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates the specified model version."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        kwargs['version'] = version
        if aliases is not None:
            kwargs['aliases'] = aliases
        if catalog_name is not None:
            kwargs['catalog_name'] = catalog_name
        if comment is not None:
            kwargs['comment'] = comment
        if created_at is not None:
            kwargs['created_at'] = created_at
        if created_by is not None:
            kwargs['created_by'] = created_by
        if id is not None:
            kwargs['id'] = id
        if metastore_id is not None:
            kwargs['metastore_id'] = metastore_id
        if model_name is not None:
            kwargs['model_name'] = model_name
        if model_version_dependencies is not None:
            kwargs['model_version_dependencies'] = model_version_dependencies
        if run_id is not None:
            kwargs['run_id'] = run_id
        if run_workspace_id is not None:
            kwargs['run_workspace_id'] = run_workspace_id
        if schema_name is not None:
            kwargs['schema_name'] = schema_name
        if source is not None:
            kwargs['source'] = source
        if status is not None:
            kwargs['status'] = status
        if storage_location is not None:
            kwargs['storage_location'] = storage_location
        if updated_at is not None:
            kwargs['updated_at'] = updated_at
        if updated_by is not None:
            kwargs['updated_by'] = updated_by
        try:
            result = self._ws.model_versions.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # NOTIFICATION DESTINATIONS (NotificationDestinationsAPI) — 5 methods
    # ============================================================================

    async def notification_destinations_create(self, config: Optional[Dict[str, Any]] = None, display_name: Optional[str] = None) -> DatabricksResponse:
        """Creates a notification destination. Requires workspace admin permissions."""
        kwargs: Dict[str, Any] = {}
        if config is not None:
            kwargs['config'] = config
        if display_name is not None:
            kwargs['display_name'] = display_name
        try:
            result = self._ws.notification_destinations.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def notification_destinations_delete(self, id: str) -> DatabricksResponse:
        """Deletes a notification destination. Requires workspace admin permissions."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.notification_destinations.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def notification_destinations_get(self, id: str) -> DatabricksResponse:
        """Gets a notification destination."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.notification_destinations.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def notification_destinations_list(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Lists notification destinations."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.notification_destinations.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def notification_destinations_update(
        self,
        id: str,
        config: Optional[Dict[str, Any]] = None,
        display_name: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates a notification destination. Requires workspace admin permissions. At least one field is required in the request body."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if config is not None:
            kwargs['config'] = config
        if display_name is not None:
            kwargs['display_name'] = display_name
        try:
            result = self._ws.notification_destinations.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # ONLINE TABLES (OnlineTablesAPI) — 3 methods
    # ============================================================================

    async def online_tables_create(self, table: Dict[str, Any]) -> DatabricksResponse:
        """Create a new Online Table."""
        kwargs: Dict[str, Any] = {}
        kwargs['table'] = table
        try:
            result = self._ws.online_tables.create(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def online_tables_delete(self, name: str) -> DatabricksResponse:
        """Delete an online table. Warning: This will delete all the data in the online table. If the source Delta table was deleted or modified since this Online Table was created, this will lose the data fo..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.online_tables.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def online_tables_get(self, name: str) -> DatabricksResponse:
        """Get information about an existing online table and its status."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.online_tables.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # PERMISSION MIGRATION (PermissionMigrationAPI) — 1 methods
    # ============================================================================

    async def permission_migration_migrate_permissions(
        self,
        workspace_id: int,
        from_workspace_group_name: str,
        to_account_group_name: str,
        size: Optional[int] = None,
    ) -> DatabricksResponse:
        """Migrate Permissions."""
        kwargs: Dict[str, Any] = {}
        kwargs['workspace_id'] = workspace_id
        kwargs['from_workspace_group_name'] = from_workspace_group_name
        kwargs['to_account_group_name'] = to_account_group_name
        if size is not None:
            kwargs['size'] = size
        try:
            result = self._ws.permission_migration.migrate_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # PERMISSIONS (PermissionsAPI) — 4 methods
    # ============================================================================

    async def permissions_get(self, request_object_type: str, request_object_id: str) -> DatabricksResponse:
        """Gets the permissions of an object. Objects can inherit permissions from their parent objects or root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['request_object_type'] = request_object_type
        kwargs['request_object_id'] = request_object_id
        try:
            result = self._ws.permissions.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def permissions_get_permission_levels(self, request_object_type: str, request_object_id: str) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        kwargs['request_object_type'] = request_object_type
        kwargs['request_object_id'] = request_object_id
        try:
            result = self._ws.permissions.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def permissions_set(
        self,
        request_object_type: str,
        request_object_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their parent objects or root ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['request_object_type'] = request_object_type
        kwargs['request_object_id'] = request_object_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.permissions.set(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def permissions_update(
        self,
        request_object_type: str,
        request_object_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on an object. Objects can inherit permissions from their parent objects or root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['request_object_type'] = request_object_type
        kwargs['request_object_id'] = request_object_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.permissions.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # PIPELINES (PipelinesAPI) — 15 methods
    # ============================================================================

    async def pipelines_clone(
        self,
        pipeline_id: str,
        allow_duplicate_names: Optional[bool] = None,
        budget_policy_id: Optional[str] = None,
        catalog: Optional[str] = None,
        channel: Optional[str] = None,
        clone_mode: Optional[Dict[str, Any]] = None,
        clusters: Optional[List[Dict[str, Any]]] = None,
        configuration: Optional[Dict[str, str]] = None,
        continuous: Optional[bool] = None,
        deployment: Optional[Dict[str, Any]] = None,
        development: Optional[bool] = None,
        edition: Optional[str] = None,
        environment: Optional[Dict[str, Any]] = None,
        event_log: Optional[Dict[str, Any]] = None,
        expected_last_modified: Optional[int] = None,
        filters: Optional[Dict[str, Any]] = None,
        gateway_definition: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,
        ingestion_definition: Optional[Dict[str, Any]] = None,
        libraries: Optional[List[Dict[str, Any]]] = None,
        name: Optional[str] = None,
        notifications: Optional[List[Dict[str, Any]]] = None,
        photon: Optional[bool] = None,
        restart_window: Optional[Dict[str, Any]] = None,
        root_path: Optional[str] = None,
        schema: Optional[str] = None,
        serverless: Optional[bool] = None,
        storage: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        target: Optional[str] = None,
        trigger: Optional[Dict[str, Any]] = None,
        usage_policy_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new pipeline using Unity Catalog from a pipeline using Hive Metastore. This method returns the ID of the newly created clone. Additionally, this method starts an update for the newly crea..."""
        kwargs: Dict[str, Any] = {}
        kwargs['pipeline_id'] = pipeline_id
        if allow_duplicate_names is not None:
            kwargs['allow_duplicate_names'] = allow_duplicate_names
        if budget_policy_id is not None:
            kwargs['budget_policy_id'] = budget_policy_id
        if catalog is not None:
            kwargs['catalog'] = catalog
        if channel is not None:
            kwargs['channel'] = channel
        if clone_mode is not None:
            kwargs['clone_mode'] = clone_mode
        if clusters is not None:
            kwargs['clusters'] = clusters
        if configuration is not None:
            kwargs['configuration'] = configuration
        if continuous is not None:
            kwargs['continuous'] = continuous
        if deployment is not None:
            kwargs['deployment'] = deployment
        if development is not None:
            kwargs['development'] = development
        if edition is not None:
            kwargs['edition'] = edition
        if environment is not None:
            kwargs['environment'] = environment
        if event_log is not None:
            kwargs['event_log'] = event_log
        if expected_last_modified is not None:
            kwargs['expected_last_modified'] = expected_last_modified
        if filters is not None:
            kwargs['filters'] = filters
        if gateway_definition is not None:
            kwargs['gateway_definition'] = gateway_definition
        if id is not None:
            kwargs['id'] = id
        if ingestion_definition is not None:
            kwargs['ingestion_definition'] = ingestion_definition
        if libraries is not None:
            kwargs['libraries'] = libraries
        if name is not None:
            kwargs['name'] = name
        if notifications is not None:
            kwargs['notifications'] = notifications
        if photon is not None:
            kwargs['photon'] = photon
        if restart_window is not None:
            kwargs['restart_window'] = restart_window
        if root_path is not None:
            kwargs['root_path'] = root_path
        if schema is not None:
            kwargs['schema'] = schema
        if serverless is not None:
            kwargs['serverless'] = serverless
        if storage is not None:
            kwargs['storage'] = storage
        if tags is not None:
            kwargs['tags'] = tags
        if target is not None:
            kwargs['target'] = target
        if trigger is not None:
            kwargs['trigger'] = trigger
        if usage_policy_id is not None:
            kwargs['usage_policy_id'] = usage_policy_id
        try:
            result = self._ws.pipelines.clone(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def pipelines_create(
        self,
        allow_duplicate_names: Optional[bool] = None,
        budget_policy_id: Optional[str] = None,
        catalog: Optional[str] = None,
        channel: Optional[str] = None,
        clusters: Optional[List[Dict[str, Any]]] = None,
        configuration: Optional[Dict[str, str]] = None,
        continuous: Optional[bool] = None,
        deployment: Optional[Dict[str, Any]] = None,
        development: Optional[bool] = None,
        dry_run: Optional[bool] = None,
        edition: Optional[str] = None,
        environment: Optional[Dict[str, Any]] = None,
        event_log: Optional[Dict[str, Any]] = None,
        filters: Optional[Dict[str, Any]] = None,
        gateway_definition: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,
        ingestion_definition: Optional[Dict[str, Any]] = None,
        libraries: Optional[List[Dict[str, Any]]] = None,
        name: Optional[str] = None,
        notifications: Optional[List[Dict[str, Any]]] = None,
        photon: Optional[bool] = None,
        restart_window: Optional[Dict[str, Any]] = None,
        root_path: Optional[str] = None,
        run_as: Optional[Dict[str, Any]] = None,
        schema: Optional[str] = None,
        serverless: Optional[bool] = None,
        storage: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        target: Optional[str] = None,
        trigger: Optional[Dict[str, Any]] = None,
        usage_policy_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new data processing pipeline based on the requested configuration. If successful, this method returns the ID of the new pipeline."""
        kwargs: Dict[str, Any] = {}
        if allow_duplicate_names is not None:
            kwargs['allow_duplicate_names'] = allow_duplicate_names
        if budget_policy_id is not None:
            kwargs['budget_policy_id'] = budget_policy_id
        if catalog is not None:
            kwargs['catalog'] = catalog
        if channel is not None:
            kwargs['channel'] = channel
        if clusters is not None:
            kwargs['clusters'] = clusters
        if configuration is not None:
            kwargs['configuration'] = configuration
        if continuous is not None:
            kwargs['continuous'] = continuous
        if deployment is not None:
            kwargs['deployment'] = deployment
        if development is not None:
            kwargs['development'] = development
        if dry_run is not None:
            kwargs['dry_run'] = dry_run
        if edition is not None:
            kwargs['edition'] = edition
        if environment is not None:
            kwargs['environment'] = environment
        if event_log is not None:
            kwargs['event_log'] = event_log
        if filters is not None:
            kwargs['filters'] = filters
        if gateway_definition is not None:
            kwargs['gateway_definition'] = gateway_definition
        if id is not None:
            kwargs['id'] = id
        if ingestion_definition is not None:
            kwargs['ingestion_definition'] = ingestion_definition
        if libraries is not None:
            kwargs['libraries'] = libraries
        if name is not None:
            kwargs['name'] = name
        if notifications is not None:
            kwargs['notifications'] = notifications
        if photon is not None:
            kwargs['photon'] = photon
        if restart_window is not None:
            kwargs['restart_window'] = restart_window
        if root_path is not None:
            kwargs['root_path'] = root_path
        if run_as is not None:
            kwargs['run_as'] = run_as
        if schema is not None:
            kwargs['schema'] = schema
        if serverless is not None:
            kwargs['serverless'] = serverless
        if storage is not None:
            kwargs['storage'] = storage
        if tags is not None:
            kwargs['tags'] = tags
        if target is not None:
            kwargs['target'] = target
        if trigger is not None:
            kwargs['trigger'] = trigger
        if usage_policy_id is not None:
            kwargs['usage_policy_id'] = usage_policy_id
        try:
            result = self._ws.pipelines.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def pipelines_delete(self, pipeline_id: str, force: Optional[bool] = None) -> DatabricksResponse:
        """Deletes a pipeline. If the pipeline publishes to Unity Catalog, pipeline deletion will cascade to all pipeline tables. Please reach out to Databricks support for assistance to undo this action."""
        kwargs: Dict[str, Any] = {}
        kwargs['pipeline_id'] = pipeline_id
        if force is not None:
            kwargs['force'] = force
        try:
            result = self._ws.pipelines.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def pipelines_get(self, pipeline_id: str) -> DatabricksResponse:
        """Get a pipeline."""
        kwargs: Dict[str, Any] = {}
        kwargs['pipeline_id'] = pipeline_id
        try:
            result = self._ws.pipelines.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def pipelines_get_permission_levels(self, pipeline_id: str) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        kwargs['pipeline_id'] = pipeline_id
        try:
            result = self._ws.pipelines.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def pipelines_get_permissions(self, pipeline_id: str) -> DatabricksResponse:
        """Gets the permissions of a pipeline. Pipelines can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['pipeline_id'] = pipeline_id
        try:
            result = self._ws.pipelines.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def pipelines_get_update(self, pipeline_id: str, update_id: str) -> DatabricksResponse:
        """Gets an update from an active pipeline."""
        kwargs: Dict[str, Any] = {}
        kwargs['pipeline_id'] = pipeline_id
        kwargs['update_id'] = update_id
        try:
            result = self._ws.pipelines.get_update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def pipelines_list_pipeline_events(
        self,
        pipeline_id: str,
        filter: Optional[str] = None,
        max_results: Optional[int] = None,
        order_by: Optional[List[str]] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Retrieves events for a pipeline."""
        kwargs: Dict[str, Any] = {}
        kwargs['pipeline_id'] = pipeline_id
        if filter is not None:
            kwargs['filter'] = filter
        if max_results is not None:
            kwargs['max_results'] = max_results
        if order_by is not None:
            kwargs['order_by'] = order_by
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.pipelines.list_pipeline_events(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def pipelines_list_pipelines(
        self,
        filter: Optional[str] = None,
        max_results: Optional[int] = None,
        order_by: Optional[List[str]] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Lists pipelines defined in the Spark Declarative Pipelines system."""
        kwargs: Dict[str, Any] = {}
        if filter is not None:
            kwargs['filter'] = filter
        if max_results is not None:
            kwargs['max_results'] = max_results
        if order_by is not None:
            kwargs['order_by'] = order_by
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.pipelines.list_pipelines(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def pipelines_list_updates(
        self,
        pipeline_id: str,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
        until_update_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """List updates for an active pipeline."""
        kwargs: Dict[str, Any] = {}
        kwargs['pipeline_id'] = pipeline_id
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        if until_update_id is not None:
            kwargs['until_update_id'] = until_update_id
        try:
            result = self._ws.pipelines.list_updates(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def pipelines_set_permissions(
        self,
        pipeline_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['pipeline_id'] = pipeline_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.pipelines.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def pipelines_start_update(
        self,
        pipeline_id: str,
        cause: Optional[Dict[str, Any]] = None,
        full_refresh: Optional[bool] = None,
        full_refresh_selection: Optional[List[str]] = None,
        refresh_selection: Optional[List[str]] = None,
        rewind_spec: Optional[Dict[str, Any]] = None,
        validate_only: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Starts a new update for the pipeline. If there is already an active update for the pipeline, the request will fail and the active update will remain running."""
        kwargs: Dict[str, Any] = {}
        kwargs['pipeline_id'] = pipeline_id
        if cause is not None:
            kwargs['cause'] = cause
        if full_refresh is not None:
            kwargs['full_refresh'] = full_refresh
        if full_refresh_selection is not None:
            kwargs['full_refresh_selection'] = full_refresh_selection
        if refresh_selection is not None:
            kwargs['refresh_selection'] = refresh_selection
        if rewind_spec is not None:
            kwargs['rewind_spec'] = rewind_spec
        if validate_only is not None:
            kwargs['validate_only'] = validate_only
        try:
            result = self._ws.pipelines.start_update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def pipelines_stop(self, pipeline_id: str) -> DatabricksResponse:
        """Stops the pipeline by canceling the active update. If there is no active update for the pipeline, this request is a no-op."""
        kwargs: Dict[str, Any] = {}
        kwargs['pipeline_id'] = pipeline_id
        try:
            result = self._ws.pipelines.stop(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def pipelines_update(
        self,
        pipeline_id: str,
        allow_duplicate_names: Optional[bool] = None,
        budget_policy_id: Optional[str] = None,
        catalog: Optional[str] = None,
        channel: Optional[str] = None,
        clusters: Optional[List[Dict[str, Any]]] = None,
        configuration: Optional[Dict[str, str]] = None,
        continuous: Optional[bool] = None,
        deployment: Optional[Dict[str, Any]] = None,
        development: Optional[bool] = None,
        edition: Optional[str] = None,
        environment: Optional[Dict[str, Any]] = None,
        event_log: Optional[Dict[str, Any]] = None,
        expected_last_modified: Optional[int] = None,
        filters: Optional[Dict[str, Any]] = None,
        gateway_definition: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,
        ingestion_definition: Optional[Dict[str, Any]] = None,
        libraries: Optional[List[Dict[str, Any]]] = None,
        name: Optional[str] = None,
        notifications: Optional[List[Dict[str, Any]]] = None,
        photon: Optional[bool] = None,
        restart_window: Optional[Dict[str, Any]] = None,
        root_path: Optional[str] = None,
        run_as: Optional[Dict[str, Any]] = None,
        schema: Optional[str] = None,
        serverless: Optional[bool] = None,
        storage: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        target: Optional[str] = None,
        trigger: Optional[Dict[str, Any]] = None,
        usage_policy_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates a pipeline with the supplied configuration."""
        kwargs: Dict[str, Any] = {}
        kwargs['pipeline_id'] = pipeline_id
        if allow_duplicate_names is not None:
            kwargs['allow_duplicate_names'] = allow_duplicate_names
        if budget_policy_id is not None:
            kwargs['budget_policy_id'] = budget_policy_id
        if catalog is not None:
            kwargs['catalog'] = catalog
        if channel is not None:
            kwargs['channel'] = channel
        if clusters is not None:
            kwargs['clusters'] = clusters
        if configuration is not None:
            kwargs['configuration'] = configuration
        if continuous is not None:
            kwargs['continuous'] = continuous
        if deployment is not None:
            kwargs['deployment'] = deployment
        if development is not None:
            kwargs['development'] = development
        if edition is not None:
            kwargs['edition'] = edition
        if environment is not None:
            kwargs['environment'] = environment
        if event_log is not None:
            kwargs['event_log'] = event_log
        if expected_last_modified is not None:
            kwargs['expected_last_modified'] = expected_last_modified
        if filters is not None:
            kwargs['filters'] = filters
        if gateway_definition is not None:
            kwargs['gateway_definition'] = gateway_definition
        if id is not None:
            kwargs['id'] = id
        if ingestion_definition is not None:
            kwargs['ingestion_definition'] = ingestion_definition
        if libraries is not None:
            kwargs['libraries'] = libraries
        if name is not None:
            kwargs['name'] = name
        if notifications is not None:
            kwargs['notifications'] = notifications
        if photon is not None:
            kwargs['photon'] = photon
        if restart_window is not None:
            kwargs['restart_window'] = restart_window
        if root_path is not None:
            kwargs['root_path'] = root_path
        if run_as is not None:
            kwargs['run_as'] = run_as
        if schema is not None:
            kwargs['schema'] = schema
        if serverless is not None:
            kwargs['serverless'] = serverless
        if storage is not None:
            kwargs['storage'] = storage
        if tags is not None:
            kwargs['tags'] = tags
        if target is not None:
            kwargs['target'] = target
        if trigger is not None:
            kwargs['trigger'] = trigger
        if usage_policy_id is not None:
            kwargs['usage_policy_id'] = usage_policy_id
        try:
            result = self._ws.pipelines.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def pipelines_update_permissions(
        self,
        pipeline_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on a pipeline. Pipelines can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['pipeline_id'] = pipeline_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.pipelines.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # POLICIES (PoliciesAPI) — 5 methods
    # ============================================================================

    async def policies_create_policy(self, policy_info: Dict[str, Any]) -> DatabricksResponse:
        """Creates a new policy on a securable. The new policy applies to the securable and all its descendants."""
        kwargs: Dict[str, Any] = {}
        kwargs['policy_info'] = policy_info
        try:
            result = self._ws.policies.create_policy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def policies_delete_policy(
        self,
        on_securable_type: str,
        on_securable_fullname: str,
        name: str,
    ) -> DatabricksResponse:
        """Delete an ABAC policy defined on a securable."""
        kwargs: Dict[str, Any] = {}
        kwargs['on_securable_type'] = on_securable_type
        kwargs['on_securable_fullname'] = on_securable_fullname
        kwargs['name'] = name
        try:
            result = self._ws.policies.delete_policy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def policies_get_policy(
        self,
        on_securable_type: str,
        on_securable_fullname: str,
        name: str,
    ) -> DatabricksResponse:
        """Get the policy definition on a securable"""
        kwargs: Dict[str, Any] = {}
        kwargs['on_securable_type'] = on_securable_type
        kwargs['on_securable_fullname'] = on_securable_fullname
        kwargs['name'] = name
        try:
            result = self._ws.policies.get_policy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def policies_list_policies(
        self,
        on_securable_type: str,
        on_securable_fullname: str,
        include_inherited: Optional[bool] = None,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List all policies defined on a securable. Optionally, the list can include inherited policies defined on the securable's parent schema or catalog."""
        kwargs: Dict[str, Any] = {}
        kwargs['on_securable_type'] = on_securable_type
        kwargs['on_securable_fullname'] = on_securable_fullname
        if include_inherited is not None:
            kwargs['include_inherited'] = include_inherited
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.policies.list_policies(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def policies_update_policy(
        self,
        on_securable_type: str,
        on_securable_fullname: str,
        name: str,
        policy_info: Dict[str, Any],
        update_mask: Optional[str] = None,
    ) -> DatabricksResponse:
        """Update an ABAC policy on a securable."""
        kwargs: Dict[str, Any] = {}
        kwargs['on_securable_type'] = on_securable_type
        kwargs['on_securable_fullname'] = on_securable_fullname
        kwargs['name'] = name
        kwargs['policy_info'] = policy_info
        if update_mask is not None:
            kwargs['update_mask'] = update_mask
        try:
            result = self._ws.policies.update_policy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # POLICY COMPLIANCE FOR CLUSTERS (PolicyComplianceForClustersAPI) — 3 methods
    # ============================================================================

    async def policy_compliance_for_clusters_enforce_compliance(self, cluster_id: str, validate_only: Optional[bool] = None) -> DatabricksResponse:
        """Updates a cluster to be compliant with the current version of its policy. A cluster can be updated if it is in a `RUNNING` or `TERMINATED` state."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        if validate_only is not None:
            kwargs['validate_only'] = validate_only
        try:
            result = self._ws.policy_compliance_for_clusters.enforce_compliance(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def policy_compliance_for_clusters_get_compliance(self, cluster_id: str) -> DatabricksResponse:
        """Returns the policy compliance status of a cluster. Clusters could be out of compliance if their policy was updated after the cluster was last edited."""
        kwargs: Dict[str, Any] = {}
        kwargs['cluster_id'] = cluster_id
        try:
            result = self._ws.policy_compliance_for_clusters.get_compliance(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def policy_compliance_for_clusters_list_compliance(
        self,
        policy_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Returns the policy compliance status of all clusters that use a given policy. Clusters could be out of compliance if their policy was updated after the cluster was last edited."""
        kwargs: Dict[str, Any] = {}
        kwargs['policy_id'] = policy_id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.policy_compliance_for_clusters.list_compliance(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # POLICY COMPLIANCE FOR JOBS (PolicyComplianceForJobsAPI) — 3 methods
    # ============================================================================

    async def policy_compliance_for_jobs_enforce_compliance(self, job_id: int, validate_only: Optional[bool] = None) -> DatabricksResponse:
        """Updates a job so the job clusters that are created when running the job (specified in `new_cluster`) are compliant with the current versions of their respective cluster policies. All-purpose cluste..."""
        kwargs: Dict[str, Any] = {}
        kwargs['job_id'] = job_id
        if validate_only is not None:
            kwargs['validate_only'] = validate_only
        try:
            result = self._ws.policy_compliance_for_jobs.enforce_compliance(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def policy_compliance_for_jobs_get_compliance(self, job_id: int) -> DatabricksResponse:
        """Returns the policy compliance status of a job. Jobs could be out of compliance if a cluster policy they use was updated after the job was last edited and some of its job clusters no longer comply w..."""
        kwargs: Dict[str, Any] = {}
        kwargs['job_id'] = job_id
        try:
            result = self._ws.policy_compliance_for_jobs.get_compliance(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def policy_compliance_for_jobs_list_compliance(
        self,
        policy_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Returns the policy compliance status of all jobs that use a given policy. Jobs could be out of compliance if a cluster policy they use was updated after the job was last edited and its job clusters..."""
        kwargs: Dict[str, Any] = {}
        kwargs['policy_id'] = policy_id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.policy_compliance_for_jobs.list_compliance(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # POLICY FAMILIES (PolicyFamiliesAPI) — 2 methods
    # ============================================================================

    async def policy_families_get(self, policy_family_id: str, version: Optional[int] = None) -> DatabricksResponse:
        """Retrieve the information for an policy family based on its identifier and version"""
        kwargs: Dict[str, Any] = {}
        kwargs['policy_family_id'] = policy_family_id
        if version is not None:
            kwargs['version'] = version
        try:
            result = self._ws.policy_families.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def policy_families_list(self, max_results: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Returns the list of policy definition types available to use at their latest version. This API is paginated."""
        kwargs: Dict[str, Any] = {}
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.policy_families.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # POSTGRES (PostgresAPI) — 21 methods
    # ============================================================================

    async def postgres_create_branch(
        self,
        parent: str,
        branch: Dict[str, Any],
        branch_id: str,
    ) -> DatabricksResponse:
        """Creates a new database branch in the project."""
        kwargs: Dict[str, Any] = {}
        kwargs['parent'] = parent
        kwargs['branch'] = branch
        kwargs['branch_id'] = branch_id
        try:
            result = self._ws.postgres.create_branch(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_create_endpoint(
        self,
        parent: str,
        endpoint: Dict[str, Any],
        endpoint_id: str,
    ) -> DatabricksResponse:
        """Creates a new compute endpoint in the branch."""
        kwargs: Dict[str, Any] = {}
        kwargs['parent'] = parent
        kwargs['endpoint'] = endpoint
        kwargs['endpoint_id'] = endpoint_id
        try:
            result = self._ws.postgres.create_endpoint(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_create_project(self, project: Dict[str, Any], project_id: str) -> DatabricksResponse:
        """Creates a new Lakebase Autoscaling Postgres database project, which contains branches and compute endpoints."""
        kwargs: Dict[str, Any] = {}
        kwargs['project'] = project
        kwargs['project_id'] = project_id
        try:
            result = self._ws.postgres.create_project(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_create_role(
        self,
        parent: str,
        role: Dict[str, Any],
        role_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new Postgres role in the branch."""
        kwargs: Dict[str, Any] = {}
        kwargs['parent'] = parent
        kwargs['role'] = role
        if role_id is not None:
            kwargs['role_id'] = role_id
        try:
            result = self._ws.postgres.create_role(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_delete_branch(self, name: str) -> DatabricksResponse:
        """Deletes the specified database branch."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.postgres.delete_branch(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_delete_endpoint(self, name: str) -> DatabricksResponse:
        """Deletes the specified compute endpoint."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.postgres.delete_endpoint(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_delete_project(self, name: str) -> DatabricksResponse:
        """Deletes the specified database project."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.postgres.delete_project(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_delete_role(self, name: str, reassign_owned_to: Optional[str] = None) -> DatabricksResponse:
        """Deletes the specified Postgres role."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if reassign_owned_to is not None:
            kwargs['reassign_owned_to'] = reassign_owned_to
        try:
            result = self._ws.postgres.delete_role(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_generate_database_credential(
        self,
        endpoint: str,
        claims: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Generate OAuth credentials for a Postgres database."""
        kwargs: Dict[str, Any] = {}
        kwargs['endpoint'] = endpoint
        if claims is not None:
            kwargs['claims'] = claims
        try:
            result = self._ws.postgres.generate_database_credential(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_get_branch(self, name: str) -> DatabricksResponse:
        """Retrieves information about the specified database branch."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.postgres.get_branch(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_get_endpoint(self, name: str) -> DatabricksResponse:
        """Retrieves information about the specified compute endpoint, including its connection details and operational state."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.postgres.get_endpoint(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_get_operation(self, name: str) -> DatabricksResponse:
        """Retrieves the status of a long-running operation."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.postgres.get_operation(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_get_project(self, name: str) -> DatabricksResponse:
        """Retrieves information about the specified database project."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.postgres.get_project(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_get_role(self, name: str) -> DatabricksResponse:
        """Retrieves information about the specified Postgres role, including its authentication method and permissions."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.postgres.get_role(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_list_branches(
        self,
        parent: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Returns a paginated list of database branches in the project."""
        kwargs: Dict[str, Any] = {}
        kwargs['parent'] = parent
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.postgres.list_branches(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_list_endpoints(
        self,
        parent: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Returns a paginated list of compute endpoints in the branch."""
        kwargs: Dict[str, Any] = {}
        kwargs['parent'] = parent
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.postgres.list_endpoints(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_list_projects(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Returns a paginated list of database projects in the workspace that the user has permission to access."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.postgres.list_projects(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_list_roles(
        self,
        parent: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Returns a paginated list of Postgres roles in the branch."""
        kwargs: Dict[str, Any] = {}
        kwargs['parent'] = parent
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.postgres.list_roles(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_update_branch(
        self,
        name: str,
        branch: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Updates the specified database branch. You can set this branch as the project's default branch, or protect/unprotect it."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['branch'] = branch
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.postgres.update_branch(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_update_endpoint(
        self,
        name: str,
        endpoint: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Updates the specified compute endpoint. You can update autoscaling limits, suspend timeout, or enable/disable the compute endpoint."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['endpoint'] = endpoint
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.postgres.update_endpoint(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def postgres_update_project(
        self,
        name: str,
        project: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Updates the specified database project."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['project'] = project
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.postgres.update_project(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # PROVIDER EXCHANGE FILTERS (ProviderExchangeFiltersAPI) — 4 methods
    # ============================================================================

    async def provider_exchange_filters_create(self, filter: Dict[str, Any]) -> DatabricksResponse:
        """Add an exchange filter."""
        kwargs: Dict[str, Any] = {}
        kwargs['filter'] = filter
        try:
            result = self._ws.provider_exchange_filters.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_exchange_filters_delete(self, id: str) -> DatabricksResponse:
        """Delete an exchange filter"""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.provider_exchange_filters.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_exchange_filters_list(
        self,
        exchange_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List exchange filter"""
        kwargs: Dict[str, Any] = {}
        kwargs['exchange_id'] = exchange_id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.provider_exchange_filters.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_exchange_filters_update(self, id: str, filter: Dict[str, Any]) -> DatabricksResponse:
        """Update an exchange filter."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        kwargs['filter'] = filter
        try:
            result = self._ws.provider_exchange_filters.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # PROVIDER EXCHANGES (ProviderExchangesAPI) — 9 methods
    # ============================================================================

    async def provider_exchanges_add_listing_to_exchange(self, listing_id: str, exchange_id: str) -> DatabricksResponse:
        """Associate an exchange with a listing"""
        kwargs: Dict[str, Any] = {}
        kwargs['listing_id'] = listing_id
        kwargs['exchange_id'] = exchange_id
        try:
            result = self._ws.provider_exchanges.add_listing_to_exchange(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_exchanges_create(self, exchange: Dict[str, Any]) -> DatabricksResponse:
        """Create an exchange"""
        kwargs: Dict[str, Any] = {}
        kwargs['exchange'] = exchange
        try:
            result = self._ws.provider_exchanges.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_exchanges_delete(self, id: str) -> DatabricksResponse:
        """This removes a listing from marketplace."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.provider_exchanges.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_exchanges_delete_listing_from_exchange(self, id: str) -> DatabricksResponse:
        """Disassociate an exchange with a listing"""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.provider_exchanges.delete_listing_from_exchange(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_exchanges_get(self, id: str) -> DatabricksResponse:
        """Get an exchange."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.provider_exchanges.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_exchanges_list(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """List exchanges visible to provider"""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.provider_exchanges.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_exchanges_list_exchanges_for_listing(
        self,
        listing_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List exchanges associated with a listing"""
        kwargs: Dict[str, Any] = {}
        kwargs['listing_id'] = listing_id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.provider_exchanges.list_exchanges_for_listing(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_exchanges_list_listings_for_exchange(
        self,
        exchange_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List listings associated with an exchange"""
        kwargs: Dict[str, Any] = {}
        kwargs['exchange_id'] = exchange_id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.provider_exchanges.list_listings_for_exchange(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_exchanges_update(self, id: str, exchange: Dict[str, Any]) -> DatabricksResponse:
        """Update an exchange"""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        kwargs['exchange'] = exchange
        try:
            result = self._ws.provider_exchanges.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # PROVIDER FILES (ProviderFilesAPI) — 4 methods
    # ============================================================================

    async def provider_files_create(
        self,
        file_parent: Dict[str, Any],
        marketplace_file_type: Dict[str, Any],
        mime_type: str,
        display_name: Optional[str] = None,
    ) -> DatabricksResponse:
        """Create a file. Currently, only provider icons and attached notebooks are supported."""
        kwargs: Dict[str, Any] = {}
        kwargs['file_parent'] = file_parent
        kwargs['marketplace_file_type'] = marketplace_file_type
        kwargs['mime_type'] = mime_type
        if display_name is not None:
            kwargs['display_name'] = display_name
        try:
            result = self._ws.provider_files.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_files_delete(self, file_id: str) -> DatabricksResponse:
        """Delete a file"""
        kwargs: Dict[str, Any] = {}
        kwargs['file_id'] = file_id
        try:
            result = self._ws.provider_files.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_files_get(self, file_id: str) -> DatabricksResponse:
        """Get a file"""
        kwargs: Dict[str, Any] = {}
        kwargs['file_id'] = file_id
        try:
            result = self._ws.provider_files.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_files_list(
        self,
        file_parent: Dict[str, Any],
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List files attached to a parent entity."""
        kwargs: Dict[str, Any] = {}
        kwargs['file_parent'] = file_parent
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.provider_files.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # PROVIDER LISTINGS (ProviderListingsAPI) — 5 methods
    # ============================================================================

    async def provider_listings_create(self, listing: Dict[str, Any]) -> DatabricksResponse:
        """Create a new listing"""
        kwargs: Dict[str, Any] = {}
        kwargs['listing'] = listing
        try:
            result = self._ws.provider_listings.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_listings_delete(self, id: str) -> DatabricksResponse:
        """Delete a listing"""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.provider_listings.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_listings_get(self, id: str) -> DatabricksResponse:
        """Get a listing"""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.provider_listings.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_listings_list(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """List listings owned by this provider"""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.provider_listings.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_listings_update(self, id: str, listing: Dict[str, Any]) -> DatabricksResponse:
        """Update a listing"""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        kwargs['listing'] = listing
        try:
            result = self._ws.provider_listings.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # PROVIDER PERSONALIZATION REQUESTS (ProviderPersonalizationRequestsAPI) — 2 methods
    # ============================================================================

    async def provider_personalization_requests_list(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """List personalization requests to this provider. This will return all personalization requests, regardless of which listing they are for."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.provider_personalization_requests.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_personalization_requests_update(
        self,
        listing_id: str,
        request_id: str,
        status: Dict[str, Any],
        reason: Optional[str] = None,
        share: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Update personalization request. This method only permits updating the status of the request."""
        kwargs: Dict[str, Any] = {}
        kwargs['listing_id'] = listing_id
        kwargs['request_id'] = request_id
        kwargs['status'] = status
        if reason is not None:
            kwargs['reason'] = reason
        if share is not None:
            kwargs['share'] = share
        try:
            result = self._ws.provider_personalization_requests.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # PROVIDER PROVIDER ANALYTICS DASHBOARDS (ProviderProviderAnalyticsDashboardsAPI) — 4 methods
    # ============================================================================

    async def provider_provider_analytics_dashboards_create(self) -> DatabricksResponse:
        """Create provider analytics dashboard. Returns Marketplace specific `id`. Not to be confused with the Lakeview dashboard id."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.provider_provider_analytics_dashboards.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_provider_analytics_dashboards_get(self) -> DatabricksResponse:
        """Get provider analytics dashboard."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.provider_provider_analytics_dashboards.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_provider_analytics_dashboards_get_latest_version(self) -> DatabricksResponse:
        """Get latest version of provider analytics dashboard."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.provider_provider_analytics_dashboards.get_latest_version(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_provider_analytics_dashboards_update(self, id: str, version: Optional[int] = None) -> DatabricksResponse:
        """Update provider analytics dashboard."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if version is not None:
            kwargs['version'] = version
        try:
            result = self._ws.provider_provider_analytics_dashboards.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # PROVIDER PROVIDERS (ProviderProvidersAPI) — 5 methods
    # ============================================================================

    async def provider_providers_create(self, provider: Dict[str, Any]) -> DatabricksResponse:
        """Create a provider"""
        kwargs: Dict[str, Any] = {}
        kwargs['provider'] = provider
        try:
            result = self._ws.provider_providers.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_providers_delete(self, id: str) -> DatabricksResponse:
        """Delete provider"""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.provider_providers.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_providers_get(self, id: str) -> DatabricksResponse:
        """Get provider profile"""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.provider_providers.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_providers_list(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """List provider profiles for account."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.provider_providers.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def provider_providers_update(self, id: str, provider: Dict[str, Any]) -> DatabricksResponse:
        """Update provider profile"""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        kwargs['provider'] = provider
        try:
            result = self._ws.provider_providers.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # PROVIDERS (ProvidersAPI) — 7 methods
    # ============================================================================

    async def providers_create(
        self,
        name: str,
        authentication_type: Dict[str, Any],
        comment: Optional[str] = None,
        recipient_profile_str: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new authentication provider minimally based on a name and authentication type. The caller must be an admin on the metastore."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['authentication_type'] = authentication_type
        if comment is not None:
            kwargs['comment'] = comment
        if recipient_profile_str is not None:
            kwargs['recipient_profile_str'] = recipient_profile_str
        try:
            result = self._ws.providers.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def providers_delete(self, name: str) -> DatabricksResponse:
        """Deletes an authentication provider, if the caller is a metastore admin or is the owner of the provider."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.providers.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def providers_get(self, name: str) -> DatabricksResponse:
        """Gets a specific authentication provider. The caller must supply the name of the provider, and must either be a metastore admin or the owner of the provider."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.providers.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def providers_list(
        self,
        data_provider_global_metastore_id: Optional[str] = None,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets an array of available authentication providers. The caller must either be a metastore admin, have the **USE_PROVIDER** privilege on the providers, or be the owner of the providers. Providers n..."""
        kwargs: Dict[str, Any] = {}
        if data_provider_global_metastore_id is not None:
            kwargs['data_provider_global_metastore_id'] = data_provider_global_metastore_id
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.providers.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def providers_list_provider_share_assets(
        self,
        provider_name: str,
        share_name: str,
        function_max_results: Optional[int] = None,
        notebook_max_results: Optional[int] = None,
        table_max_results: Optional[int] = None,
        volume_max_results: Optional[int] = None,
    ) -> DatabricksResponse:
        """Get arrays of assets associated with a specified provider's share. The caller is the recipient of the share."""
        kwargs: Dict[str, Any] = {}
        kwargs['provider_name'] = provider_name
        kwargs['share_name'] = share_name
        if function_max_results is not None:
            kwargs['function_max_results'] = function_max_results
        if notebook_max_results is not None:
            kwargs['notebook_max_results'] = notebook_max_results
        if table_max_results is not None:
            kwargs['table_max_results'] = table_max_results
        if volume_max_results is not None:
            kwargs['volume_max_results'] = volume_max_results
        try:
            result = self._ws.providers.list_provider_share_assets(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def providers_list_shares(
        self,
        name: str,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets an array of a specified provider's shares within the metastore where:"""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.providers.list_shares(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def providers_update(
        self,
        name: str,
        comment: Optional[str] = None,
        new_name: Optional[str] = None,
        owner: Optional[str] = None,
        recipient_profile_str: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates the information for an authentication provider, if the caller is a metastore admin or is the owner of the provider. If the update changes the provider name, the caller must be both a metast..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if comment is not None:
            kwargs['comment'] = comment
        if new_name is not None:
            kwargs['new_name'] = new_name
        if owner is not None:
            kwargs['owner'] = owner
        if recipient_profile_str is not None:
            kwargs['recipient_profile_str'] = recipient_profile_str
        try:
            result = self._ws.providers.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # QUALITY MONITOR V2 (QualityMonitorV2API) — 5 methods
    # ============================================================================

    async def quality_monitor_v2_create_quality_monitor(self, quality_monitor: Dict[str, Any]) -> DatabricksResponse:
        """[DEPRECATED] Create a quality monitor on UC object. Use Data Quality Monitoring API instead."""
        kwargs: Dict[str, Any] = {}
        kwargs['quality_monitor'] = quality_monitor
        try:
            result = self._ws.quality_monitor_v2.create_quality_monitor(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def quality_monitor_v2_delete_quality_monitor(self, object_type: str, object_id: str) -> DatabricksResponse:
        """[DEPRECATED] Delete a quality monitor on UC object. Use Data Quality Monitoring API instead."""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        try:
            result = self._ws.quality_monitor_v2.delete_quality_monitor(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def quality_monitor_v2_get_quality_monitor(self, object_type: str, object_id: str) -> DatabricksResponse:
        """[DEPRECATED] Read a quality monitor on UC object. Use Data Quality Monitoring API instead."""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        try:
            result = self._ws.quality_monitor_v2.get_quality_monitor(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def quality_monitor_v2_list_quality_monitor(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """[DEPRECATED] (Unimplemented) List quality monitors. Use Data Quality Monitoring API instead."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.quality_monitor_v2.list_quality_monitor(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def quality_monitor_v2_update_quality_monitor(
        self,
        object_type: str,
        object_id: str,
        quality_monitor: Dict[str, Any],
    ) -> DatabricksResponse:
        """[DEPRECATED] (Unimplemented) Update a quality monitor on UC object. Use Data Quality Monitoring API instead."""
        kwargs: Dict[str, Any] = {}
        kwargs['object_type'] = object_type
        kwargs['object_id'] = object_id
        kwargs['quality_monitor'] = quality_monitor
        try:
            result = self._ws.quality_monitor_v2.update_quality_monitor(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # QUALITY MONITORS (QualityMonitorsAPI) — 9 methods
    # ============================================================================

    async def quality_monitors_cancel_refresh(self, table_name: str, refresh_id: int) -> DatabricksResponse:
        """[DEPRECATED] Cancels an already-initiated refresh job. Use Data Quality Monitors API instead (/api/data-quality/v1/monitors)."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        kwargs['refresh_id'] = refresh_id
        try:
            result = self._ws.quality_monitors.cancel_refresh(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def quality_monitors_create(
        self,
        table_name: str,
        output_schema_name: str,
        assets_dir: str,
        baseline_table_name: Optional[str] = None,
        custom_metrics: Optional[List[Dict[str, Any]]] = None,
        data_classification_config: Optional[Dict[str, Any]] = None,
        inference_log: Optional[Dict[str, Any]] = None,
        latest_monitor_failure_msg: Optional[str] = None,
        notifications: Optional[Dict[str, Any]] = None,
        schedule: Optional[Dict[str, Any]] = None,
        skip_builtin_dashboard: Optional[bool] = None,
        slicing_exprs: Optional[List[str]] = None,
        snapshot: Optional[Dict[str, Any]] = None,
        time_series: Optional[Dict[str, Any]] = None,
        warehouse_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """[DEPRECATED] Creates a new monitor for the specified table. Use Data Quality Monitors API instead (/api/data-quality/v1/monitors)."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        kwargs['output_schema_name'] = output_schema_name
        kwargs['assets_dir'] = assets_dir
        if baseline_table_name is not None:
            kwargs['baseline_table_name'] = baseline_table_name
        if custom_metrics is not None:
            kwargs['custom_metrics'] = custom_metrics
        if data_classification_config is not None:
            kwargs['data_classification_config'] = data_classification_config
        if inference_log is not None:
            kwargs['inference_log'] = inference_log
        if latest_monitor_failure_msg is not None:
            kwargs['latest_monitor_failure_msg'] = latest_monitor_failure_msg
        if notifications is not None:
            kwargs['notifications'] = notifications
        if schedule is not None:
            kwargs['schedule'] = schedule
        if skip_builtin_dashboard is not None:
            kwargs['skip_builtin_dashboard'] = skip_builtin_dashboard
        if slicing_exprs is not None:
            kwargs['slicing_exprs'] = slicing_exprs
        if snapshot is not None:
            kwargs['snapshot'] = snapshot
        if time_series is not None:
            kwargs['time_series'] = time_series
        if warehouse_id is not None:
            kwargs['warehouse_id'] = warehouse_id
        try:
            result = self._ws.quality_monitors.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def quality_monitors_delete(self, table_name: str) -> DatabricksResponse:
        """[DEPRECATED] Deletes a monitor for the specified table. Use Data Quality Monitors API instead (/api/data-quality/v1/monitors)."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        try:
            result = self._ws.quality_monitors.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def quality_monitors_get(self, table_name: str) -> DatabricksResponse:
        """[DEPRECATED] Gets a monitor for the specified table. Use Data Quality Monitors API instead (/api/data-quality/v1/monitors)."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        try:
            result = self._ws.quality_monitors.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def quality_monitors_get_refresh(self, table_name: str, refresh_id: int) -> DatabricksResponse:
        """[DEPRECATED] Gets info about a specific monitor refresh using the given refresh ID. Use Data Quality Monitors API instead (/api/data-quality/v1/monitors)."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        kwargs['refresh_id'] = refresh_id
        try:
            result = self._ws.quality_monitors.get_refresh(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def quality_monitors_list_refreshes(self, table_name: str) -> DatabricksResponse:
        """[DEPRECATED] Gets an array containing the history of the most recent refreshes (up to 25) for this table. Use Data Quality Monitors API instead (/api/data-quality/v1/monitors)."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        try:
            result = self._ws.quality_monitors.list_refreshes(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def quality_monitors_regenerate_dashboard(self, table_name: str, warehouse_id: Optional[str] = None) -> DatabricksResponse:
        """[DEPRECATED] Regenerates the monitoring dashboard for the specified table. Use Data Quality Monitors API instead (/api/data-quality/v1/monitors)."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        if warehouse_id is not None:
            kwargs['warehouse_id'] = warehouse_id
        try:
            result = self._ws.quality_monitors.regenerate_dashboard(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def quality_monitors_run_refresh(self, table_name: str) -> DatabricksResponse:
        """[DEPRECATED] Queues a metric refresh on the monitor for the specified table. Use Data Quality Monitors API instead (/api/data-quality/v1/monitors). The refresh will execute in the background."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        try:
            result = self._ws.quality_monitors.run_refresh(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def quality_monitors_update(
        self,
        table_name: str,
        output_schema_name: str,
        baseline_table_name: Optional[str] = None,
        custom_metrics: Optional[List[Dict[str, Any]]] = None,
        dashboard_id: Optional[str] = None,
        data_classification_config: Optional[Dict[str, Any]] = None,
        inference_log: Optional[Dict[str, Any]] = None,
        latest_monitor_failure_msg: Optional[str] = None,
        notifications: Optional[Dict[str, Any]] = None,
        schedule: Optional[Dict[str, Any]] = None,
        slicing_exprs: Optional[List[str]] = None,
        snapshot: Optional[Dict[str, Any]] = None,
        time_series: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """[DEPRECATED] Updates a monitor for the specified table. Use Data Quality Monitors API instead (/api/data-quality/v1/monitors)."""
        kwargs: Dict[str, Any] = {}
        kwargs['table_name'] = table_name
        kwargs['output_schema_name'] = output_schema_name
        if baseline_table_name is not None:
            kwargs['baseline_table_name'] = baseline_table_name
        if custom_metrics is not None:
            kwargs['custom_metrics'] = custom_metrics
        if dashboard_id is not None:
            kwargs['dashboard_id'] = dashboard_id
        if data_classification_config is not None:
            kwargs['data_classification_config'] = data_classification_config
        if inference_log is not None:
            kwargs['inference_log'] = inference_log
        if latest_monitor_failure_msg is not None:
            kwargs['latest_monitor_failure_msg'] = latest_monitor_failure_msg
        if notifications is not None:
            kwargs['notifications'] = notifications
        if schedule is not None:
            kwargs['schedule'] = schedule
        if slicing_exprs is not None:
            kwargs['slicing_exprs'] = slicing_exprs
        if snapshot is not None:
            kwargs['snapshot'] = snapshot
        if time_series is not None:
            kwargs['time_series'] = time_series
        try:
            result = self._ws.quality_monitors.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # QUERIES (QueriesAPI) — 6 methods
    # ============================================================================

    async def queries_create(
        self,
        auto_resolve_display_name: Optional[bool] = None,
        query: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Creates a query."""
        kwargs: Dict[str, Any] = {}
        if auto_resolve_display_name is not None:
            kwargs['auto_resolve_display_name'] = auto_resolve_display_name
        if query is not None:
            kwargs['query'] = query
        try:
            result = self._ws.queries.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def queries_delete(self, id: str) -> DatabricksResponse:
        """Moves a query to the trash. Trashed queries immediately disappear from searches and list views, and cannot be used for alerts. You can restore a trashed query through the UI. A trashed query is per..."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.queries.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def queries_get(self, id: str) -> DatabricksResponse:
        """Gets a query."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.queries.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def queries_list(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Gets a list of queries accessible to the user, ordered by creation time. **Warning:** Calling this API concurrently 10 or more times could result in throttling, service degradation, or a temporary ..."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.queries.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def queries_list_visualizations(
        self,
        id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets a list of visualizations on a query."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.queries.list_visualizations(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def queries_update(
        self,
        id: str,
        update_mask: str,
        auto_resolve_display_name: Optional[bool] = None,
        query: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Updates a query."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        kwargs['update_mask'] = update_mask
        if auto_resolve_display_name is not None:
            kwargs['auto_resolve_display_name'] = auto_resolve_display_name
        if query is not None:
            kwargs['query'] = query
        try:
            result = self._ws.queries.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # QUERY HISTORY (QueryHistoryAPI) — 1 methods
    # ============================================================================

    async def query_history_list(
        self,
        filter_by: Optional[Dict[str, Any]] = None,
        include_metrics: Optional[bool] = None,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List the history of queries through SQL warehouses, and serverless compute."""
        kwargs: Dict[str, Any] = {}
        if filter_by is not None:
            kwargs['filter_by'] = filter_by
        if include_metrics is not None:
            kwargs['include_metrics'] = include_metrics
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = self._ws.query_history.list(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # QUERY VISUALIZATIONS (QueryVisualizationsAPI) — 3 methods
    # ============================================================================

    async def query_visualizations_create(
        self,
        visualization: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Adds a visualization to a query."""
        kwargs: Dict[str, Any] = {}
        if visualization is not None:
            kwargs['visualization'] = visualization
        try:
            result = self._ws.query_visualizations.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def query_visualizations_delete(self, id: str) -> DatabricksResponse:
        """Removes a visualization."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.query_visualizations.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def query_visualizations_update(
        self,
        id: str,
        update_mask: str,
        visualization: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Updates a visualization."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        kwargs['update_mask'] = update_mask
        if visualization is not None:
            kwargs['visualization'] = visualization
        try:
            result = self._ws.query_visualizations.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # RECIPIENT ACTIVATION (RecipientActivationAPI) — 2 methods
    # ============================================================================

    async def recipient_activation_get_activation_url_info(self, activation_url: str) -> DatabricksResponse:
        """Gets an activation URL for a share."""
        kwargs: Dict[str, Any] = {}
        kwargs['activation_url'] = activation_url
        try:
            result = self._ws.recipient_activation.get_activation_url_info(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def recipient_activation_retrieve_token(self, activation_url: str) -> DatabricksResponse:
        """Retrieve access token with an activation url. This is a public API without any authentication."""
        kwargs: Dict[str, Any] = {}
        kwargs['activation_url'] = activation_url
        try:
            result = self._ws.recipient_activation.retrieve_token(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # RECIPIENT FEDERATION POLICIES (RecipientFederationPoliciesAPI) — 4 methods
    # ============================================================================

    async def recipient_federation_policies_create(self, recipient_name: str, policy: Dict[str, Any]) -> DatabricksResponse:
        """Create a federation policy for an OIDC_FEDERATION recipient for sharing data from Databricks to non-Databricks recipients. The caller must be the owner of the recipient. When sharing data from Data..."""
        kwargs: Dict[str, Any] = {}
        kwargs['recipient_name'] = recipient_name
        kwargs['policy'] = policy
        try:
            result = self._ws.recipient_federation_policies.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def recipient_federation_policies_delete(self, recipient_name: str, name: str) -> DatabricksResponse:
        """Deletes an existing federation policy for an OIDC_FEDERATION recipient. The caller must be the owner of the recipient."""
        kwargs: Dict[str, Any] = {}
        kwargs['recipient_name'] = recipient_name
        kwargs['name'] = name
        try:
            result = self._ws.recipient_federation_policies.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def recipient_federation_policies_get_federation_policy(self, recipient_name: str, name: str) -> DatabricksResponse:
        """Reads an existing federation policy for an OIDC_FEDERATION recipient for sharing data from Databricks to non-Databricks recipients. The caller must have read access to the recipient."""
        kwargs: Dict[str, Any] = {}
        kwargs['recipient_name'] = recipient_name
        kwargs['name'] = name
        try:
            result = self._ws.recipient_federation_policies.get_federation_policy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def recipient_federation_policies_list(
        self,
        recipient_name: str,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Lists federation policies for an OIDC_FEDERATION recipient for sharing data from Databricks to non-Databricks recipients. The caller must have read access to the recipient."""
        kwargs: Dict[str, Any] = {}
        kwargs['recipient_name'] = recipient_name
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.recipient_federation_policies.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # RECIPIENTS (RecipientsAPI) — 7 methods
    # ============================================================================

    async def recipients_create(
        self,
        name: str,
        authentication_type: Dict[str, Any],
        comment: Optional[str] = None,
        data_recipient_global_metastore_id: Optional[str] = None,
        expiration_time: Optional[int] = None,
        ip_access_list: Optional[Dict[str, Any]] = None,
        owner: Optional[str] = None,
        properties_kvpairs: Optional[Dict[str, Any]] = None,
        sharing_code: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new recipient with the delta sharing authentication type in the metastore. The caller must be a metastore admin or have the **CREATE_RECIPIENT** privilege on the metastore."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['authentication_type'] = authentication_type
        if comment is not None:
            kwargs['comment'] = comment
        if data_recipient_global_metastore_id is not None:
            kwargs['data_recipient_global_metastore_id'] = data_recipient_global_metastore_id
        if expiration_time is not None:
            kwargs['expiration_time'] = expiration_time
        if ip_access_list is not None:
            kwargs['ip_access_list'] = ip_access_list
        if owner is not None:
            kwargs['owner'] = owner
        if properties_kvpairs is not None:
            kwargs['properties_kvpairs'] = properties_kvpairs
        if sharing_code is not None:
            kwargs['sharing_code'] = sharing_code
        try:
            result = self._ws.recipients.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def recipients_delete(self, name: str) -> DatabricksResponse:
        """Deletes the specified recipient from the metastore. The caller must be the owner of the recipient."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.recipients.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def recipients_get(self, name: str) -> DatabricksResponse:
        """Gets a share recipient from the metastore. The caller must be one of: * A user with **USE_RECIPIENT** privilege on the metastore * The owner of the share recipient * A metastore admin"""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.recipients.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def recipients_list(
        self,
        data_recipient_global_metastore_id: Optional[str] = None,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets an array of all share recipients within the current metastore where:"""
        kwargs: Dict[str, Any] = {}
        if data_recipient_global_metastore_id is not None:
            kwargs['data_recipient_global_metastore_id'] = data_recipient_global_metastore_id
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.recipients.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def recipients_rotate_token(self, name: str, existing_token_expire_in_seconds: int) -> DatabricksResponse:
        """Refreshes the specified recipient's delta sharing authentication token with the provided token info. The caller must be the owner of the recipient."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['existing_token_expire_in_seconds'] = existing_token_expire_in_seconds
        try:
            result = self._ws.recipients.rotate_token(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def recipients_share_permissions(
        self,
        name: str,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets the share permissions for the specified Recipient. The caller must have the **USE_RECIPIENT** privilege on the metastore or be the owner of the Recipient."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = self._ws.recipients.share_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def recipients_update(
        self,
        name: str,
        comment: Optional[str] = None,
        expiration_time: Optional[int] = None,
        ip_access_list: Optional[Dict[str, Any]] = None,
        new_name: Optional[str] = None,
        owner: Optional[str] = None,
        properties_kvpairs: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Updates an existing recipient in the metastore. The caller must be a metastore admin or the owner of the recipient. If the recipient name will be updated, the user must be both a metastore admin an..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if comment is not None:
            kwargs['comment'] = comment
        if expiration_time is not None:
            kwargs['expiration_time'] = expiration_time
        if ip_access_list is not None:
            kwargs['ip_access_list'] = ip_access_list
        if new_name is not None:
            kwargs['new_name'] = new_name
        if owner is not None:
            kwargs['owner'] = owner
        if properties_kvpairs is not None:
            kwargs['properties_kvpairs'] = properties_kvpairs
        try:
            result = self._ws.recipients.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # REDASH CONFIG (RedashConfigAPI) — 1 methods
    # ============================================================================

    async def redash_config_get_config(self) -> DatabricksResponse:
        """Read workspace configuration for Redash-v2."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.redash_config.get_config(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # REGISTERED MODELS (RegisteredModelsAPI) — 7 methods
    # ============================================================================

    async def registered_models_create(
        self,
        aliases: Optional[List[Dict[str, Any]]] = None,
        browse_only: Optional[bool] = None,
        catalog_name: Optional[str] = None,
        comment: Optional[str] = None,
        created_at: Optional[int] = None,
        created_by: Optional[str] = None,
        full_name: Optional[str] = None,
        metastore_id: Optional[str] = None,
        name: Optional[str] = None,
        owner: Optional[str] = None,
        schema_name: Optional[str] = None,
        storage_location: Optional[str] = None,
        updated_at: Optional[int] = None,
        updated_by: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new registered model in Unity Catalog."""
        kwargs: Dict[str, Any] = {}
        if aliases is not None:
            kwargs['aliases'] = aliases
        if browse_only is not None:
            kwargs['browse_only'] = browse_only
        if catalog_name is not None:
            kwargs['catalog_name'] = catalog_name
        if comment is not None:
            kwargs['comment'] = comment
        if created_at is not None:
            kwargs['created_at'] = created_at
        if created_by is not None:
            kwargs['created_by'] = created_by
        if full_name is not None:
            kwargs['full_name'] = full_name
        if metastore_id is not None:
            kwargs['metastore_id'] = metastore_id
        if name is not None:
            kwargs['name'] = name
        if owner is not None:
            kwargs['owner'] = owner
        if schema_name is not None:
            kwargs['schema_name'] = schema_name
        if storage_location is not None:
            kwargs['storage_location'] = storage_location
        if updated_at is not None:
            kwargs['updated_at'] = updated_at
        if updated_by is not None:
            kwargs['updated_by'] = updated_by
        try:
            result = self._ws.registered_models.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def registered_models_delete(self, full_name: str) -> DatabricksResponse:
        """Deletes a registered model and all its model versions from the specified parent catalog and schema."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        try:
            result = self._ws.registered_models.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def registered_models_delete_alias(self, full_name: str, alias: str) -> DatabricksResponse:
        """Deletes a registered model alias."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        kwargs['alias'] = alias
        try:
            result = self._ws.registered_models.delete_alias(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def registered_models_get(
        self,
        full_name: str,
        include_aliases: Optional[bool] = None,
        include_browse: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Get a registered model."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        if include_aliases is not None:
            kwargs['include_aliases'] = include_aliases
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        try:
            result = self._ws.registered_models.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def registered_models_list(
        self,
        catalog_name: Optional[str] = None,
        include_browse: Optional[bool] = None,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
        schema_name: Optional[str] = None,
    ) -> DatabricksResponse:
        """List registered models. You can list registered models under a particular schema, or list all registered models in the current metastore."""
        kwargs: Dict[str, Any] = {}
        if catalog_name is not None:
            kwargs['catalog_name'] = catalog_name
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        if schema_name is not None:
            kwargs['schema_name'] = schema_name
        try:
            result = list(self._ws.registered_models.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def registered_models_set_alias(
        self,
        full_name: str,
        alias: str,
        version_num: int,
    ) -> DatabricksResponse:
        """Set an alias on the specified registered model."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        kwargs['alias'] = alias
        kwargs['version_num'] = version_num
        try:
            result = self._ws.registered_models.set_alias(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def registered_models_update(
        self,
        full_name: str,
        aliases: Optional[List[Dict[str, Any]]] = None,
        browse_only: Optional[bool] = None,
        catalog_name: Optional[str] = None,
        comment: Optional[str] = None,
        created_at: Optional[int] = None,
        created_by: Optional[str] = None,
        metastore_id: Optional[str] = None,
        name: Optional[str] = None,
        new_name: Optional[str] = None,
        owner: Optional[str] = None,
        schema_name: Optional[str] = None,
        storage_location: Optional[str] = None,
        updated_at: Optional[int] = None,
        updated_by: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates the specified registered model."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        if aliases is not None:
            kwargs['aliases'] = aliases
        if browse_only is not None:
            kwargs['browse_only'] = browse_only
        if catalog_name is not None:
            kwargs['catalog_name'] = catalog_name
        if comment is not None:
            kwargs['comment'] = comment
        if created_at is not None:
            kwargs['created_at'] = created_at
        if created_by is not None:
            kwargs['created_by'] = created_by
        if metastore_id is not None:
            kwargs['metastore_id'] = metastore_id
        if name is not None:
            kwargs['name'] = name
        if new_name is not None:
            kwargs['new_name'] = new_name
        if owner is not None:
            kwargs['owner'] = owner
        if schema_name is not None:
            kwargs['schema_name'] = schema_name
        if storage_location is not None:
            kwargs['storage_location'] = storage_location
        if updated_at is not None:
            kwargs['updated_at'] = updated_at
        if updated_by is not None:
            kwargs['updated_by'] = updated_by
        try:
            result = self._ws.registered_models.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # REPOS (ReposAPI) — 9 methods
    # ============================================================================

    async def repos_create(
        self,
        url: str,
        provider: str,
        path: Optional[str] = None,
        sparse_checkout: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Creates a repo in the workspace and links it to the remote Git repo specified. Note that repos created programmatically must be linked to a remote Git repo, unlike repos created in the browser."""
        kwargs: Dict[str, Any] = {}
        kwargs['url'] = url
        kwargs['provider'] = provider
        if path is not None:
            kwargs['path'] = path
        if sparse_checkout is not None:
            kwargs['sparse_checkout'] = sparse_checkout
        try:
            result = self._ws.repos.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def repos_delete(self, repo_id: int) -> DatabricksResponse:
        """Deletes the specified repo."""
        kwargs: Dict[str, Any] = {}
        kwargs['repo_id'] = repo_id
        try:
            result = self._ws.repos.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def repos_get(self, repo_id: int) -> DatabricksResponse:
        """Returns the repo with the given repo ID."""
        kwargs: Dict[str, Any] = {}
        kwargs['repo_id'] = repo_id
        try:
            result = self._ws.repos.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def repos_get_permission_levels(self, repo_id: str) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        kwargs['repo_id'] = repo_id
        try:
            result = self._ws.repos.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def repos_get_permissions(self, repo_id: str) -> DatabricksResponse:
        """Gets the permissions of a repo. Repos can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['repo_id'] = repo_id
        try:
            result = self._ws.repos.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def repos_list(self, next_page_token: Optional[str] = None, path_prefix: Optional[str] = None) -> DatabricksResponse:
        """Returns repos that the calling user has Manage permissions on. Use `next_page_token` to iterate through additional pages."""
        kwargs: Dict[str, Any] = {}
        if next_page_token is not None:
            kwargs['next_page_token'] = next_page_token
        if path_prefix is not None:
            kwargs['path_prefix'] = path_prefix
        try:
            result = list(self._ws.repos.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def repos_set_permissions(
        self,
        repo_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['repo_id'] = repo_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.repos.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def repos_update(
        self,
        repo_id: int,
        branch: Optional[str] = None,
        sparse_checkout: Optional[Dict[str, Any]] = None,
        tag: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates the repo to a different branch or tag, or updates the repo to the latest commit on the same branch."""
        kwargs: Dict[str, Any] = {}
        kwargs['repo_id'] = repo_id
        if branch is not None:
            kwargs['branch'] = branch
        if sparse_checkout is not None:
            kwargs['sparse_checkout'] = sparse_checkout
        if tag is not None:
            kwargs['tag'] = tag
        try:
            result = self._ws.repos.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def repos_update_permissions(
        self,
        repo_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on a repo. Repos can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['repo_id'] = repo_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.repos.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # RESOURCE QUOTAS (ResourceQuotasAPI) — 2 methods
    # ============================================================================

    async def resource_quotas_get_quota(
        self,
        parent_securable_type: str,
        parent_full_name: str,
        quota_name: str,
    ) -> DatabricksResponse:
        """The GetQuota API returns usage information for a single resource quota, defined as a child-parent pair. This API also refreshes the quota count if it is out of date. Refreshes are triggered asynchr..."""
        kwargs: Dict[str, Any] = {}
        kwargs['parent_securable_type'] = parent_securable_type
        kwargs['parent_full_name'] = parent_full_name
        kwargs['quota_name'] = quota_name
        try:
            result = self._ws.resource_quotas.get_quota(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def resource_quotas_list_quotas(self, max_results: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """ListQuotas returns all quota values under the metastore. There are no SLAs on the freshness of the counts returned. This API does not trigger a refresh of quota counts."""
        kwargs: Dict[str, Any] = {}
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.resource_quotas.list_quotas(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # RFA (RfaAPI) — 3 methods
    # ============================================================================

    async def rfa_batch_create_access_requests(
        self,
        requests: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Creates access requests for Unity Catalog permissions for a specified principal on a securable object. This Batch API can take in multiple principals, securable objects, and permissions as the inpu..."""
        kwargs: Dict[str, Any] = {}
        if requests is not None:
            kwargs['requests'] = requests
        try:
            result = self._ws.rfa.batch_create_access_requests(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def rfa_get_access_request_destinations(self, securable_type: str, full_name: str) -> DatabricksResponse:
        """Gets an array of access request destinations for the specified securable. Any caller can see URL destinations or the destinations on the metastore. Otherwise, only those with **BROWSE** permissions..."""
        kwargs: Dict[str, Any] = {}
        kwargs['securable_type'] = securable_type
        kwargs['full_name'] = full_name
        try:
            result = self._ws.rfa.get_access_request_destinations(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def rfa_update_access_request_destinations(
        self,
        access_request_destinations: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Updates the access request destinations for the given securable. The caller must be a metastore admin, the owner of the securable, or a user that has the **MANAGE** privilege on the securable in or..."""
        kwargs: Dict[str, Any] = {}
        kwargs['access_request_destinations'] = access_request_destinations
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.rfa.update_access_request_destinations(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # SCHEMAS (SchemasAPI) — 5 methods
    # ============================================================================

    async def schemas_create(
        self,
        name: str,
        catalog_name: str,
        comment: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
        storage_root: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new schema for catalog in the Metastore. The caller must be a metastore admin, or have the **CREATE_SCHEMA** privilege in the parent catalog."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['catalog_name'] = catalog_name
        if comment is not None:
            kwargs['comment'] = comment
        if properties is not None:
            kwargs['properties'] = properties
        if storage_root is not None:
            kwargs['storage_root'] = storage_root
        try:
            result = self._ws.schemas.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def schemas_delete(self, full_name: str, force: Optional[bool] = None) -> DatabricksResponse:
        """Deletes the specified schema from the parent catalog. The caller must be the owner of the schema or an owner of the parent catalog."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        if force is not None:
            kwargs['force'] = force
        try:
            result = self._ws.schemas.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def schemas_get(self, full_name: str, include_browse: Optional[bool] = None) -> DatabricksResponse:
        """Gets the specified schema within the metastore. The caller must be a metastore admin, the owner of the schema, or a user that has the **USE_SCHEMA** privilege on the schema."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        try:
            result = self._ws.schemas.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def schemas_list(
        self,
        catalog_name: str,
        include_browse: Optional[bool] = None,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets an array of schemas for a catalog in the metastore. If the caller is the metastore admin or the owner of the parent catalog, all schemas for the catalog will be retrieved. Otherwise, only sche..."""
        kwargs: Dict[str, Any] = {}
        kwargs['catalog_name'] = catalog_name
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.schemas.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def schemas_update(
        self,
        full_name: str,
        comment: Optional[str] = None,
        enable_predictive_optimization: Optional[Dict[str, Any]] = None,
        new_name: Optional[str] = None,
        owner: Optional[str] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> DatabricksResponse:
        """Updates a schema for a catalog. The caller must be the owner of the schema or a metastore admin. If the caller is a metastore admin, only the __owner__ field can be changed in the update. If the __..."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        if comment is not None:
            kwargs['comment'] = comment
        if enable_predictive_optimization is not None:
            kwargs['enable_predictive_optimization'] = enable_predictive_optimization
        if new_name is not None:
            kwargs['new_name'] = new_name
        if owner is not None:
            kwargs['owner'] = owner
        if properties is not None:
            kwargs['properties'] = properties
        try:
            result = self._ws.schemas.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # SECRETS (SecretsAPI) — 11 methods
    # ============================================================================

    async def secrets_create_scope(
        self,
        scope: str,
        backend_azure_keyvault: Optional[Dict[str, Any]] = None,
        initial_manage_principal: Optional[str] = None,
        scope_backend_type: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Creates a new secret scope."""
        kwargs: Dict[str, Any] = {}
        kwargs['scope'] = scope
        if backend_azure_keyvault is not None:
            kwargs['backend_azure_keyvault'] = backend_azure_keyvault
        if initial_manage_principal is not None:
            kwargs['initial_manage_principal'] = initial_manage_principal
        if scope_backend_type is not None:
            kwargs['scope_backend_type'] = scope_backend_type
        try:
            result = self._ws.secrets.create_scope(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def secrets_delete_acl(self, scope: str, principal: str) -> DatabricksResponse:
        """Deletes the given ACL on the given scope."""
        kwargs: Dict[str, Any] = {}
        kwargs['scope'] = scope
        kwargs['principal'] = principal
        try:
            result = self._ws.secrets.delete_acl(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def secrets_delete_scope(self, scope: str) -> DatabricksResponse:
        """Deletes a secret scope."""
        kwargs: Dict[str, Any] = {}
        kwargs['scope'] = scope
        try:
            result = self._ws.secrets.delete_scope(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def secrets_delete_secret(self, scope: str, key: str) -> DatabricksResponse:
        """Deletes the secret stored in this secret scope. You must have ``WRITE`` or ``MANAGE`` permission on the Secret Scope."""
        kwargs: Dict[str, Any] = {}
        kwargs['scope'] = scope
        kwargs['key'] = key
        try:
            result = self._ws.secrets.delete_secret(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def secrets_get_acl(self, scope: str, principal: str) -> DatabricksResponse:
        """Describes the details about the given ACL, such as the group and permission."""
        kwargs: Dict[str, Any] = {}
        kwargs['scope'] = scope
        kwargs['principal'] = principal
        try:
            result = self._ws.secrets.get_acl(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def secrets_get_secret(self, scope: str, key: str) -> DatabricksResponse:
        """Gets a secret for a given key and scope. This API can only be called from the DBUtils interface. Users need the READ permission to make this call."""
        kwargs: Dict[str, Any] = {}
        kwargs['scope'] = scope
        kwargs['key'] = key
        try:
            result = self._ws.secrets.get_secret(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def secrets_list_acls(self, scope: str) -> DatabricksResponse:
        """Lists the ACLs set on the given scope."""
        kwargs: Dict[str, Any] = {}
        kwargs['scope'] = scope
        try:
            result = list(self._ws.secrets.list_acls(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def secrets_list_scopes(self) -> DatabricksResponse:
        """Lists all secret scopes available in the workspace."""
        kwargs: Dict[str, Any] = {}
        try:
            result = list(self._ws.secrets.list_scopes(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def secrets_list_secrets(self, scope: str) -> DatabricksResponse:
        """Lists the secret keys that are stored at this scope. This is a metadata-only operation; secret data cannot be retrieved using this API. Users need the READ permission to make this call."""
        kwargs: Dict[str, Any] = {}
        kwargs['scope'] = scope
        try:
            result = list(self._ws.secrets.list_secrets(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def secrets_put_acl(
        self,
        scope: str,
        principal: str,
        permission: Dict[str, Any],
    ) -> DatabricksResponse:
        """Creates or overwrites the ACL associated with the given principal (user or group) on the specified scope point. In general, a user or group will use the most powerful permission available to them, ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['scope'] = scope
        kwargs['principal'] = principal
        kwargs['permission'] = permission
        try:
            result = self._ws.secrets.put_acl(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def secrets_put_secret(
        self,
        scope: str,
        key: str,
        bytes_value: Optional[str] = None,
        string_value: Optional[str] = None,
    ) -> DatabricksResponse:
        """Inserts a secret under the provided scope with the given name. If a secret already exists with the same name, this command overwrites the existing secret's value. The server encrypts the secret usi..."""
        kwargs: Dict[str, Any] = {}
        kwargs['scope'] = scope
        kwargs['key'] = key
        if bytes_value is not None:
            kwargs['bytes_value'] = bytes_value
        if string_value is not None:
            kwargs['string_value'] = string_value
        try:
            result = self._ws.secrets.put_secret(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # SERVICE PRINCIPAL SECRETS PROXY (ServicePrincipalSecretsProxyAPI) — 3 methods
    # ============================================================================

    async def service_principal_secrets_proxy_create(self, service_principal_id: str, lifetime: Optional[str] = None) -> DatabricksResponse:
        """Create a secret for the given service principal."""
        kwargs: Dict[str, Any] = {}
        kwargs['service_principal_id'] = service_principal_id
        if lifetime is not None:
            kwargs['lifetime'] = lifetime
        try:
            result = self._ws.service_principal_secrets_proxy.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def service_principal_secrets_proxy_delete(self, service_principal_id: str, secret_id: str) -> DatabricksResponse:
        """Delete a secret from the given service principal."""
        kwargs: Dict[str, Any] = {}
        kwargs['service_principal_id'] = service_principal_id
        kwargs['secret_id'] = secret_id
        try:
            result = self._ws.service_principal_secrets_proxy.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def service_principal_secrets_proxy_list(
        self,
        service_principal_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List all secrets associated with the given service principal. This operation only returns information about the secrets themselves and does not include the secret values."""
        kwargs: Dict[str, Any] = {}
        kwargs['service_principal_id'] = service_principal_id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.service_principal_secrets_proxy.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # SERVICE PRINCIPALS (ServicePrincipalsAPI) — 6 methods
    # ============================================================================

    async def service_principals_create(
        self,
        active: Optional[bool] = None,
        application_id: Optional[str] = None,
        display_name: Optional[str] = None,
        entitlements: Optional[List[Dict[str, Any]]] = None,
        external_id: Optional[str] = None,
        groups: Optional[List[Dict[str, Any]]] = None,
        id: Optional[str] = None,
        roles: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Creates a new service principal in the Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        if active is not None:
            kwargs['active'] = active
        if application_id is not None:
            kwargs['application_id'] = application_id
        if display_name is not None:
            kwargs['display_name'] = display_name
        if entitlements is not None:
            kwargs['entitlements'] = entitlements
        if external_id is not None:
            kwargs['external_id'] = external_id
        if groups is not None:
            kwargs['groups'] = groups
        if id is not None:
            kwargs['id'] = id
        if roles is not None:
            kwargs['roles'] = roles
        if schemas is not None:
            kwargs['schemas'] = schemas
        try:
            result = self._ws.service_principals.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def service_principals_delete(self, id: str) -> DatabricksResponse:
        """Delete a single service principal in the Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.service_principals.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def service_principals_get(self, id: str) -> DatabricksResponse:
        """Gets the details for a single service principal define in the Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.service_principals.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def service_principals_list(
        self,
        attributes: Optional[str] = None,
        count: Optional[int] = None,
        excluded_attributes: Optional[str] = None,
        filter: Optional[str] = None,
        sort_by: Optional[str] = None,
        sort_order: Optional[Dict[str, Any]] = None,
        start_index: Optional[int] = None,
    ) -> DatabricksResponse:
        """Gets the set of service principals associated with a Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        if attributes is not None:
            kwargs['attributes'] = attributes
        if count is not None:
            kwargs['count'] = count
        if excluded_attributes is not None:
            kwargs['excluded_attributes'] = excluded_attributes
        if filter is not None:
            kwargs['filter'] = filter
        if sort_by is not None:
            kwargs['sort_by'] = sort_by
        if sort_order is not None:
            kwargs['sort_order'] = sort_order
        if start_index is not None:
            kwargs['start_index'] = start_index
        try:
            result = list(self._ws.service_principals.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def service_principals_patch(
        self,
        id: str,
        operations: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Partially updates the details of a single service principal in the Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if operations is not None:
            kwargs['operations'] = operations
        if schemas is not None:
            kwargs['schemas'] = schemas
        try:
            result = self._ws.service_principals.patch(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def service_principals_update(
        self,
        id: str,
        active: Optional[bool] = None,
        application_id: Optional[str] = None,
        display_name: Optional[str] = None,
        entitlements: Optional[List[Dict[str, Any]]] = None,
        external_id: Optional[str] = None,
        groups: Optional[List[Dict[str, Any]]] = None,
        roles: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the details of a single service principal."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if active is not None:
            kwargs['active'] = active
        if application_id is not None:
            kwargs['application_id'] = application_id
        if display_name is not None:
            kwargs['display_name'] = display_name
        if entitlements is not None:
            kwargs['entitlements'] = entitlements
        if external_id is not None:
            kwargs['external_id'] = external_id
        if groups is not None:
            kwargs['groups'] = groups
        if roles is not None:
            kwargs['roles'] = roles
        if schemas is not None:
            kwargs['schemas'] = schemas
        try:
            result = self._ws.service_principals.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # SERVICE PRINCIPALS V2 (ServicePrincipalsV2API) — 6 methods
    # ============================================================================

    async def service_principals_v2_create(
        self,
        active: Optional[bool] = None,
        application_id: Optional[str] = None,
        display_name: Optional[str] = None,
        entitlements: Optional[List[Dict[str, Any]]] = None,
        external_id: Optional[str] = None,
        groups: Optional[List[Dict[str, Any]]] = None,
        id: Optional[str] = None,
        roles: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Creates a new service principal in the Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        if active is not None:
            kwargs['active'] = active
        if application_id is not None:
            kwargs['application_id'] = application_id
        if display_name is not None:
            kwargs['display_name'] = display_name
        if entitlements is not None:
            kwargs['entitlements'] = entitlements
        if external_id is not None:
            kwargs['external_id'] = external_id
        if groups is not None:
            kwargs['groups'] = groups
        if id is not None:
            kwargs['id'] = id
        if roles is not None:
            kwargs['roles'] = roles
        if schemas is not None:
            kwargs['schemas'] = schemas
        try:
            result = self._ws.service_principals_v2.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def service_principals_v2_delete(self, id: str) -> DatabricksResponse:
        """Delete a single service principal in the Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.service_principals_v2.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def service_principals_v2_get(self, id: str) -> DatabricksResponse:
        """Gets the details for a single service principal define in the Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.service_principals_v2.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def service_principals_v2_list(
        self,
        attributes: Optional[str] = None,
        count: Optional[int] = None,
        excluded_attributes: Optional[str] = None,
        filter: Optional[str] = None,
        sort_by: Optional[str] = None,
        sort_order: Optional[Dict[str, Any]] = None,
        start_index: Optional[int] = None,
    ) -> DatabricksResponse:
        """Gets the set of service principals associated with a Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        if attributes is not None:
            kwargs['attributes'] = attributes
        if count is not None:
            kwargs['count'] = count
        if excluded_attributes is not None:
            kwargs['excluded_attributes'] = excluded_attributes
        if filter is not None:
            kwargs['filter'] = filter
        if sort_by is not None:
            kwargs['sort_by'] = sort_by
        if sort_order is not None:
            kwargs['sort_order'] = sort_order
        if start_index is not None:
            kwargs['start_index'] = start_index
        try:
            result = list(self._ws.service_principals_v2.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def service_principals_v2_patch(
        self,
        id: str,
        operations: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Partially updates the details of a single service principal in the Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if operations is not None:
            kwargs['operations'] = operations
        if schemas is not None:
            kwargs['schemas'] = schemas
        try:
            result = self._ws.service_principals_v2.patch(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def service_principals_v2_update(
        self,
        id: str,
        active: Optional[bool] = None,
        application_id: Optional[str] = None,
        display_name: Optional[str] = None,
        entitlements: Optional[List[Dict[str, Any]]] = None,
        external_id: Optional[str] = None,
        groups: Optional[List[Dict[str, Any]]] = None,
        roles: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the details of a single service principal."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if active is not None:
            kwargs['active'] = active
        if application_id is not None:
            kwargs['application_id'] = application_id
        if display_name is not None:
            kwargs['display_name'] = display_name
        if entitlements is not None:
            kwargs['entitlements'] = entitlements
        if external_id is not None:
            kwargs['external_id'] = external_id
        if groups is not None:
            kwargs['groups'] = groups
        if roles is not None:
            kwargs['roles'] = roles
        if schemas is not None:
            kwargs['schemas'] = schemas
        try:
            result = self._ws.service_principals_v2.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # SERVING ENDPOINTS (ServingEndpointsExt) — 21 methods
    # ============================================================================

    async def serving_endpoints_build_logs(self, name: str, served_model_name: str) -> DatabricksResponse:
        """Retrieves the build logs associated with the provided served model."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['served_model_name'] = served_model_name
        try:
            result = self._ws.serving_endpoints.build_logs(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_create(
        self,
        name: str,
        ai_gateway: Optional[Dict[str, Any]] = None,
        budget_policy_id: Optional[str] = None,
        config: Optional[Dict[str, Any]] = None,
        description: Optional[str] = None,
        email_notifications: Optional[Dict[str, Any]] = None,
        rate_limits: Optional[List[Dict[str, Any]]] = None,
        route_optimized: Optional[bool] = None,
        tags: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Create a new serving endpoint."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if ai_gateway is not None:
            kwargs['ai_gateway'] = ai_gateway
        if budget_policy_id is not None:
            kwargs['budget_policy_id'] = budget_policy_id
        if config is not None:
            kwargs['config'] = config
        if description is not None:
            kwargs['description'] = description
        if email_notifications is not None:
            kwargs['email_notifications'] = email_notifications
        if rate_limits is not None:
            kwargs['rate_limits'] = rate_limits
        if route_optimized is not None:
            kwargs['route_optimized'] = route_optimized
        if tags is not None:
            kwargs['tags'] = tags
        try:
            result = self._ws.serving_endpoints.create(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_create_provisioned_throughput_endpoint(
        self,
        name: str,
        config: Dict[str, Any],
        ai_gateway: Optional[Dict[str, Any]] = None,
        budget_policy_id: Optional[str] = None,
        email_notifications: Optional[Dict[str, Any]] = None,
        tags: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Create a new PT serving endpoint."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['config'] = config
        if ai_gateway is not None:
            kwargs['ai_gateway'] = ai_gateway
        if budget_policy_id is not None:
            kwargs['budget_policy_id'] = budget_policy_id
        if email_notifications is not None:
            kwargs['email_notifications'] = email_notifications
        if tags is not None:
            kwargs['tags'] = tags
        try:
            result = self._ws.serving_endpoints.create_provisioned_throughput_endpoint(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_delete(self, name: str) -> DatabricksResponse:
        """Delete a serving endpoint."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.serving_endpoints.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_export_metrics(self, name: str) -> DatabricksResponse:
        """Retrieves the metrics associated with the provided serving endpoint in either Prometheus or OpenMetrics exposition format."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.serving_endpoints.export_metrics(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_get(self, name: str) -> DatabricksResponse:
        """Retrieves the details for a single serving endpoint."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.serving_endpoints.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_get_open_api(self, name: str) -> DatabricksResponse:
        """Get the query schema of the serving endpoint in OpenAPI format. The schema contains information for the supported paths, input and output format and datatypes."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.serving_endpoints.get_open_api(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_get_permission_levels(self, serving_endpoint_id: str) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        kwargs['serving_endpoint_id'] = serving_endpoint_id
        try:
            result = self._ws.serving_endpoints.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_get_permissions(self, serving_endpoint_id: str) -> DatabricksResponse:
        """Gets the permissions of a serving endpoint. Serving endpoints can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['serving_endpoint_id'] = serving_endpoint_id
        try:
            result = self._ws.serving_endpoints.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_http_request(
        self,
        conn: str,
        method: Dict[str, Any],
        path: str,
        headers: Optional[Dict[str, str]] = None,
        json: Optional[Dict[str, str]] = None,
        params: Optional[Dict[str, str]] = None,
    ) -> DatabricksResponse:
        """Make external services call using the credentials stored in UC Connection. **NOTE:** Experimental: This API may change or be removed in a future release without warning. :param conn: str   The conn..."""
        kwargs: Dict[str, Any] = {}
        kwargs['conn'] = conn
        kwargs['method'] = method
        kwargs['path'] = path
        if headers is not None:
            kwargs['headers'] = headers
        if json is not None:
            kwargs['json'] = json
        if params is not None:
            kwargs['params'] = params
        try:
            result = self._ws.serving_endpoints.http_request(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_list(self) -> DatabricksResponse:
        """Get all serving endpoints."""
        kwargs: Dict[str, Any] = {}
        try:
            result = list(self._ws.serving_endpoints.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_logs(self, name: str, served_model_name: str) -> DatabricksResponse:
        """Retrieves the service logs associated with the provided served model."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['served_model_name'] = served_model_name
        try:
            result = self._ws.serving_endpoints.logs(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_patch(
        self,
        name: str,
        add_tags: Optional[List[Dict[str, Any]]] = None,
        delete_tags: Optional[List[str]] = None,
    ) -> DatabricksResponse:
        """Used to batch add and delete tags from a serving endpoint with a single API call."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if add_tags is not None:
            kwargs['add_tags'] = add_tags
        if delete_tags is not None:
            kwargs['delete_tags'] = delete_tags
        try:
            result = self._ws.serving_endpoints.patch(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_put(
        self,
        name: str,
        rate_limits: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Deprecated: Please use AI Gateway to manage rate limits instead."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if rate_limits is not None:
            kwargs['rate_limits'] = rate_limits
        try:
            result = self._ws.serving_endpoints.put(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_put_ai_gateway(
        self,
        name: str,
        fallback_config: Optional[Dict[str, Any]] = None,
        guardrails: Optional[Dict[str, Any]] = None,
        inference_table_config: Optional[Dict[str, Any]] = None,
        rate_limits: Optional[List[Dict[str, Any]]] = None,
        usage_tracking_config: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Used to update the AI Gateway of a serving endpoint. NOTE: External model, provisioned throughput, and pay-per-token endpoints are fully supported; agent endpoints currently only support inference ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if fallback_config is not None:
            kwargs['fallback_config'] = fallback_config
        if guardrails is not None:
            kwargs['guardrails'] = guardrails
        if inference_table_config is not None:
            kwargs['inference_table_config'] = inference_table_config
        if rate_limits is not None:
            kwargs['rate_limits'] = rate_limits
        if usage_tracking_config is not None:
            kwargs['usage_tracking_config'] = usage_tracking_config
        try:
            result = self._ws.serving_endpoints.put_ai_gateway(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_query(
        self,
        name: str,
        client_request_id: Optional[str] = None,
        dataframe_records: Optional[List[Any]] = None,
        dataframe_split: Optional[Dict[str, Any]] = None,
        extra_params: Optional[Dict[str, str]] = None,
        input: Optional[Any] = None,
        inputs: Optional[Any] = None,
        instances: Optional[List[Any]] = None,
        max_tokens: Optional[int] = None,
        messages: Optional[List[Dict[str, Any]]] = None,
        n: Optional[int] = None,
        prompt: Optional[Any] = None,
        stop: Optional[List[str]] = None,
        stream: Optional[bool] = None,
        temperature: Optional[float] = None,
        usage_context: Optional[Dict[str, str]] = None,
    ) -> DatabricksResponse:
        """Query a serving endpoint"""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if client_request_id is not None:
            kwargs['client_request_id'] = client_request_id
        if dataframe_records is not None:
            kwargs['dataframe_records'] = dataframe_records
        if dataframe_split is not None:
            kwargs['dataframe_split'] = dataframe_split
        if extra_params is not None:
            kwargs['extra_params'] = extra_params
        if input is not None:
            kwargs['input'] = input
        if inputs is not None:
            kwargs['inputs'] = inputs
        if instances is not None:
            kwargs['instances'] = instances
        if max_tokens is not None:
            kwargs['max_tokens'] = max_tokens
        if messages is not None:
            kwargs['messages'] = messages
        if n is not None:
            kwargs['n'] = n
        if prompt is not None:
            kwargs['prompt'] = prompt
        if stop is not None:
            kwargs['stop'] = stop
        if stream is not None:
            kwargs['stream'] = stream
        if temperature is not None:
            kwargs['temperature'] = temperature
        if usage_context is not None:
            kwargs['usage_context'] = usage_context
        try:
            result = self._ws.serving_endpoints.query(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_set_permissions(
        self,
        serving_endpoint_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['serving_endpoint_id'] = serving_endpoint_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.serving_endpoints.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_update_config(
        self,
        name: str,
        auto_capture_config: Optional[Dict[str, Any]] = None,
        served_entities: Optional[List[Dict[str, Any]]] = None,
        served_models: Optional[List[Dict[str, Any]]] = None,
        traffic_config: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Updates any combination of the serving endpoint's served entities, the compute configuration of those served entities, and the endpoint's traffic config. An endpoint that already has an update in p..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if auto_capture_config is not None:
            kwargs['auto_capture_config'] = auto_capture_config
        if served_entities is not None:
            kwargs['served_entities'] = served_entities
        if served_models is not None:
            kwargs['served_models'] = served_models
        if traffic_config is not None:
            kwargs['traffic_config'] = traffic_config
        try:
            result = self._ws.serving_endpoints.update_config(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_update_notifications(
        self,
        name: str,
        email_notifications: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Updates the email and webhook notification settings for an endpoint."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if email_notifications is not None:
            kwargs['email_notifications'] = email_notifications
        try:
            result = self._ws.serving_endpoints.update_notifications(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_update_permissions(
        self,
        serving_endpoint_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on a serving endpoint. Serving endpoints can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['serving_endpoint_id'] = serving_endpoint_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.serving_endpoints.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def serving_endpoints_update_provisioned_throughput_endpoint_config(self, name: str, config: Dict[str, Any]) -> DatabricksResponse:
        """Updates any combination of the pt endpoint's served entities, the compute configuration of those served entities, and the endpoint's traffic config. Updates are instantaneous and endpoint should be..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['config'] = config
        try:
            result = self._ws.serving_endpoints.update_provisioned_throughput_endpoint_config(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # SERVING ENDPOINTS DATA PLANE (ServingEndpointsDataPlaneAPI) — 1 methods
    # ============================================================================

    async def serving_endpoints_data_plane_query(
        self,
        name: str,
        client_request_id: Optional[str] = None,
        dataframe_records: Optional[List[Any]] = None,
        dataframe_split: Optional[Dict[str, Any]] = None,
        extra_params: Optional[Dict[str, str]] = None,
        input: Optional[Any] = None,
        inputs: Optional[Any] = None,
        instances: Optional[List[Any]] = None,
        max_tokens: Optional[int] = None,
        messages: Optional[List[Dict[str, Any]]] = None,
        n: Optional[int] = None,
        prompt: Optional[Any] = None,
        stop: Optional[List[str]] = None,
        stream: Optional[bool] = None,
        temperature: Optional[float] = None,
        usage_context: Optional[Dict[str, str]] = None,
    ) -> DatabricksResponse:
        """Query a serving endpoint"""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if client_request_id is not None:
            kwargs['client_request_id'] = client_request_id
        if dataframe_records is not None:
            kwargs['dataframe_records'] = dataframe_records
        if dataframe_split is not None:
            kwargs['dataframe_split'] = dataframe_split
        if extra_params is not None:
            kwargs['extra_params'] = extra_params
        if input is not None:
            kwargs['input'] = input
        if inputs is not None:
            kwargs['inputs'] = inputs
        if instances is not None:
            kwargs['instances'] = instances
        if max_tokens is not None:
            kwargs['max_tokens'] = max_tokens
        if messages is not None:
            kwargs['messages'] = messages
        if n is not None:
            kwargs['n'] = n
        if prompt is not None:
            kwargs['prompt'] = prompt
        if stop is not None:
            kwargs['stop'] = stop
        if stream is not None:
            kwargs['stream'] = stream
        if temperature is not None:
            kwargs['temperature'] = temperature
        if usage_context is not None:
            kwargs['usage_context'] = usage_context
        try:
            result = self._ws.serving_endpoints_data_plane.query(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # SHARES (SharesAPI) — 7 methods
    # ============================================================================

    async def shares_create(
        self,
        name: str,
        comment: Optional[str] = None,
        storage_root: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new share for data objects. Data objects can be added after creation with **update**. The caller must be a metastore admin or have the **CREATE_SHARE** privilege on the metastore."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if comment is not None:
            kwargs['comment'] = comment
        if storage_root is not None:
            kwargs['storage_root'] = storage_root
        try:
            result = self._ws.shares.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def shares_delete(self, name: str) -> DatabricksResponse:
        """Deletes a data object share from the metastore. The caller must be an owner of the share."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.shares.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def shares_get(
        self,
        name: str,
        include_shared_data: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Gets a data object share from the metastore. The caller must have the USE_SHARE privilege on the metastore or be the owner of the share."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if include_shared_data is not None:
            kwargs['include_shared_data'] = include_shared_data
        try:
            result = self._ws.shares.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def shares_list_shares(self, max_results: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Gets an array of data object shares from the metastore. If the caller has the USE_SHARE privilege on the metastore, all shares are returned. Otherwise, only shares owned by the caller are returned...."""
        kwargs: Dict[str, Any] = {}
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.shares.list_shares(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def shares_share_permissions(
        self,
        name: str,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets the permissions for a data share from the metastore. The caller must have the USE_SHARE privilege on the metastore or be the owner of the share."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = self._ws.shares.share_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def shares_update(
        self,
        name: str,
        comment: Optional[str] = None,
        new_name: Optional[str] = None,
        owner: Optional[str] = None,
        storage_root: Optional[str] = None,
        updates: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the share with the changes and data objects in the request. The caller must be the owner of the share or a metastore admin."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if comment is not None:
            kwargs['comment'] = comment
        if new_name is not None:
            kwargs['new_name'] = new_name
        if owner is not None:
            kwargs['owner'] = owner
        if storage_root is not None:
            kwargs['storage_root'] = storage_root
        if updates is not None:
            kwargs['updates'] = updates
        try:
            result = self._ws.shares.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def shares_update_permissions(
        self,
        name: str,
        changes: Optional[List[Dict[str, Any]]] = None,
        omit_permissions_list: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Updates the permissions for a data share in the metastore. The caller must have both the USE_SHARE and SET_SHARE_PERMISSION privileges on the metastore, or be the owner of the share."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if changes is not None:
            kwargs['changes'] = changes
        if omit_permissions_list is not None:
            kwargs['omit_permissions_list'] = omit_permissions_list
        try:
            result = self._ws.shares.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # STATEMENT EXECUTION (StatementExecutionAPI) — 4 methods
    # ============================================================================

    async def statement_execution_cancel_execution(self, statement_id: str) -> DatabricksResponse:
        """Requests that an executing statement be canceled. Callers must poll for status to see the terminal state. Cancel response is empty; receiving response indicates successful receipt."""
        kwargs: Dict[str, Any] = {}
        kwargs['statement_id'] = statement_id
        try:
            result = self._ws.statement_execution.cancel_execution(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def statement_execution_execute_statement(
        self,
        statement: str,
        warehouse_id: str,
        byte_limit: Optional[int] = None,
        catalog: Optional[str] = None,
        disposition: Optional[Dict[str, Any]] = None,
        format: Optional[Dict[str, Any]] = None,
        on_wait_timeout: Optional[Dict[str, Any]] = None,
        parameters: Optional[List[Dict[str, Any]]] = None,
        row_limit: Optional[int] = None,
        schema: Optional[str] = None,
        wait_timeout: Optional[str] = None,
    ) -> DatabricksResponse:
        """Execute a SQL statement and optionally await its results for a specified time."""
        kwargs: Dict[str, Any] = {}
        kwargs['statement'] = statement
        kwargs['warehouse_id'] = warehouse_id
        if byte_limit is not None:
            kwargs['byte_limit'] = byte_limit
        if catalog is not None:
            kwargs['catalog'] = catalog
        if disposition is not None:
            kwargs['disposition'] = disposition
        if format is not None:
            kwargs['format'] = format
        if on_wait_timeout is not None:
            kwargs['on_wait_timeout'] = on_wait_timeout
        if parameters is not None:
            kwargs['parameters'] = parameters
        if row_limit is not None:
            kwargs['row_limit'] = row_limit
        if schema is not None:
            kwargs['schema'] = schema
        if wait_timeout is not None:
            kwargs['wait_timeout'] = wait_timeout
        try:
            result = self._ws.statement_execution.execute_statement(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def statement_execution_get_statement(self, statement_id: str) -> DatabricksResponse:
        """This request can be used to poll for the statement's status. StatementResponse contains `statement_id` and `status`; other fields might be absent or present depending on context. When the `status.s..."""
        kwargs: Dict[str, Any] = {}
        kwargs['statement_id'] = statement_id
        try:
            result = self._ws.statement_execution.get_statement(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def statement_execution_get_statement_result_chunk_n(self, statement_id: str, chunk_index: int) -> DatabricksResponse:
        """After the statement execution has `SUCCEEDED`, this request can be used to fetch any chunk by index. Whereas the first chunk with `chunk_index=0` is typically fetched with :method:statementexecutio..."""
        kwargs: Dict[str, Any] = {}
        kwargs['statement_id'] = statement_id
        kwargs['chunk_index'] = chunk_index
        try:
            result = self._ws.statement_execution.get_statement_result_chunk_n(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # STORAGE CREDENTIALS (StorageCredentialsAPI) — 6 methods
    # ============================================================================

    async def storage_credentials_create(
        self,
        name: str,
        aws_iam_role: Optional[Dict[str, Any]] = None,
        azure_managed_identity: Optional[Dict[str, Any]] = None,
        azure_service_principal: Optional[Dict[str, Any]] = None,
        cloudflare_api_token: Optional[Dict[str, Any]] = None,
        comment: Optional[str] = None,
        databricks_gcp_service_account: Optional[Dict[str, Any]] = None,
        read_only: Optional[bool] = None,
        skip_validation: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Creates a new storage credential."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if aws_iam_role is not None:
            kwargs['aws_iam_role'] = aws_iam_role
        if azure_managed_identity is not None:
            kwargs['azure_managed_identity'] = azure_managed_identity
        if azure_service_principal is not None:
            kwargs['azure_service_principal'] = azure_service_principal
        if cloudflare_api_token is not None:
            kwargs['cloudflare_api_token'] = cloudflare_api_token
        if comment is not None:
            kwargs['comment'] = comment
        if databricks_gcp_service_account is not None:
            kwargs['databricks_gcp_service_account'] = databricks_gcp_service_account
        if read_only is not None:
            kwargs['read_only'] = read_only
        if skip_validation is not None:
            kwargs['skip_validation'] = skip_validation
        try:
            result = self._ws.storage_credentials.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def storage_credentials_delete(self, name: str, force: Optional[bool] = None) -> DatabricksResponse:
        """Deletes a storage credential from the metastore. The caller must be an owner of the storage credential."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if force is not None:
            kwargs['force'] = force
        try:
            result = self._ws.storage_credentials.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def storage_credentials_get(self, name: str) -> DatabricksResponse:
        """Gets a storage credential from the metastore. The caller must be a metastore admin, the owner of the storage credential, or have some permission on the storage credential."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.storage_credentials.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def storage_credentials_list(
        self,
        include_unbound: Optional[bool] = None,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets an array of storage credentials (as __StorageCredentialInfo__ objects). The array is limited to only those storage credentials the caller has permission to access. If the caller is a metastore..."""
        kwargs: Dict[str, Any] = {}
        if include_unbound is not None:
            kwargs['include_unbound'] = include_unbound
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.storage_credentials.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def storage_credentials_update(
        self,
        name: str,
        aws_iam_role: Optional[Dict[str, Any]] = None,
        azure_managed_identity: Optional[Dict[str, Any]] = None,
        azure_service_principal: Optional[Dict[str, Any]] = None,
        cloudflare_api_token: Optional[Dict[str, Any]] = None,
        comment: Optional[str] = None,
        databricks_gcp_service_account: Optional[Dict[str, Any]] = None,
        force: Optional[bool] = None,
        isolation_mode: Optional[Dict[str, Any]] = None,
        new_name: Optional[str] = None,
        owner: Optional[str] = None,
        read_only: Optional[bool] = None,
        skip_validation: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Updates a storage credential on the metastore."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if aws_iam_role is not None:
            kwargs['aws_iam_role'] = aws_iam_role
        if azure_managed_identity is not None:
            kwargs['azure_managed_identity'] = azure_managed_identity
        if azure_service_principal is not None:
            kwargs['azure_service_principal'] = azure_service_principal
        if cloudflare_api_token is not None:
            kwargs['cloudflare_api_token'] = cloudflare_api_token
        if comment is not None:
            kwargs['comment'] = comment
        if databricks_gcp_service_account is not None:
            kwargs['databricks_gcp_service_account'] = databricks_gcp_service_account
        if force is not None:
            kwargs['force'] = force
        if isolation_mode is not None:
            kwargs['isolation_mode'] = isolation_mode
        if new_name is not None:
            kwargs['new_name'] = new_name
        if owner is not None:
            kwargs['owner'] = owner
        if read_only is not None:
            kwargs['read_only'] = read_only
        if skip_validation is not None:
            kwargs['skip_validation'] = skip_validation
        try:
            result = self._ws.storage_credentials.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def storage_credentials_validate(
        self,
        aws_iam_role: Optional[Dict[str, Any]] = None,
        azure_managed_identity: Optional[Dict[str, Any]] = None,
        azure_service_principal: Optional[Dict[str, Any]] = None,
        cloudflare_api_token: Optional[Dict[str, Any]] = None,
        databricks_gcp_service_account: Optional[Dict[str, Any]] = None,
        external_location_name: Optional[str] = None,
        read_only: Optional[bool] = None,
        storage_credential_name: Optional[str] = None,
        url: Optional[str] = None,
    ) -> DatabricksResponse:
        """Validates a storage credential. At least one of __external_location_name__ and __url__ need to be provided. If only one of them is provided, it will be used for validation. And if both are provided..."""
        kwargs: Dict[str, Any] = {}
        if aws_iam_role is not None:
            kwargs['aws_iam_role'] = aws_iam_role
        if azure_managed_identity is not None:
            kwargs['azure_managed_identity'] = azure_managed_identity
        if azure_service_principal is not None:
            kwargs['azure_service_principal'] = azure_service_principal
        if cloudflare_api_token is not None:
            kwargs['cloudflare_api_token'] = cloudflare_api_token
        if databricks_gcp_service_account is not None:
            kwargs['databricks_gcp_service_account'] = databricks_gcp_service_account
        if external_location_name is not None:
            kwargs['external_location_name'] = external_location_name
        if read_only is not None:
            kwargs['read_only'] = read_only
        if storage_credential_name is not None:
            kwargs['storage_credential_name'] = storage_credential_name
        if url is not None:
            kwargs['url'] = url
        try:
            result = self._ws.storage_credentials.validate(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # SYSTEM SCHEMAS (SystemSchemasAPI) — 3 methods
    # ============================================================================

    async def system_schemas_disable(self, metastore_id: str, schema_name: str) -> DatabricksResponse:
        """Disables the system schema and removes it from the system catalog. The caller must be an account admin or a metastore admin."""
        kwargs: Dict[str, Any] = {}
        kwargs['metastore_id'] = metastore_id
        kwargs['schema_name'] = schema_name
        try:
            result = self._ws.system_schemas.disable(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def system_schemas_enable(
        self,
        metastore_id: str,
        schema_name: str,
        catalog_name: Optional[str] = None,
    ) -> DatabricksResponse:
        """Enables the system schema and adds it to the system catalog. The caller must be an account admin or a metastore admin."""
        kwargs: Dict[str, Any] = {}
        kwargs['metastore_id'] = metastore_id
        kwargs['schema_name'] = schema_name
        if catalog_name is not None:
            kwargs['catalog_name'] = catalog_name
        try:
            result = self._ws.system_schemas.enable(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def system_schemas_list(
        self,
        metastore_id: str,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets an array of system schemas for a metastore. The caller must be an account admin or a metastore admin."""
        kwargs: Dict[str, Any] = {}
        kwargs['metastore_id'] = metastore_id
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.system_schemas.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # TABLE CONSTRAINTS (TableConstraintsAPI) — 2 methods
    # ============================================================================

    async def table_constraints_create(self, full_name_arg: str, constraint: Dict[str, Any]) -> DatabricksResponse:
        """Creates a new table constraint."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name_arg'] = full_name_arg
        kwargs['constraint'] = constraint
        try:
            result = self._ws.table_constraints.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def table_constraints_delete(
        self,
        full_name: str,
        constraint_name: str,
        cascade: bool,
    ) -> DatabricksResponse:
        """Deletes a table constraint."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        kwargs['constraint_name'] = constraint_name
        kwargs['cascade'] = cascade
        try:
            result = self._ws.table_constraints.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # TABLES (TablesAPI) — 7 methods
    # ============================================================================

    async def tables_create(
        self,
        name: str,
        catalog_name: str,
        schema_name: str,
        table_type: Dict[str, Any],
        data_source_format: Dict[str, Any],
        storage_location: str,
        columns: Optional[List[Dict[str, Any]]] = None,
        properties: Optional[Dict[str, str]] = None,
    ) -> DatabricksResponse:
        """Creates a new table in the specified catalog and schema."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['catalog_name'] = catalog_name
        kwargs['schema_name'] = schema_name
        kwargs['table_type'] = table_type
        kwargs['data_source_format'] = data_source_format
        kwargs['storage_location'] = storage_location
        if columns is not None:
            kwargs['columns'] = columns
        if properties is not None:
            kwargs['properties'] = properties
        try:
            result = self._ws.tables.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def tables_delete(self, full_name: str) -> DatabricksResponse:
        """Deletes a table from the specified parent catalog and schema. The caller must be the owner of the parent catalog, have the **USE_CATALOG** privilege on the parent catalog and be the owner of the pa..."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        try:
            result = self._ws.tables.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def tables_exists(self, full_name: str) -> DatabricksResponse:
        """Gets if a table exists in the metastore for a specific catalog and schema. The caller must satisfy one of the following requirements: * Be a metastore admin * Be the owner of the parent catalog * B..."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        try:
            result = self._ws.tables.exists(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def tables_get(
        self,
        full_name: str,
        include_browse: Optional[bool] = None,
        include_delta_metadata: Optional[bool] = None,
        include_manifest_capabilities: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Gets a table from the metastore for a specific catalog and schema. The caller must satisfy one of the following requirements: * Be a metastore admin * Be the owner of the parent catalog * Be the ow..."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        if include_delta_metadata is not None:
            kwargs['include_delta_metadata'] = include_delta_metadata
        if include_manifest_capabilities is not None:
            kwargs['include_manifest_capabilities'] = include_manifest_capabilities
        try:
            result = self._ws.tables.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def tables_list(
        self,
        catalog_name: str,
        schema_name: str,
        include_browse: Optional[bool] = None,
        include_manifest_capabilities: Optional[bool] = None,
        max_results: Optional[int] = None,
        omit_columns: Optional[bool] = None,
        omit_properties: Optional[bool] = None,
        omit_username: Optional[bool] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets an array of all tables for the current metastore under the parent catalog and schema. The caller must be a metastore admin or an owner of (or have the **SELECT** privilege on) the table. For t..."""
        kwargs: Dict[str, Any] = {}
        kwargs['catalog_name'] = catalog_name
        kwargs['schema_name'] = schema_name
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        if include_manifest_capabilities is not None:
            kwargs['include_manifest_capabilities'] = include_manifest_capabilities
        if max_results is not None:
            kwargs['max_results'] = max_results
        if omit_columns is not None:
            kwargs['omit_columns'] = omit_columns
        if omit_properties is not None:
            kwargs['omit_properties'] = omit_properties
        if omit_username is not None:
            kwargs['omit_username'] = omit_username
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.tables.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def tables_list_summaries(
        self,
        catalog_name: str,
        include_manifest_capabilities: Optional[bool] = None,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
        schema_name_pattern: Optional[str] = None,
        table_name_pattern: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets an array of summaries for tables for a schema and catalog within the metastore. The table summaries returned are either:"""
        kwargs: Dict[str, Any] = {}
        kwargs['catalog_name'] = catalog_name
        if include_manifest_capabilities is not None:
            kwargs['include_manifest_capabilities'] = include_manifest_capabilities
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        if schema_name_pattern is not None:
            kwargs['schema_name_pattern'] = schema_name_pattern
        if table_name_pattern is not None:
            kwargs['table_name_pattern'] = table_name_pattern
        try:
            result = list(self._ws.tables.list_summaries(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def tables_update(self, full_name: str, owner: Optional[str] = None) -> DatabricksResponse:
        """Change the owner of the table. The caller must be the owner of the parent catalog, have the **USE_CATALOG** privilege on the parent catalog and be the owner of the parent schema, or be the owner of..."""
        kwargs: Dict[str, Any] = {}
        kwargs['full_name'] = full_name
        if owner is not None:
            kwargs['owner'] = owner
        try:
            result = self._ws.tables.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # TAG POLICIES (TagPoliciesAPI) — 5 methods
    # ============================================================================

    async def tag_policies_create_tag_policy(self, tag_policy: Dict[str, Any]) -> DatabricksResponse:
        """Creates a new tag policy, making the associated tag key governed. For Terraform usage, see the [Tag Policy Terraform documentation]. To manage permissions for tag policies, use the [Account Access ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['tag_policy'] = tag_policy
        try:
            result = self._ws.tag_policies.create_tag_policy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def tag_policies_delete_tag_policy(self, tag_key: str) -> DatabricksResponse:
        """Deletes a tag policy by its associated governed tag's key, leaving that tag key ungoverned. For Terraform usage, see the [Tag Policy Terraform documentation]."""
        kwargs: Dict[str, Any] = {}
        kwargs['tag_key'] = tag_key
        try:
            result = self._ws.tag_policies.delete_tag_policy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def tag_policies_get_tag_policy(self, tag_key: str) -> DatabricksResponse:
        """Gets a single tag policy by its associated governed tag's key. For Terraform usage, see the [Tag Policy Terraform documentation]. To list granted permissions for tag policies, use the [Account Acce..."""
        kwargs: Dict[str, Any] = {}
        kwargs['tag_key'] = tag_key
        try:
            result = self._ws.tag_policies.get_tag_policy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def tag_policies_list_tag_policies(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Lists the tag policies for all governed tags in the account. For Terraform usage, see the [Tag Policy Terraform documentation]. To list granted permissions for tag policies, use the [Account Access..."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.tag_policies.list_tag_policies(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def tag_policies_update_tag_policy(
        self,
        tag_key: str,
        tag_policy: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Updates an existing tag policy for a single governed tag. For Terraform usage, see the [Tag Policy Terraform documentation]. To manage permissions for tag policies, use the [Account Access Control ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['tag_key'] = tag_key
        kwargs['tag_policy'] = tag_policy
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.tag_policies.update_tag_policy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # TEMPORARY PATH CREDENTIALS (TemporaryPathCredentialsAPI) — 1 methods
    # ============================================================================

    async def temporary_path_credentials_generate_temporary_path_credentials(
        self,
        url: str,
        operation: Dict[str, Any],
        dry_run: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Get a short-lived credential for directly accessing cloud storage locations registered in Databricks. The Generate Temporary Path Credentials API is only supported for external storage paths, speci..."""
        kwargs: Dict[str, Any] = {}
        kwargs['url'] = url
        kwargs['operation'] = operation
        if dry_run is not None:
            kwargs['dry_run'] = dry_run
        try:
            result = self._ws.temporary_path_credentials.generate_temporary_path_credentials(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # TEMPORARY TABLE CREDENTIALS (TemporaryTableCredentialsAPI) — 1 methods
    # ============================================================================

    async def temporary_table_credentials_generate_temporary_table_credentials(
        self,
        operation: Optional[Dict[str, Any]] = None,
        table_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Get a short-lived credential for directly accessing the table data on cloud storage. The metastore must have **external_access_enabled** flag set to true (default false). The caller must have the *..."""
        kwargs: Dict[str, Any] = {}
        if operation is not None:
            kwargs['operation'] = operation
        if table_id is not None:
            kwargs['table_id'] = table_id
        try:
            result = self._ws.temporary_table_credentials.generate_temporary_table_credentials(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # TOKEN MANAGEMENT (TokenManagementAPI) — 8 methods
    # ============================================================================

    async def token_management_create_obo_token(
        self,
        application_id: str,
        comment: Optional[str] = None,
        lifetime_seconds: Optional[int] = None,
    ) -> DatabricksResponse:
        """Creates a token on behalf of a service principal."""
        kwargs: Dict[str, Any] = {}
        kwargs['application_id'] = application_id
        if comment is not None:
            kwargs['comment'] = comment
        if lifetime_seconds is not None:
            kwargs['lifetime_seconds'] = lifetime_seconds
        try:
            result = self._ws.token_management.create_obo_token(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def token_management_delete(self, token_id: str) -> DatabricksResponse:
        """Deletes a token, specified by its ID."""
        kwargs: Dict[str, Any] = {}
        kwargs['token_id'] = token_id
        try:
            result = self._ws.token_management.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def token_management_get(self, token_id: str) -> DatabricksResponse:
        """Gets information about a token, specified by its ID."""
        kwargs: Dict[str, Any] = {}
        kwargs['token_id'] = token_id
        try:
            result = self._ws.token_management.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def token_management_get_permission_levels(self) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.token_management.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def token_management_get_permissions(self) -> DatabricksResponse:
        """Gets the permissions of all tokens. Tokens can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.token_management.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def token_management_list(
        self,
        created_by_id: Optional[int] = None,
        created_by_username: Optional[str] = None,
    ) -> DatabricksResponse:
        """Lists all tokens associated with the specified workspace or user."""
        kwargs: Dict[str, Any] = {}
        if created_by_id is not None:
            kwargs['created_by_id'] = created_by_id
        if created_by_username is not None:
            kwargs['created_by_username'] = created_by_username
        try:
            result = list(self._ws.token_management.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def token_management_set_permissions(
        self,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.token_management.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def token_management_update_permissions(
        self,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on all tokens. Tokens can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.token_management.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # TOKENS (TokensAPI) — 3 methods
    # ============================================================================

    async def tokens_create(self, comment: Optional[str] = None, lifetime_seconds: Optional[int] = None) -> DatabricksResponse:
        """Creates and returns a token for a user. If this call is made through token authentication, it creates a token with the same client ID as the authenticated token. If the user's token quota is exceed..."""
        kwargs: Dict[str, Any] = {}
        if comment is not None:
            kwargs['comment'] = comment
        if lifetime_seconds is not None:
            kwargs['lifetime_seconds'] = lifetime_seconds
        try:
            result = self._ws.tokens.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def tokens_delete(self, token_id: str) -> DatabricksResponse:
        """Revokes an access token."""
        kwargs: Dict[str, Any] = {}
        kwargs['token_id'] = token_id
        try:
            result = self._ws.tokens.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def tokens_list(self) -> DatabricksResponse:
        """Lists all the valid tokens for a user-workspace pair."""
        kwargs: Dict[str, Any] = {}
        try:
            result = list(self._ws.tokens.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # USERS (UsersAPI) — 10 methods
    # ============================================================================

    async def users_create(
        self,
        active: Optional[bool] = None,
        display_name: Optional[str] = None,
        emails: Optional[List[Dict[str, Any]]] = None,
        entitlements: Optional[List[Dict[str, Any]]] = None,
        external_id: Optional[str] = None,
        groups: Optional[List[Dict[str, Any]]] = None,
        id: Optional[str] = None,
        name: Optional[Dict[str, Any]] = None,
        roles: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
        user_name: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new user in the Databricks workspace. This new user will also be added to the Databricks account."""
        kwargs: Dict[str, Any] = {}
        if active is not None:
            kwargs['active'] = active
        if display_name is not None:
            kwargs['display_name'] = display_name
        if emails is not None:
            kwargs['emails'] = emails
        if entitlements is not None:
            kwargs['entitlements'] = entitlements
        if external_id is not None:
            kwargs['external_id'] = external_id
        if groups is not None:
            kwargs['groups'] = groups
        if id is not None:
            kwargs['id'] = id
        if name is not None:
            kwargs['name'] = name
        if roles is not None:
            kwargs['roles'] = roles
        if schemas is not None:
            kwargs['schemas'] = schemas
        if user_name is not None:
            kwargs['user_name'] = user_name
        try:
            result = self._ws.users.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_delete(self, id: str) -> DatabricksResponse:
        """Deletes a user. Deleting a user from a Databricks workspace also removes objects associated with the user."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.users.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_get(
        self,
        id: str,
        attributes: Optional[str] = None,
        count: Optional[int] = None,
        excluded_attributes: Optional[str] = None,
        filter: Optional[str] = None,
        sort_by: Optional[str] = None,
        sort_order: Optional[Dict[str, Any]] = None,
        start_index: Optional[int] = None,
    ) -> DatabricksResponse:
        """Gets information for a specific user in Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if attributes is not None:
            kwargs['attributes'] = attributes
        if count is not None:
            kwargs['count'] = count
        if excluded_attributes is not None:
            kwargs['excluded_attributes'] = excluded_attributes
        if filter is not None:
            kwargs['filter'] = filter
        if sort_by is not None:
            kwargs['sort_by'] = sort_by
        if sort_order is not None:
            kwargs['sort_order'] = sort_order
        if start_index is not None:
            kwargs['start_index'] = start_index
        try:
            result = self._ws.users.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_get_permission_levels(self) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.users.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_get_permissions(self) -> DatabricksResponse:
        """Gets the permissions of all passwords. Passwords can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.users.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_list(
        self,
        attributes: Optional[str] = None,
        count: Optional[int] = None,
        excluded_attributes: Optional[str] = None,
        filter: Optional[str] = None,
        sort_by: Optional[str] = None,
        sort_order: Optional[Dict[str, Any]] = None,
        start_index: Optional[int] = None,
    ) -> DatabricksResponse:
        """Gets details for all the users associated with a Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        if attributes is not None:
            kwargs['attributes'] = attributes
        if count is not None:
            kwargs['count'] = count
        if excluded_attributes is not None:
            kwargs['excluded_attributes'] = excluded_attributes
        if filter is not None:
            kwargs['filter'] = filter
        if sort_by is not None:
            kwargs['sort_by'] = sort_by
        if sort_order is not None:
            kwargs['sort_order'] = sort_order
        if start_index is not None:
            kwargs['start_index'] = start_index
        try:
            result = list(self._ws.users.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_patch(
        self,
        id: str,
        operations: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Partially updates a user resource by applying the supplied operations on specific user attributes."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if operations is not None:
            kwargs['operations'] = operations
        if schemas is not None:
            kwargs['schemas'] = schemas
        try:
            result = self._ws.users.patch(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_set_permissions(
        self,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.users.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_update(
        self,
        id: str,
        active: Optional[bool] = None,
        display_name: Optional[str] = None,
        emails: Optional[List[Dict[str, Any]]] = None,
        entitlements: Optional[List[Dict[str, Any]]] = None,
        external_id: Optional[str] = None,
        groups: Optional[List[Dict[str, Any]]] = None,
        name: Optional[Dict[str, Any]] = None,
        roles: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
        user_name: Optional[str] = None,
    ) -> DatabricksResponse:
        """Replaces a user's information with the data supplied in request."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if active is not None:
            kwargs['active'] = active
        if display_name is not None:
            kwargs['display_name'] = display_name
        if emails is not None:
            kwargs['emails'] = emails
        if entitlements is not None:
            kwargs['entitlements'] = entitlements
        if external_id is not None:
            kwargs['external_id'] = external_id
        if groups is not None:
            kwargs['groups'] = groups
        if name is not None:
            kwargs['name'] = name
        if roles is not None:
            kwargs['roles'] = roles
        if schemas is not None:
            kwargs['schemas'] = schemas
        if user_name is not None:
            kwargs['user_name'] = user_name
        try:
            result = self._ws.users.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_update_permissions(
        self,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on all passwords. Passwords can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.users.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # USERS V2 (UsersV2API) — 10 methods
    # ============================================================================

    async def users_v2_create(
        self,
        active: Optional[bool] = None,
        display_name: Optional[str] = None,
        emails: Optional[List[Dict[str, Any]]] = None,
        entitlements: Optional[List[Dict[str, Any]]] = None,
        external_id: Optional[str] = None,
        groups: Optional[List[Dict[str, Any]]] = None,
        id: Optional[str] = None,
        name: Optional[Dict[str, Any]] = None,
        roles: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
        user_name: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new user in the Databricks workspace. This new user will also be added to the Databricks account."""
        kwargs: Dict[str, Any] = {}
        if active is not None:
            kwargs['active'] = active
        if display_name is not None:
            kwargs['display_name'] = display_name
        if emails is not None:
            kwargs['emails'] = emails
        if entitlements is not None:
            kwargs['entitlements'] = entitlements
        if external_id is not None:
            kwargs['external_id'] = external_id
        if groups is not None:
            kwargs['groups'] = groups
        if id is not None:
            kwargs['id'] = id
        if name is not None:
            kwargs['name'] = name
        if roles is not None:
            kwargs['roles'] = roles
        if schemas is not None:
            kwargs['schemas'] = schemas
        if user_name is not None:
            kwargs['user_name'] = user_name
        try:
            result = self._ws.users_v2.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_v2_delete(self, id: str) -> DatabricksResponse:
        """Deletes a user. Deleting a user from a Databricks workspace also removes objects associated with the user."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.users_v2.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_v2_get(
        self,
        id: str,
        attributes: Optional[str] = None,
        count: Optional[int] = None,
        excluded_attributes: Optional[str] = None,
        filter: Optional[str] = None,
        sort_by: Optional[str] = None,
        sort_order: Optional[Dict[str, Any]] = None,
        start_index: Optional[int] = None,
    ) -> DatabricksResponse:
        """Gets information for a specific user in Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if attributes is not None:
            kwargs['attributes'] = attributes
        if count is not None:
            kwargs['count'] = count
        if excluded_attributes is not None:
            kwargs['excluded_attributes'] = excluded_attributes
        if filter is not None:
            kwargs['filter'] = filter
        if sort_by is not None:
            kwargs['sort_by'] = sort_by
        if sort_order is not None:
            kwargs['sort_order'] = sort_order
        if start_index is not None:
            kwargs['start_index'] = start_index
        try:
            result = self._ws.users_v2.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_v2_get_permission_levels(self) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.users_v2.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_v2_get_permissions(self) -> DatabricksResponse:
        """Gets the permissions of all passwords. Passwords can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.users_v2.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_v2_list(
        self,
        attributes: Optional[str] = None,
        count: Optional[int] = None,
        excluded_attributes: Optional[str] = None,
        filter: Optional[str] = None,
        sort_by: Optional[str] = None,
        sort_order: Optional[Dict[str, Any]] = None,
        start_index: Optional[int] = None,
    ) -> DatabricksResponse:
        """Gets details for all the users associated with a Databricks workspace."""
        kwargs: Dict[str, Any] = {}
        if attributes is not None:
            kwargs['attributes'] = attributes
        if count is not None:
            kwargs['count'] = count
        if excluded_attributes is not None:
            kwargs['excluded_attributes'] = excluded_attributes
        if filter is not None:
            kwargs['filter'] = filter
        if sort_by is not None:
            kwargs['sort_by'] = sort_by
        if sort_order is not None:
            kwargs['sort_order'] = sort_order
        if start_index is not None:
            kwargs['start_index'] = start_index
        try:
            result = list(self._ws.users_v2.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_v2_patch(
        self,
        id: str,
        operations: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Partially updates a user resource by applying the supplied operations on specific user attributes."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if operations is not None:
            kwargs['operations'] = operations
        if schemas is not None:
            kwargs['schemas'] = schemas
        try:
            result = self._ws.users_v2.patch(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_v2_set_permissions(
        self,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.users_v2.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_v2_update(
        self,
        id: str,
        active: Optional[bool] = None,
        display_name: Optional[str] = None,
        emails: Optional[List[Dict[str, Any]]] = None,
        entitlements: Optional[List[Dict[str, Any]]] = None,
        external_id: Optional[str] = None,
        groups: Optional[List[Dict[str, Any]]] = None,
        name: Optional[Dict[str, Any]] = None,
        roles: Optional[List[Dict[str, Any]]] = None,
        schemas: Optional[List[Dict[str, Any]]] = None,
        user_name: Optional[str] = None,
    ) -> DatabricksResponse:
        """Replaces a user's information with the data supplied in request."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if active is not None:
            kwargs['active'] = active
        if display_name is not None:
            kwargs['display_name'] = display_name
        if emails is not None:
            kwargs['emails'] = emails
        if entitlements is not None:
            kwargs['entitlements'] = entitlements
        if external_id is not None:
            kwargs['external_id'] = external_id
        if groups is not None:
            kwargs['groups'] = groups
        if name is not None:
            kwargs['name'] = name
        if roles is not None:
            kwargs['roles'] = roles
        if schemas is not None:
            kwargs['schemas'] = schemas
        if user_name is not None:
            kwargs['user_name'] = user_name
        try:
            result = self._ws.users_v2.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def users_v2_update_permissions(
        self,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on all passwords. Passwords can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.users_v2.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # VECTOR SEARCH ENDPOINTS (VectorSearchEndpointsAPI) — 7 methods
    # ============================================================================

    async def vector_search_endpoints_create_endpoint(
        self,
        name: str,
        endpoint_type: Dict[str, Any],
        budget_policy_id: Optional[str] = None,
    ) -> DatabricksResponse:
        """Create a new endpoint."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['endpoint_type'] = endpoint_type
        if budget_policy_id is not None:
            kwargs['budget_policy_id'] = budget_policy_id
        try:
            result = self._ws.vector_search_endpoints.create_endpoint(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_endpoints_delete_endpoint(self, endpoint_name: str) -> DatabricksResponse:
        """Delete a vector search endpoint."""
        kwargs: Dict[str, Any] = {}
        kwargs['endpoint_name'] = endpoint_name
        try:
            result = self._ws.vector_search_endpoints.delete_endpoint(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_endpoints_get_endpoint(self, endpoint_name: str) -> DatabricksResponse:
        """Get details for a single vector search endpoint."""
        kwargs: Dict[str, Any] = {}
        kwargs['endpoint_name'] = endpoint_name
        try:
            result = self._ws.vector_search_endpoints.get_endpoint(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_endpoints_list_endpoints(self, page_token: Optional[str] = None) -> DatabricksResponse:
        """List all vector search endpoints in the workspace."""
        kwargs: Dict[str, Any] = {}
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.vector_search_endpoints.list_endpoints(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_endpoints_retrieve_user_visible_metrics(
        self,
        name: str,
        end_time: Optional[str] = None,
        granularity_in_seconds: Optional[int] = None,
        metrics: Optional[List[Dict[str, Any]]] = None,
        page_token: Optional[str] = None,
        start_time: Optional[str] = None,
    ) -> DatabricksResponse:
        """Retrieve user-visible metrics for an endpoint"""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if end_time is not None:
            kwargs['end_time'] = end_time
        if granularity_in_seconds is not None:
            kwargs['granularity_in_seconds'] = granularity_in_seconds
        if metrics is not None:
            kwargs['metrics'] = metrics
        if page_token is not None:
            kwargs['page_token'] = page_token
        if start_time is not None:
            kwargs['start_time'] = start_time
        try:
            result = self._ws.vector_search_endpoints.retrieve_user_visible_metrics(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_endpoints_update_endpoint_budget_policy(self, endpoint_name: str, budget_policy_id: str) -> DatabricksResponse:
        """Update the budget policy of an endpoint"""
        kwargs: Dict[str, Any] = {}
        kwargs['endpoint_name'] = endpoint_name
        kwargs['budget_policy_id'] = budget_policy_id
        try:
            result = self._ws.vector_search_endpoints.update_endpoint_budget_policy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_endpoints_update_endpoint_custom_tags(self, endpoint_name: str, custom_tags: List[Dict[str, Any]]) -> DatabricksResponse:
        """Update the custom tags of an endpoint."""
        kwargs: Dict[str, Any] = {}
        kwargs['endpoint_name'] = endpoint_name
        kwargs['custom_tags'] = custom_tags
        try:
            result = self._ws.vector_search_endpoints.update_endpoint_custom_tags(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # VECTOR SEARCH INDEXES (VectorSearchIndexesAPI) — 10 methods
    # ============================================================================

    async def vector_search_indexes_create_index(
        self,
        name: str,
        endpoint_name: str,
        primary_key: str,
        index_type: Dict[str, Any],
        delta_sync_index_spec: Optional[Dict[str, Any]] = None,
        direct_access_index_spec: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Create a new index."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['endpoint_name'] = endpoint_name
        kwargs['primary_key'] = primary_key
        kwargs['index_type'] = index_type
        if delta_sync_index_spec is not None:
            kwargs['delta_sync_index_spec'] = delta_sync_index_spec
        if direct_access_index_spec is not None:
            kwargs['direct_access_index_spec'] = direct_access_index_spec
        try:
            result = self._ws.vector_search_indexes.create_index(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_indexes_delete_data_vector_index(self, index_name: str, primary_keys: List[str]) -> DatabricksResponse:
        """Handles the deletion of data from a specified vector index."""
        kwargs: Dict[str, Any] = {}
        kwargs['index_name'] = index_name
        kwargs['primary_keys'] = primary_keys
        try:
            result = self._ws.vector_search_indexes.delete_data_vector_index(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_indexes_delete_index(self, index_name: str) -> DatabricksResponse:
        """Delete an index."""
        kwargs: Dict[str, Any] = {}
        kwargs['index_name'] = index_name
        try:
            result = self._ws.vector_search_indexes.delete_index(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_indexes_get_index(
        self,
        index_name: str,
        ensure_reranker_compatible: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Get an index."""
        kwargs: Dict[str, Any] = {}
        kwargs['index_name'] = index_name
        if ensure_reranker_compatible is not None:
            kwargs['ensure_reranker_compatible'] = ensure_reranker_compatible
        try:
            result = self._ws.vector_search_indexes.get_index(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_indexes_list_indexes(self, endpoint_name: str, page_token: Optional[str] = None) -> DatabricksResponse:
        """List all indexes in the given endpoint."""
        kwargs: Dict[str, Any] = {}
        kwargs['endpoint_name'] = endpoint_name
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.vector_search_indexes.list_indexes(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_indexes_query_index(
        self,
        index_name: str,
        columns: List[str],
        columns_to_rerank: Optional[List[str]] = None,
        filters_json: Optional[str] = None,
        num_results: Optional[int] = None,
        query_text: Optional[str] = None,
        query_type: Optional[str] = None,
        query_vector: Optional[List[float]] = None,
        reranker: Optional[Dict[str, Any]] = None,
        score_threshold: Optional[float] = None,
    ) -> DatabricksResponse:
        """Query the specified vector index."""
        kwargs: Dict[str, Any] = {}
        kwargs['index_name'] = index_name
        kwargs['columns'] = columns
        if columns_to_rerank is not None:
            kwargs['columns_to_rerank'] = columns_to_rerank
        if filters_json is not None:
            kwargs['filters_json'] = filters_json
        if num_results is not None:
            kwargs['num_results'] = num_results
        if query_text is not None:
            kwargs['query_text'] = query_text
        if query_type is not None:
            kwargs['query_type'] = query_type
        if query_vector is not None:
            kwargs['query_vector'] = query_vector
        if reranker is not None:
            kwargs['reranker'] = reranker
        if score_threshold is not None:
            kwargs['score_threshold'] = score_threshold
        try:
            result = self._ws.vector_search_indexes.query_index(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_indexes_query_next_page(
        self,
        index_name: str,
        endpoint_name: Optional[str] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Use `next_page_token` returned from previous `QueryVectorIndex` or `QueryVectorIndexNextPage` request to fetch next page of results."""
        kwargs: Dict[str, Any] = {}
        kwargs['index_name'] = index_name
        if endpoint_name is not None:
            kwargs['endpoint_name'] = endpoint_name
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = self._ws.vector_search_indexes.query_next_page(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_indexes_scan_index(
        self,
        index_name: str,
        last_primary_key: Optional[str] = None,
        num_results: Optional[int] = None,
    ) -> DatabricksResponse:
        """Scan the specified vector index and return the first `num_results` entries after the exclusive `primary_key`."""
        kwargs: Dict[str, Any] = {}
        kwargs['index_name'] = index_name
        if last_primary_key is not None:
            kwargs['last_primary_key'] = last_primary_key
        if num_results is not None:
            kwargs['num_results'] = num_results
        try:
            result = self._ws.vector_search_indexes.scan_index(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_indexes_sync_index(self, index_name: str) -> DatabricksResponse:
        """Triggers a synchronization process for a specified vector index."""
        kwargs: Dict[str, Any] = {}
        kwargs['index_name'] = index_name
        try:
            result = self._ws.vector_search_indexes.sync_index(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def vector_search_indexes_upsert_data_vector_index(self, index_name: str, inputs_json: str) -> DatabricksResponse:
        """Handles the upserting of data into a specified vector index."""
        kwargs: Dict[str, Any] = {}
        kwargs['index_name'] = index_name
        kwargs['inputs_json'] = inputs_json
        try:
            result = self._ws.vector_search_indexes.upsert_data_vector_index(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # VOLUMES (VolumesAPI) — 5 methods
    # ============================================================================

    async def volumes_create(
        self,
        catalog_name: str,
        schema_name: str,
        name: str,
        volume_type: Dict[str, Any],
        comment: Optional[str] = None,
        storage_location: Optional[str] = None,
    ) -> DatabricksResponse:
        """Creates a new volume."""
        kwargs: Dict[str, Any] = {}
        kwargs['catalog_name'] = catalog_name
        kwargs['schema_name'] = schema_name
        kwargs['name'] = name
        kwargs['volume_type'] = volume_type
        if comment is not None:
            kwargs['comment'] = comment
        if storage_location is not None:
            kwargs['storage_location'] = storage_location
        try:
            result = self._ws.volumes.create(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def volumes_delete(self, name: str) -> DatabricksResponse:
        """Deletes a volume from the specified parent catalog and schema."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.volumes.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def volumes_list(
        self,
        catalog_name: str,
        schema_name: str,
        include_browse: Optional[bool] = None,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets an array of volumes for the current metastore under the parent catalog and schema."""
        kwargs: Dict[str, Any] = {}
        kwargs['catalog_name'] = catalog_name
        kwargs['schema_name'] = schema_name
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.volumes.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def volumes_read(self, name: str, include_browse: Optional[bool] = None) -> DatabricksResponse:
        """Gets a volume from the metastore for a specific catalog and schema."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if include_browse is not None:
            kwargs['include_browse'] = include_browse
        try:
            result = self._ws.volumes.read(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def volumes_update(
        self,
        name: str,
        comment: Optional[str] = None,
        new_name: Optional[str] = None,
        owner: Optional[str] = None,
    ) -> DatabricksResponse:
        """Updates the specified volume under the specified parent catalog and schema."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if comment is not None:
            kwargs['comment'] = comment
        if new_name is not None:
            kwargs['new_name'] = new_name
        if owner is not None:
            kwargs['owner'] = owner
        try:
            result = self._ws.volumes.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # WAREHOUSES (WarehousesAPI) — 18 methods
    # ============================================================================

    async def warehouses_create(
        self,
        auto_stop_mins: Optional[int] = None,
        channel: Optional[Dict[str, Any]] = None,
        cluster_size: Optional[str] = None,
        creator_name: Optional[str] = None,
        enable_photon: Optional[bool] = None,
        enable_serverless_compute: Optional[bool] = None,
        instance_profile_arn: Optional[str] = None,
        max_num_clusters: Optional[int] = None,
        min_num_clusters: Optional[int] = None,
        name: Optional[str] = None,
        spot_instance_policy: Optional[Dict[str, Any]] = None,
        tags: Optional[Dict[str, Any]] = None,
        warehouse_type: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Creates a new SQL warehouse."""
        kwargs: Dict[str, Any] = {}
        if auto_stop_mins is not None:
            kwargs['auto_stop_mins'] = auto_stop_mins
        if channel is not None:
            kwargs['channel'] = channel
        if cluster_size is not None:
            kwargs['cluster_size'] = cluster_size
        if creator_name is not None:
            kwargs['creator_name'] = creator_name
        if enable_photon is not None:
            kwargs['enable_photon'] = enable_photon
        if enable_serverless_compute is not None:
            kwargs['enable_serverless_compute'] = enable_serverless_compute
        if instance_profile_arn is not None:
            kwargs['instance_profile_arn'] = instance_profile_arn
        if max_num_clusters is not None:
            kwargs['max_num_clusters'] = max_num_clusters
        if min_num_clusters is not None:
            kwargs['min_num_clusters'] = min_num_clusters
        if name is not None:
            kwargs['name'] = name
        if spot_instance_policy is not None:
            kwargs['spot_instance_policy'] = spot_instance_policy
        if tags is not None:
            kwargs['tags'] = tags
        if warehouse_type is not None:
            kwargs['warehouse_type'] = warehouse_type
        try:
            result = self._ws.warehouses.create(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_create_default_warehouse_override(
        self,
        default_warehouse_override: Dict[str, Any],
        default_warehouse_override_id: str,
    ) -> DatabricksResponse:
        """Creates a new default warehouse override for a user. Users can create their own override. Admins can create overrides for any user."""
        kwargs: Dict[str, Any] = {}
        kwargs['default_warehouse_override'] = default_warehouse_override
        kwargs['default_warehouse_override_id'] = default_warehouse_override_id
        try:
            result = self._ws.warehouses.create_default_warehouse_override(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_delete(self, id: str) -> DatabricksResponse:
        """Deletes a SQL warehouse."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.warehouses.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_delete_default_warehouse_override(self, name: str) -> DatabricksResponse:
        """Deletes the default warehouse override for a user. Users can delete their own override. Admins can delete overrides for any user. After deletion, the workspace default warehouse will be used."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.warehouses.delete_default_warehouse_override(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_edit(
        self,
        id: str,
        auto_stop_mins: Optional[int] = None,
        channel: Optional[Dict[str, Any]] = None,
        cluster_size: Optional[str] = None,
        creator_name: Optional[str] = None,
        enable_photon: Optional[bool] = None,
        enable_serverless_compute: Optional[bool] = None,
        instance_profile_arn: Optional[str] = None,
        max_num_clusters: Optional[int] = None,
        min_num_clusters: Optional[int] = None,
        name: Optional[str] = None,
        spot_instance_policy: Optional[Dict[str, Any]] = None,
        tags: Optional[Dict[str, Any]] = None,
        warehouse_type: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Updates the configuration for a SQL warehouse."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        if auto_stop_mins is not None:
            kwargs['auto_stop_mins'] = auto_stop_mins
        if channel is not None:
            kwargs['channel'] = channel
        if cluster_size is not None:
            kwargs['cluster_size'] = cluster_size
        if creator_name is not None:
            kwargs['creator_name'] = creator_name
        if enable_photon is not None:
            kwargs['enable_photon'] = enable_photon
        if enable_serverless_compute is not None:
            kwargs['enable_serverless_compute'] = enable_serverless_compute
        if instance_profile_arn is not None:
            kwargs['instance_profile_arn'] = instance_profile_arn
        if max_num_clusters is not None:
            kwargs['max_num_clusters'] = max_num_clusters
        if min_num_clusters is not None:
            kwargs['min_num_clusters'] = min_num_clusters
        if name is not None:
            kwargs['name'] = name
        if spot_instance_policy is not None:
            kwargs['spot_instance_policy'] = spot_instance_policy
        if tags is not None:
            kwargs['tags'] = tags
        if warehouse_type is not None:
            kwargs['warehouse_type'] = warehouse_type
        try:
            result = self._ws.warehouses.edit(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_get(self, id: str) -> DatabricksResponse:
        """Gets the information for a single SQL warehouse."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.warehouses.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_get_default_warehouse_override(self, name: str) -> DatabricksResponse:
        """Returns the default warehouse override for a user. Users can fetch their own override. Admins can fetch overrides for any user. If no override exists, the UI will fallback to the workspace default ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.warehouses.get_default_warehouse_override(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_get_permission_levels(self, warehouse_id: str) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        kwargs['warehouse_id'] = warehouse_id
        try:
            result = self._ws.warehouses.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_get_permissions(self, warehouse_id: str) -> DatabricksResponse:
        """Gets the permissions of a SQL warehouse. SQL warehouses can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['warehouse_id'] = warehouse_id
        try:
            result = self._ws.warehouses.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_get_workspace_warehouse_config(self) -> DatabricksResponse:
        """Gets the workspace level configuration that is shared by all SQL warehouses in a workspace."""
        kwargs: Dict[str, Any] = {}
        try:
            result = self._ws.warehouses.get_workspace_warehouse_config(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_list(
        self,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        run_as_user_id: Optional[int] = None,
    ) -> DatabricksResponse:
        """Lists all SQL warehouses that a user has access to."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        if run_as_user_id is not None:
            kwargs['run_as_user_id'] = run_as_user_id
        try:
            result = list(self._ws.warehouses.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_list_default_warehouse_overrides(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """Lists all default warehouse overrides in the workspace. Only workspace administrators can list all overrides."""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.warehouses.list_default_warehouse_overrides(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_set_permissions(
        self,
        warehouse_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['warehouse_id'] = warehouse_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.warehouses.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_set_workspace_warehouse_config(
        self,
        channel: Optional[Dict[str, Any]] = None,
        config_param: Optional[Dict[str, Any]] = None,
        data_access_config: Optional[List[Dict[str, Any]]] = None,
        enable_serverless_compute: Optional[bool] = None,
        enabled_warehouse_types: Optional[List[Dict[str, Any]]] = None,
        global_param: Optional[Dict[str, Any]] = None,
        google_service_account: Optional[str] = None,
        instance_profile_arn: Optional[str] = None,
        security_policy: Optional[Dict[str, Any]] = None,
        sql_configuration_parameters: Optional[Dict[str, Any]] = None,
    ) -> DatabricksResponse:
        """Sets the workspace level configuration that is shared by all SQL warehouses in a workspace."""
        kwargs: Dict[str, Any] = {}
        if channel is not None:
            kwargs['channel'] = channel
        if config_param is not None:
            kwargs['config_param'] = config_param
        if data_access_config is not None:
            kwargs['data_access_config'] = data_access_config
        if enable_serverless_compute is not None:
            kwargs['enable_serverless_compute'] = enable_serverless_compute
        if enabled_warehouse_types is not None:
            kwargs['enabled_warehouse_types'] = enabled_warehouse_types
        if global_param is not None:
            kwargs['global_param'] = global_param
        if google_service_account is not None:
            kwargs['google_service_account'] = google_service_account
        if instance_profile_arn is not None:
            kwargs['instance_profile_arn'] = instance_profile_arn
        if security_policy is not None:
            kwargs['security_policy'] = security_policy
        if sql_configuration_parameters is not None:
            kwargs['sql_configuration_parameters'] = sql_configuration_parameters
        try:
            result = self._ws.warehouses.set_workspace_warehouse_config(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_start(self, id: str) -> DatabricksResponse:
        """Starts a SQL warehouse."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.warehouses.start(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_stop(self, id: str) -> DatabricksResponse:
        """Stops a SQL warehouse."""
        kwargs: Dict[str, Any] = {}
        kwargs['id'] = id
        try:
            result = self._ws.warehouses.stop(**kwargs)
            data = _serialize(getattr(result, 'response', result))
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_update_default_warehouse_override(
        self,
        name: str,
        default_warehouse_override: Dict[str, Any],
        update_mask: str,
        allow_missing: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Updates an existing default warehouse override for a user. Users can update their own override. Admins can update overrides for any user."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['default_warehouse_override'] = default_warehouse_override
        kwargs['update_mask'] = update_mask
        if allow_missing is not None:
            kwargs['allow_missing'] = allow_missing
        try:
            result = self._ws.warehouses.update_default_warehouse_override(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def warehouses_update_permissions(
        self,
        warehouse_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on a SQL warehouse. SQL warehouses can inherit permissions from their root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['warehouse_id'] = warehouse_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.warehouses.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # WORKSPACE (WorkspaceExt) — 12 methods
    # ============================================================================

    async def workspace_delete(self, path: str, recursive: Optional[bool] = None) -> DatabricksResponse:
        """Deletes an object or a directory (and optionally recursively deletes all objects in the directory). * If `path` does not exist, this call returns an error `RESOURCE_DOES_NOT_EXIST`. * If `path` is ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        if recursive is not None:
            kwargs['recursive'] = recursive
        try:
            result = self._ws.workspace.delete(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_download(self, path: str, format: Optional[Dict[str, Any]] = None) -> DatabricksResponse:
        """Downloads notebook or file from the workspace"""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        if format is not None:
            kwargs['format'] = format
        try:
            result = self._ws.workspace.download(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_export(self, path: str, format: Optional[Dict[str, Any]] = None) -> DatabricksResponse:
        """Exports an object or the contents of an entire directory."""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        if format is not None:
            kwargs['format'] = format
        try:
            result = self._ws.workspace.export(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_get_permission_levels(self, workspace_object_type: str, workspace_object_id: str) -> DatabricksResponse:
        """Gets the permission levels that a user can have on an object."""
        kwargs: Dict[str, Any] = {}
        kwargs['workspace_object_type'] = workspace_object_type
        kwargs['workspace_object_id'] = workspace_object_id
        try:
            result = self._ws.workspace.get_permission_levels(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_get_permissions(self, workspace_object_type: str, workspace_object_id: str) -> DatabricksResponse:
        """Gets the permissions of a workspace object. Workspace objects can inherit permissions from their parent objects or root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['workspace_object_type'] = workspace_object_type
        kwargs['workspace_object_id'] = workspace_object_id
        try:
            result = self._ws.workspace.get_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_get_status(self, path: str) -> DatabricksResponse:
        """Gets the status of an object or a directory. If `path` does not exist, this call returns an error `RESOURCE_DOES_NOT_EXIST`."""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        try:
            result = self._ws.workspace.get_status(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_import_(
        self,
        path: str,
        content: Optional[str] = None,
        format: Optional[Dict[str, Any]] = None,
        language: Optional[Dict[str, Any]] = None,
        overwrite: Optional[bool] = None,
    ) -> DatabricksResponse:
        """Imports a workspace object (for example, a notebook or file) or the contents of an entire directory. If `path` already exists and `overwrite` is set to `false`, this call returns an error `RESOURCE..."""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        if content is not None:
            kwargs['content'] = content
        if format is not None:
            kwargs['format'] = format
        if language is not None:
            kwargs['language'] = language
        if overwrite is not None:
            kwargs['overwrite'] = overwrite
        try:
            result = self._ws.workspace.import_(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_list(
        self,
        path: str,
        notebooks_modified_after: Optional[int] = None,
        recursive: Optional[bool] = False,
    ) -> DatabricksResponse:
        """List workspace objects"""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        if notebooks_modified_after is not None:
            kwargs['notebooks_modified_after'] = notebooks_modified_after
        if recursive is not None:
            kwargs['recursive'] = recursive
        try:
            result = list(self._ws.workspace.list(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_mkdirs(self, path: str) -> DatabricksResponse:
        """Creates the specified directory (and necessary parent directories if they do not exist). If there is an object (not a directory) at any prefix of the input path, this call returns an error `RESOURC..."""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        try:
            result = self._ws.workspace.mkdirs(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_set_permissions(
        self,
        workspace_object_type: str,
        workspace_object_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Sets permissions on an object, replacing existing permissions if they exist. Deletes all direct permissions if none are specified. Objects can inherit permissions from their parent objects or root ..."""
        kwargs: Dict[str, Any] = {}
        kwargs['workspace_object_type'] = workspace_object_type
        kwargs['workspace_object_id'] = workspace_object_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.workspace.set_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_update_permissions(
        self,
        workspace_object_type: str,
        workspace_object_id: str,
        access_control_list: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates the permissions on a workspace object. Workspace objects can inherit permissions from their parent objects or root object."""
        kwargs: Dict[str, Any] = {}
        kwargs['workspace_object_type'] = workspace_object_type
        kwargs['workspace_object_id'] = workspace_object_id
        if access_control_list is not None:
            kwargs['access_control_list'] = access_control_list
        try:
            result = self._ws.workspace.update_permissions(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_upload(
        self,
        path: str,
        content: Union[bytes, bytes],
        format: Optional[Dict[str, Any]] = None,
        language: Optional[Dict[str, Any]] = None,
        overwrite: Optional[bool] = False,
    ) -> DatabricksResponse:
        """Uploads a workspace object (for example, a notebook or file) or the contents of an entire directory (`DBC` format)."""
        kwargs: Dict[str, Any] = {}
        kwargs['path'] = path
        kwargs['content'] = content
        if format is not None:
            kwargs['format'] = format
        if language is not None:
            kwargs['language'] = language
        if overwrite is not None:
            kwargs['overwrite'] = overwrite
        try:
            result = self._ws.workspace.upload(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # WORKSPACE BINDINGS (WorkspaceBindingsAPI) — 4 methods
    # ============================================================================

    async def workspace_bindings_get(self, name: str) -> DatabricksResponse:
        """Gets workspace bindings of the catalog. The caller must be a metastore admin or an owner of the catalog."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.workspace_bindings.get(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_bindings_get_bindings(
        self,
        securable_type: str,
        securable_name: str,
        max_results: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """Gets workspace bindings of the securable. The caller must be a metastore admin or an owner of the securable."""
        kwargs: Dict[str, Any] = {}
        kwargs['securable_type'] = securable_type
        kwargs['securable_name'] = securable_name
        if max_results is not None:
            kwargs['max_results'] = max_results
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.workspace_bindings.get_bindings(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_bindings_update(
        self,
        name: str,
        assign_workspaces: Optional[List[int]] = None,
        unassign_workspaces: Optional[List[int]] = None,
    ) -> DatabricksResponse:
        """Updates workspace bindings of the catalog. The caller must be a metastore admin or an owner of the catalog."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        if assign_workspaces is not None:
            kwargs['assign_workspaces'] = assign_workspaces
        if unassign_workspaces is not None:
            kwargs['unassign_workspaces'] = unassign_workspaces
        try:
            result = self._ws.workspace_bindings.update(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_bindings_update_bindings(
        self,
        securable_type: str,
        securable_name: str,
        add: Optional[List[Dict[str, Any]]] = None,
        remove: Optional[List[Dict[str, Any]]] = None,
    ) -> DatabricksResponse:
        """Updates workspace bindings of the securable. The caller must be a metastore admin or an owner of the securable."""
        kwargs: Dict[str, Any] = {}
        kwargs['securable_type'] = securable_type
        kwargs['securable_name'] = securable_name
        if add is not None:
            kwargs['add'] = add
        if remove is not None:
            kwargs['remove'] = remove
        try:
            result = self._ws.workspace_bindings.update_bindings(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # WORKSPACE CONF (WorkspaceConfAPI) — 2 methods
    # ============================================================================

    async def workspace_conf_get_status(self, keys: str) -> DatabricksResponse:
        """Gets the configuration status for a workspace."""
        kwargs: Dict[str, Any] = {}
        kwargs['keys'] = keys
        try:
            result = self._ws.workspace_conf.get_status(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_conf_set_status(self, contents: Dict[str, str]) -> DatabricksResponse:
        """Sets the configuration status for a workspace, including enabling or disabling it."""
        kwargs: Dict[str, Any] = {}
        kwargs['contents'] = contents
        try:
            result = self._ws.workspace_conf.set_status(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # WORKSPACE ENTITY TAG ASSIGNMENTS (WorkspaceEntityTagAssignmentsAPI) — 5 methods
    # ============================================================================

    async def workspace_entity_tag_assignments_create_tag_assignment(self, tag_assignment: Dict[str, Any]) -> DatabricksResponse:
        """Create a tag assignment"""
        kwargs: Dict[str, Any] = {}
        kwargs['tag_assignment'] = tag_assignment
        try:
            result = self._ws.workspace_entity_tag_assignments.create_tag_assignment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_entity_tag_assignments_delete_tag_assignment(
        self,
        entity_type: str,
        entity_id: str,
        tag_key: str,
    ) -> DatabricksResponse:
        """Delete a tag assignment"""
        kwargs: Dict[str, Any] = {}
        kwargs['entity_type'] = entity_type
        kwargs['entity_id'] = entity_id
        kwargs['tag_key'] = tag_key
        try:
            result = self._ws.workspace_entity_tag_assignments.delete_tag_assignment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_entity_tag_assignments_get_tag_assignment(
        self,
        entity_type: str,
        entity_id: str,
        tag_key: str,
    ) -> DatabricksResponse:
        """Get a tag assignment"""
        kwargs: Dict[str, Any] = {}
        kwargs['entity_type'] = entity_type
        kwargs['entity_id'] = entity_id
        kwargs['tag_key'] = tag_key
        try:
            result = self._ws.workspace_entity_tag_assignments.get_tag_assignment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_entity_tag_assignments_list_tag_assignments(
        self,
        entity_type: str,
        entity_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
    ) -> DatabricksResponse:
        """List the tag assignments for an entity"""
        kwargs: Dict[str, Any] = {}
        kwargs['entity_type'] = entity_type
        kwargs['entity_id'] = entity_id
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.workspace_entity_tag_assignments.list_tag_assignments(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_entity_tag_assignments_update_tag_assignment(
        self,
        entity_type: str,
        entity_id: str,
        tag_key: str,
        tag_assignment: Dict[str, Any],
        update_mask: str,
    ) -> DatabricksResponse:
        """Update a tag assignment"""
        kwargs: Dict[str, Any] = {}
        kwargs['entity_type'] = entity_type
        kwargs['entity_id'] = entity_id
        kwargs['tag_key'] = tag_key
        kwargs['tag_assignment'] = tag_assignment
        kwargs['update_mask'] = update_mask
        try:
            result = self._ws.workspace_entity_tag_assignments.update_tag_assignment(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # WORKSPACE IAM V2 (WorkspaceIamV2API) — 4 methods
    # ============================================================================

    async def workspace_iam_v2_get_workspace_access_detail_local(self, principal_id: int, view: Optional[Dict[str, Any]] = None) -> DatabricksResponse:
        """Returns the access details for a principal in the current workspace. Allows for checking access details for any provisioned principal (user, service principal, or group) in the current workspace. *..."""
        kwargs: Dict[str, Any] = {}
        kwargs['principal_id'] = principal_id
        if view is not None:
            kwargs['view'] = view
        try:
            result = self._ws.workspace_iam_v2.get_workspace_access_detail_local(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_iam_v2_resolve_group_proxy(self, external_id: str) -> DatabricksResponse:
        """Resolves a group with the given external ID from the customer's IdP. If the group does not exist, it will be created in the account. If the customer is not onboarded onto Automatic Identity Managem..."""
        kwargs: Dict[str, Any] = {}
        kwargs['external_id'] = external_id
        try:
            result = self._ws.workspace_iam_v2.resolve_group_proxy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_iam_v2_resolve_service_principal_proxy(self, external_id: str) -> DatabricksResponse:
        """Resolves an SP with the given external ID from the customer's IdP. If the SP does not exist, it will be created. If the customer is not onboarded onto Automatic Identity Management (AIM), this will..."""
        kwargs: Dict[str, Any] = {}
        kwargs['external_id'] = external_id
        try:
            result = self._ws.workspace_iam_v2.resolve_service_principal_proxy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_iam_v2_resolve_user_proxy(self, external_id: str) -> DatabricksResponse:
        """Resolves a user with the given external ID from the customer's IdP. If the user does not exist, it will be created. If the customer is not onboarded onto Automatic Identity Management (AIM), this w..."""
        kwargs: Dict[str, Any] = {}
        kwargs['external_id'] = external_id
        try:
            result = self._ws.workspace_iam_v2.resolve_user_proxy(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    # ============================================================================
    # WORKSPACE SETTINGS V2 (WorkspaceSettingsV2API) — 3 methods
    # ============================================================================

    async def workspace_settings_v2_get_public_workspace_setting(self, name: str) -> DatabricksResponse:
        """Get a setting value at workspace level. See :method:settingsv2/listworkspacesettingsmetadata for list of setting available via public APIs."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        try:
            result = self._ws.workspace_settings_v2.get_public_workspace_setting(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_settings_v2_list_workspace_settings_metadata(self, page_size: Optional[int] = None, page_token: Optional[str] = None) -> DatabricksResponse:
        """List valid setting keys and metadata. These settings are available to be referenced via GET :method:settingsv2/getpublicworkspacesetting and PATCH :method:settingsv2/patchpublicworkspacesetting APIs"""
        kwargs: Dict[str, Any] = {}
        if page_size is not None:
            kwargs['page_size'] = page_size
        if page_token is not None:
            kwargs['page_token'] = page_token
        try:
            result = list(self._ws.workspace_settings_v2.list_workspace_settings_metadata(**kwargs))
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

    async def workspace_settings_v2_patch_public_workspace_setting(self, name: str, setting: Dict[str, Any]) -> DatabricksResponse:
        """Patch a setting value at workspace level. See :method:settingsv2/listworkspacesettingsmetadata for list of setting available via public APIs at workspace level. To determine the correct field to in..."""
        kwargs: Dict[str, Any] = {}
        kwargs['name'] = name
        kwargs['setting'] = setting
        try:
            result = self._ws.workspace_settings_v2.patch_public_workspace_setting(**kwargs)
            data = _serialize(result)
            return DatabricksResponse(success=True, data=data)
        except Exception as e:
            return DatabricksResponse(
                success=False, error=type(e).__name__, message=str(e)
            )

